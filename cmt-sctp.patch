diff --git a/Makefile b/Makefile
index f0cb9ac..2b803e3 100644
--- a/Makefile
+++ b/Makefile
@@ -1,3 +1,12 @@
+OSTYPE = $(shell uname)
+ifeq ($(OSTYPE),Darwin)
+HRTIMEFLAGS = -DHAVE_MACH_ABSOLUTE_TIME
+endif
+ifeq ($(OSTYPE),Linux)
+HRTIMEFLAGS = -lrt -DHAVE_CLOCK_GETTIME
+endif
+
+
 all: checkmakefiles
 	cd src && $(MAKE)
 
@@ -10,7 +19,8 @@ cleanall: checkmakefiles
 	rm -f src/Makefile
 
 makefiles:
-	cd src && opp_makemake -f --deep --make-so -o inet -O out $$NSC_VERSION_DEF
+	# cd src && opp_makemake -f --deep -lpcap -lssl -lcrypto -DHAVE_PCAP -DUSE_TF -o inet -O out $$NSC_VERSION_DEF
+	cd src && opp_makemake -f --deep -lpcap -lssl -lcrypto -DPRIVATE -DHAVE_PCAP -DUSE_TF -o inet -O out $$NSC_VERSION_DEF
 
 checkmakefiles:
 	@if [ ! -f src/Makefile ]; then \
diff --git a/examples/sctp/cmttest4/README b/examples/sctp/cmttest4/README
new file mode 100644
index 0000000..e69de29
diff --git a/examples/sctp/cmttest4/cmttest4.ned b/examples/sctp/cmttest4/cmttest4.ned
new file mode 100644
index 0000000..9fcf40f
--- /dev/null
+++ b/examples/sctp/cmttest4/cmttest4.ned
@@ -0,0 +1,328 @@
+// * --------------------------------------------------------------------------
+// *
+// *     //====//  //===== <===//===>  //====//
+// *    //        //          //      //    //    SCTP Optimization Project
+// *   //=====   //          //      //====//   ==============================
+// *        //  //          //      //           University of Duisburg-Essen
+// *  =====//  //=====     //      //
+// *
+// * --------------------------------------------------------------------------
+// *
+// *   Copyright (C) 2009-2012 by Thomas Dreibholz
+// *
+// *   This program is free software: you can redistribute it and/or modify
+// *   it under the terms of the GNU General Public License as published by
+// *   the Free Software Foundation, either version 3 of the License, or
+// *   (at your option) any later version.
+// *
+// *   This program is distributed in the hope that it will be useful,
+// *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+// *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// *   GNU General Public License for more details.
+// *
+// *   You should have received a copy of the GNU General Public License
+// *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+// *
+// *   Contact: dreibh@iem.uni-due.de
+
+package inet.examples.sctp.cmttest4;
+
+import inet.nodes.inet.StandardHost;
+import inet.nodes.inet.Router;
+import ned.DatarateChannel;
+import ned.DelayChannel;
+import ned.IdealChannel;
+import inet.networklayer.autorouting.MultihomedFlatNetworkConfigurator;
+
+
+channel coreChannel extends DatarateChannel
+{
+   int netID = default(0);        // NOTE: Shared by all networks!
+   datarate  = default(1 Mbps);
+   delay     = default(0ms);
+   ber       = default(0);
+   per       = default(0);
+   @display("ls=black,3;t=NetID=$netID");
+}
+
+channel accessChannel extends DatarateChannel
+{
+   int netID = default(1);
+   datarate  = default(1 Gbps);   // NOTE: 1 Gbit/s access channel!
+   delay     = default(0.1ms);
+   ber       = default(0);
+   per       = default(0);
+   @display("ls=blue,5;t=NetID=$netID");
+}
+
+channel connectorChannel extends IdealChannel
+{
+   int netID = default(1);
+   @display("ls=darkgray,5;t=NetID=$netID");
+}
+
+
+module Core
+{
+   // ====== System Parameters ==============================================
+   parameters:
+      @display("bgi=maps/world,s");
+      int    netIDBase        = default(2048);
+      int    systemsMain      = default(1);
+      int    systemsReference = default(0);
+      int    disjointTrails   = default(2);
+      int    bottleneckTrails = default(0);
+      int    uplinkTrails     = default(0);
+      int    downlinkTrails   = default(0);
+
+   // ====== Gates ==========================================================
+   gates:
+      inout westernDownlink[downlinkTrails] @loose;
+      inout easternDownlink[downlinkTrails] @loose;
+      inout westernUplink[uplinkTrails] @loose;
+      inout easternUplink[uplinkTrails] @loose;
+
+   // ====== Network Components =============================================
+   submodules:
+      // ------ Routers -----------------------------------------------------
+      westernBorderRouter[disjointTrails * (1 + bottleneckTrails)] : StandardHost {
+         parameters:
+            IPForward = true;
+            @display("p=500,150,c,150;i=abstract/router_l,gold");
+         gates:
+            pppg[1 + systemsMain + systemsReference + (downlinkTrails > 0 ? 1 : 0)];
+      }
+      westernCoreRouter[disjointTrails] : StandardHost {
+         parameters:
+            IPForward = true;
+            @display("p=700,150,c,150;i=abstract/router_l,gold");
+         gates:
+            pppg[1 + (1 + bottleneckTrails)];
+      }
+      easternCoreRouter[disjointTrails] : StandardHost {
+         parameters:
+            IPForward = true;
+            @display("p=1000,150,c,150;i=abstract/router_l,gold");
+         gates:
+            pppg[1 + (1 + bottleneckTrails)];
+      }
+      easternBorderRouter[disjointTrails * (1 + bottleneckTrails)] : StandardHost {
+         parameters:
+            IPForward = true;
+            @display("p=1200,150,c,150;i=abstract/router_l,gold");
+         gates:
+            pppg[1 + systemsMain + systemsReference + (downlinkTrails > 0 ? 1 : 0)];
+      }
+
+      westernUplinkRouter[uplinkTrails] : StandardHost {
+         parameters:
+            IPForward = true;
+            @display("p=350,50,r,150;i=abstract/router_l,gray");
+         gates:
+            pppg[1 + systemsMain + systemsReference];
+      }
+      easternUplinkRouter[uplinkTrails] : StandardHost {
+         parameters:
+            IPForward = true;
+            @display("p=1250,50,r,150;i=abstract/router_l,gray");
+         gates:
+            pppg[1 + systemsMain + systemsReference];
+      }
+
+      // ------ Systems -----------------------------------------------------
+      clientMain[systemsMain] : StandardHost {
+         parameters:
+            IPForward = false;
+            @display("p=50,50,c,200;i=device/laptop_l,green");
+         gates:
+            pppg[disjointTrails * (1 + bottleneckTrails) + uplinkTrails];
+      }
+      clientReference[systemsReference] : StandardHost {
+         parameters:
+            IPForward = false;
+            @display("p=150,150,c,200;i=device/laptop_l,red");
+         gates:
+            pppg[disjointTrails * (1 + bottleneckTrails) + uplinkTrails];
+      }
+      serverMain[systemsMain] : StandardHost {
+         parameters:
+            IPForward = false;
+            @display("p=1650,50,c,200;i=device/server_l,green");
+         gates:
+            pppg[disjointTrails * (1 + bottleneckTrails) + uplinkTrails];
+      }
+      serverReference[systemsReference] : StandardHost {
+         parameters:
+            IPForward = false;
+            @display("p=1550,150,c,200;i=device/server_l,red");
+         gates:
+            pppg[disjointTrails * (1 + bottleneckTrails) + uplinkTrails];
+      }
+
+   // ====== Connections ====================================================
+   connections:
+
+      // Core Router [disjointTrails]:
+      // ppp0 <--> other core router
+      // ppp1 <--> disjoint path to border router
+      // pppx <--> shared paths to border routers; x=2+b
+
+      // Border Router [disjointTrails * (1 + bottleneckTrails) + uplinkTrails]:
+      // ppp0 <--> core router OR uplink router
+      // pppX <--> system; x=1+s (main); X=1+systemsMain+s (reference)
+      // pppY <--> downlink router; Y=2+systemsMain+systemsReference
+
+      // System
+      // pppX <--> border router of path X
+      //   ppp0: disjoint path #1
+      //      ppp(1-bottleneckTrails): corresponding bottleneck path
+
+      // ------ Disjoint Links ----------------------------------------------
+      for d=0..disjointTrails-1 {
+         // NOTE: These connections MUST be the first ones, since the
+         //       simulation script assumes the bottleneck interface to be ppp0!
+         westernCoreRouter[d].pppg[0]
+            <--> coreChannel { netID = 0; @display("ls=blue,3"); }
+            <--> easternCoreRouter[d].pppg[0];
+
+         westernBorderRouter[d].pppg[0]
+            <--> accessChannel { netID = 0; @display("ls=blue,5"); }
+            <--> westernCoreRouter[d].pppg[1];
+         easternBorderRouter[d].pppg[0]
+            <--> accessChannel { netID = 0; @display("ls=blue,5"); }
+            <--> easternCoreRouter[d].pppg[1];
+      }
+
+      for d=0..disjointTrails-1,
+         for s=0..max(systemsMain, systemsReference)-1 {
+            clientMain[s].pppg[d * (1 + bottleneckTrails) + 0]
+               <--> accessChannel { netID = netIDBase + d * (1 + bottleneckTrails); @display("ls=green,5"); }
+               <--> westernBorderRouter[d].pppg[1 + s]
+               if (s < systemsMain);
+            serverMain[s].pppg[d * (1 + bottleneckTrails) + 0]
+               <--> accessChannel { netID = netIDBase + d * (1 + bottleneckTrails); @display("ls=green,5"); }
+               <--> easternBorderRouter[d].pppg[1 + s]
+               if (s < systemsMain);
+
+            clientReference[s].pppg[d * (1 + bottleneckTrails) + 0]
+               <--> accessChannel { netID = netIDBase + d * (1 + bottleneckTrails); @display("ls=red,5"); }
+               <--> westernBorderRouter[d].pppg[1 + systemsMain + s]
+               if (s < systemsReference);
+            serverReference[s].pppg[d * (1 + bottleneckTrails) + 0]
+               <--> accessChannel { netID = netIDBase + d * (1 + bottleneckTrails); @display("ls=red,5"); }
+               <--> easternBorderRouter[d].pppg[1 + systemsMain + s]
+               if (s < systemsReference);
+      }
+
+      // ------ Shared Bottleneck Links -------------------------------------
+      for d=0..disjointTrails-1,
+         for b=0..bottleneckTrails-1 {
+            westernBorderRouter[disjointTrails + (d * bottleneckTrails) + b].pppg++
+               <--> accessChannel { netID = 0; @display("ls=blue,5"); }
+               <--> westernCoreRouter[d].pppg[2 + b];
+            easternBorderRouter[disjointTrails + (d * bottleneckTrails) + b].pppg++
+               <--> accessChannel { netID = 0; @display("ls=blue,5"); }
+               <--> easternCoreRouter[d].pppg[2 + b];
+      }
+
+      for d=0..disjointTrails-1,
+         for b=0..bottleneckTrails-1,
+            for s=0..max(systemsMain, systemsReference)-1 {
+               clientMain[s].pppg[d * (1 + bottleneckTrails) + (b + 1)]
+                  <--> accessChannel { netID = netIDBase + d * (1 + bottleneckTrails) + (b + 1); @display("ls=green,5,da"); }
+                  <--> westernBorderRouter[disjointTrails + (d * bottleneckTrails) + b].pppg[1 + s]
+                  if (s < systemsMain);
+               serverMain[s].pppg[d * (1 + bottleneckTrails) + (b + 1)]
+                  <--> accessChannel { netID = netIDBase + d * (1 + bottleneckTrails) + (b + 1); @display("ls=green,5,da"); }
+                  <--> easternBorderRouter[disjointTrails + (d * bottleneckTrails) + b].pppg[1 + s]
+                  if (s < systemsMain);
+
+               clientReference[s].pppg[d * (1 + bottleneckTrails) + (b + 1)]
+                  <--> accessChannel { netID = netIDBase + d * (1 + bottleneckTrails) + (b + 1); @display("ls=red,5,d"); }
+                  <--> westernBorderRouter[disjointTrails + (d * bottleneckTrails) + b].pppg[1 + systemsMain + s]
+                  if (s < systemsReference);
+               serverReference[s].pppg[d * (1 + bottleneckTrails) + (b + 1)]
+                  <--> accessChannel { netID = netIDBase + d * (1 + bottleneckTrails) + (b + 1); @display("ls=red,5,d"); }
+                  <--> easternBorderRouter[disjointTrails + (d * bottleneckTrails) + b].pppg[1 + systemsMain + s]
+                  if (s < systemsReference);
+      }
+
+      // ------ Downlinks -----------------------------------------------------
+      for w=0..min(downlinkTrails, (disjointTrails * (1 + bottleneckTrails)))-1 {
+         westernBorderRouter[w].pppg[1 + systemsMain + systemsReference]
+            <--> connectorChannel { netID = 0;  @display("ls=darkgray,5"); }
+            <--> westernDownlink[w];
+         easternBorderRouter[w].pppg[1 + systemsMain + systemsReference]
+            <--> connectorChannel { netID = 0;  @display("ls=darkgray,5"); }
+            <--> easternDownlink[w];
+      }
+
+      // ------ Uplinks -----------------------------------------------------
+      for u=0..uplinkTrails-1 {
+         westernUplinkRouter[u].pppg[0]
+            <--> connectorChannel { netID = netIDBase + disjointTrails * (1 + bottleneckTrails) + u;  @display("ls=darkgray,5"); }
+            <--> westernUplink[u];
+         easternUplinkRouter[u].pppg[0]
+            <--> connectorChannel { netID = netIDBase + disjointTrails * (1 + bottleneckTrails) + u;  @display("ls=darkgray,5"); }
+            <--> easternUplink[u];
+      }
+      for u=0..uplinkTrails-1,
+         for s=0..max(systemsMain, systemsReference)-1 {
+            clientMain[s].pppg[disjointTrails * (1 + bottleneckTrails) + u]
+               <--> accessChannel { netID = netIDBase + disjointTrails * (1 + bottleneckTrails) + u;  @display("ls=darkgray,5"); }
+               <--> westernUplinkRouter[u].pppg[1 + s]
+               if (s < systemsMain);
+            serverMain[s].pppg[disjointTrails * (1 + bottleneckTrails) + u]
+               <--> accessChannel { netID = netIDBase + disjointTrails * (1 + bottleneckTrails) + u;  @display("ls=darkgray,5"); }
+               <--> easternUplinkRouter[u].pppg[1 + s]
+               if (s < systemsMain);
+
+            clientReference[s].pppg[disjointTrails * (1 + bottleneckTrails) + u]
+               <--> accessChannel { netID = netIDBase + disjointTrails * (1 + bottleneckTrails) + u;  @display("ls=darkgray,5"); }
+               <--> westernUplinkRouter[u].pppg[1 + systemsMain + s]
+               if (s < systemsReference);
+            serverReference[s].pppg[disjointTrails * (1 + bottleneckTrails) + u]
+               <--> accessChannel { netID = netIDBase + disjointTrails * (1 + bottleneckTrails) + u;  @display("ls=darkgray,5"); }
+               <--> easternUplinkRouter[u].pppg[1 + systemsMain + s]
+               if (s < systemsReference);
+      }
+}
+
+
+network cmttest4
+{
+    // ====== System Parameters =============================================
+    parameters:
+        double testTimeout @unit(s) = default(0s);
+        bool   testing              = default(false);
+        int    cores                = default(3);
+    @display("bgi=maps/europe,s");
+
+    // ====== Network Components ============================================
+    submodules:
+        // ------ Routing Auto-Configuration --------------------------------
+        configurator: MultihomedFlatNetworkConfigurator {
+            parameters:
+               @display("p=600,250;i=abstract/penguin_vl,gold");
+        }
+
+        core[cores] : Core {
+           parameters:
+              netIDBase = 1024 + (index * 1024);
+              @display("p=150,150,c,200;i=block/network2_vl,blue");
+        }
+
+   // ====== Connections ====================================================
+   connections:
+   for c=1..cores-1,
+      for t=0..core[c-1].downlinkTrails-1 {
+         core[c-1].westernDownlink[t]
+            <--> accessChannel { netID = core[c].netIDBase + core[c].disjointTrails * (1 + core[c].bottleneckTrails) + t; }
+            <--> core[c].westernUplink[t]
+            if (t < core[c].uplinkTrails);
+         core[c-1].easternDownlink[t]
+            <--> accessChannel { netID = core[c].netIDBase + core[c].disjointTrails * (1 + core[c].bottleneckTrails) + t; }
+            <--> core[c].easternUplink[t]
+            if (t < core[c].uplinkTrails);
+   }
+}
diff --git a/examples/sctp/cmttest4/debug.memcheck b/examples/sctp/cmttest4/debug.memcheck
new file mode 100755
index 0000000..a66a302
--- /dev/null
+++ b/examples/sctp/cmttest4/debug.memcheck
@@ -0,0 +1,31 @@
+#!/bin/sh
+# $Id: debug.memcheck 2195 2009-08-06 08:42:21Z dreibh $
+# --------------------------------------------------------------------------
+#
+#              //===//   //=====   //===//   //       //   //===//
+#             //    //  //        //    //  //       //   //    //
+#            //===//   //=====   //===//   //       //   //===<<
+#           //   \\         //  //        //       //   //    //
+#          //     \\  =====//  //        //=====  //   //===//    Version II
+#
+# ------------- An Efficient RSerPool Prototype Implementation -------------
+#
+# Copyright (C) 2002-2012 by Thomas Dreibholz
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+#
+# Contact: dreibh@iem.uni-due.de
+
+echo "valgrind $@"
+G_SLICE=always-malloc valgrind  -v --tool=memcheck --leak-check=yes --show-reachable=no --leak-resolution=high --num-callers=40 --freelist-vol=4000000 $@
diff --git a/examples/sctp/cmttest4/omnetpp.ini b/examples/sctp/cmttest4/omnetpp.ini
new file mode 100644
index 0000000..a24e691
--- /dev/null
+++ b/examples/sctp/cmttest4/omnetpp.ini
@@ -0,0 +1,518 @@
+# * $Id: omnetpp.ini,v 1.14 2009-03-27 03:46:37 dreibh Exp $
+# * --------------------------------------------------------------------------
+# *
+# *     //====//  //===== <===//===>  //====//
+# *    //        //          //      //    //    SCTP Optimization Project
+# *   //=====   //          //      //====//   ==============================
+# *        //  //          //      //           University of Duisburg-Essen
+# *  =====//  //=====     //      //
+# *
+# * --------------------------------------------------------------------------
+# *
+# *   Copyright (C) 2009-2012 by Thomas Dreibholz
+# *
+# *   This program is free software: you can redistribute it and/or modify
+# *   it under the terms of the GNU General Public License as published by
+# *   the Free Software Foundation, either version 3 of the License, or
+# *   (at your option) any later version.
+# *
+# *   This program is distributed in the hope that it will be useful,
+# *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+# *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# *   GNU General Public License for more details.
+# *
+# *   You should have received a copy of the GNU General Public License
+# *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+# *
+# *   Contact: dreibh@iem.uni-due.de
+
+#############################################################################
+#### GENERAL CONFIGURATION                                               ####
+#############################################################################
+
+[General]
+network             = cmttest4
+rng-class           = cMersenneTwister
+seed-0-mt           = 3
+
+# NOTE: To turn on printing of SCTP debugging messages, set:
+#       cmdenv-express-mode=false, **.testing=true
+cmdenv-express-mode = true    # Express mode
+**.testing          = false   # Verbose SCTP messages
+**.testTimeout      = 0
+
+output-scalar-file  = scalars.sca
+output-vector-file  = vectors.vec
+
+cmttest4.**.vector-recording = no
+cmttest4.**.vector-recording-intervals = 0s..0s 3600s
+
+
+# ===== General Scenario Settings ======================
+cmttest4.cores                  = 3
+cmttest4.core[0].downlinkTrails = 2
+cmttest4.core[1].uplinkTrails   = 2
+cmttest4.core[1].downlinkTrails = 1
+cmttest4.core[2].uplinkTrails   = 1
+# ---- Alpha ----------------------------------------------
+cmttest4.core[0].systemsMain                          = 2
+cmttest4.core[0].systemsReference                     = 0
+cmttest4.core[0].clientReference[*].sctp.cmtCCVariant = "off"
+cmttest4.core[0].serverReference[*].sctp.cmtCCVariant = "off"
+cmttest4.core[0].disjointTrails                       = 2
+cmttest4.core[0].bottleneckTrails                     = 0
+# ---- Beta -----------------------------------------------
+cmttest4.core[1].systemsMain                          = 0
+cmttest4.core[1].systemsReference                     = 0
+cmttest4.core[1].clientReference[*].sctp.cmtCCVariant = "off"
+cmttest4.core[1].serverReference[*].sctp.cmtCCVariant = "off"
+cmttest4.core[1].disjointTrails                       = 1
+cmttest4.core[1].bottleneckTrails                     = 0
+# ---- Gamma ----------------------------------------------
+cmttest4.core[2].systemsMain                          = 0
+cmttest4.core[2].systemsReference                     = 0
+cmttest4.core[2].clientReference[*].sctp.cmtCCVariant = "off"
+cmttest4.core[2].serverReference[*].sctp.cmtCCVariant = "off"
+cmttest4.core[2].disjointTrails                       = 1
+cmttest4.core[2].bottleneckTrails                     = 0
+
+# ===== Network QoS Settings ===========================
+# ----- Trails -----------------------------------------
+cmttest4.core[*].westernCoreRouter[*].ppp[0].ppp.mtu             = 1500   # NOTE: mtu := max(commonMTU, coreMTU)
+cmttest4.core[*].westernCoreRouter[*].ppp[0].queueType           = "REDQueue"
+cmttest4.core[*].westernCoreRouter[*].ppp[0].queue.wq            = 0.002
+cmttest4.core[*].westernCoreRouter[*].ppp[0].queue.minth         = 20
+cmttest4.core[*].westernCoreRouter[*].ppp[0].queue.maxth         = 80
+cmttest4.core[*].westernCoreRouter[*].ppp[0].queue.maxp          = 0.02
+cmttest4.core[*].westernCoreRouter[*].ppp[0].queue.frameCapacity = 100
+cmttest4.core[*].westernCoreRouter[*].ppp[0].queue.pkrate        = 833.33333
+cmttest4.core[*].westernCoreRouter[*].pppg$o[0].channel.datarate = 10 Mbps
+cmttest4.core[*].westernCoreRouter[*].pppg$o[0].channel.delay    = 1 ms
+cmttest4.core[*].westernCoreRouter[*].pppg$o[0].channel.per      = 0
+cmttest4.core[*].westernCoreRouter[*].pppg$o[0].channel.ber      = 0
+cmttest4.core[*].easternCoreRouter[*].ppp[0].ppp.mtu             = 1500   # NOTE: mtu := max(commonMTU, coreMTU)
+cmttest4.core[*].easternCoreRouter[*].ppp[0].queueType           = "REDQueue"
+cmttest4.core[*].easternCoreRouter[*].ppp[0].queue.wq            = 0.002
+cmttest4.core[*].easternCoreRouter[*].ppp[0].queue.minth         = 20
+cmttest4.core[*].easternCoreRouter[*].ppp[0].queue.maxth         = 80
+cmttest4.core[*].easternCoreRouter[*].ppp[0].queue.maxp          = 0.02
+cmttest4.core[*].easternCoreRouter[*].ppp[0].queue.frameCapacity = 100
+cmttest4.core[*].easternCoreRouter[*].ppp[0].queue.pkrate        = 833.33333
+cmttest4.core[*].easternCoreRouter[*].pppg$o[0].channel.datarate = 10 Mbps
+cmttest4.core[*].easternCoreRouter[*].pppg$o[0].channel.delay    = 1 ms
+cmttest4.core[*].easternCoreRouter[*].pppg$o[0].channel.per      = 0
+cmttest4.core[*].easternCoreRouter[*].pppg$o[0].channel.ber      = 0
+cmttest4.core[*].client*[*].ppp[0].ppp.mtu                       = 1500   # Core
+cmttest4.core[*].server*[*].ppp[0].ppp.mtu                       = 1500   # Core
+cmttest4.core[*].client*[*].ppp[1].ppp.mtu                       = 1500   # Core
+cmttest4.core[*].server*[*].ppp[1].ppp.mtu                       = 1500   # Core
+
+# ===== Background Traffic ===============================
+# ----- Western Nodes-------------------------------------
+cmttest4.core[*].westernCoreRouter[*].numNetPerfMeters              = 1
+cmttest4.core[*].westernCoreRouter[*].netPerfMeter[*].activeMode    = true
+cmttest4.core[*].westernCoreRouter[*].netPerfMeter[*].protocol      = "UDP"
+cmttest4.core[*].westernCoreRouter[*].netPerfMeter[*].frameRate     = 0
+cmttest4.core[*].westernCoreRouter[*].netPerfMeter[*].frameSize     = 0
+cmttest4.core[*].westernCoreRouter[*].netPerfMeter[*].maxMsgSize    = 1472 B
+cmttest4.core[*].westernCoreRouter[*].netPerfMeter[*].unordered     = 0.0
+cmttest4.core[*].westernCoreRouter[*].netPerfMeter[*].unreliable    = 0.0
+cmttest4.core[*].westernCoreRouter[*].netPerfMeter[*].remoteAddress = "cmttest4.core[*].easternCoreRouter[" + string(${WesternCoreRouterID=ancestorIndex(1)}) + "]/ppp0"
+cmttest4.core[*].westernCoreRouter[*].netPerfMeter[*].localPort     = 20000+${WesternCoreRouterClientID=ancestorIndex(0)}
+cmttest4.core[*].westernCoreRouter[*].netPerfMeter[*].remotePort    = 8000+${WesternCoreRouterClientID}
+# ----- Eastern Nodes-------------------------------------
+cmttest4.core[*].easternCoreRouter[*].numNetPerfMeters              = 1
+cmttest4.core[*].easternCoreRouter[*].netPerfMeter[*].activeMode    = false
+cmttest4.core[*].easternCoreRouter[*].netPerfMeter[*].protocol      = "UDP"
+cmttest4.core[*].easternCoreRouter[*].netPerfMeter[*].frameRate     = 0
+cmttest4.core[*].easternCoreRouter[*].netPerfMeter[*].frameSize     = 0
+cmttest4.core[*].easternCoreRouter[*].netPerfMeter[*].maxMsgSize    = 1472 B
+cmttest4.core[*].easternCoreRouter[*].netPerfMeter[*].unordered     = 0.0
+cmttest4.core[*].easternCoreRouter[*].netPerfMeter[*].unreliable    = 0.0
+cmttest4.core[*].easternCoreRouter[*].netPerfMeter[*].localPort     = 8000+${EasternCoreRouterServerID=ancestorIndex(0)}
+
+# ----- Common Settings --------------------------------
+cmttest4.core[*].*[*].ppp[*].ppp.mtu = 1500
+
+# ===== Application Parameters ===========================
+# ----- NetPerfMeter Active Node--------------------------
+cmttest4.core[*].client*[*].netPerfMeter[*].activeMode      = true
+cmttest4.core[*].client*[*].netPerfMeter[*].connectTime     = 0.001 s
+cmttest4.core[*].client*[*].netPerfMeter[*].startTime       = uniform(0.9s,1.1s)
+cmttest4.core[*].client*[*].netPerfMeter[*].resetTime       = 19 s
+cmttest4.core[*].client*[*].netPerfMeter[*].stopTime        = 60 s
+cmttest4.core[*].client*[*].netPerfMeter[*].queueSize       = 1e+06 B
+cmttest4.core[*].client*[*].netPerfMeter[*].unordered       = 1
+cmttest4.core[*].client*[*].netPerfMeter[*].unreliable      = 0
+cmttest4.core[*].client*[*].netPerfMeter[*].outboundStreams = 1
+cmttest4.core[*].client*[*].netPerfMeter[*].decoupleSaturatedStreams = false
+cmttest4.core[*].client*[*].netPerfMeter[*].maxMsgSize      = 1452 B
+cmttest4.core[*].client*[*].netPerfMeter[*].frameRate       = 0 Hz
+cmttest4.core[*].client*[*].netPerfMeter[*].frameSize       = uniform(500B, 1452B)
+cmttest4.core[*].client*[*].netPerfMeter[*].frameRateString = ""
+cmttest4.core[*].client*[*].netPerfMeter[*].frameSizeString = ""
+cmttest4.core[*].client*[*].netPerfMeter[*].onTime          = -1s
+cmttest4.core[*].client*[*].netPerfMeter[*].offTime         = -1s
+cmttest4.core[*].client*[*].netPerfMeter[*].maxReconnects   = 0
+# cmttest4.core[*].client*[*].tcpdump.dumpFile                = ${N1=fullPath()}+".pcap"   # *** Enable pcap dump here! ***
+
+# ----- NetPerfMeter Passive Node ------------------------
+cmttest4.core[*].server*[*].netPerfMeter[*].activeMode        = false
+cmttest4.core[*].server*[*].netPerfMeter[*].connectTime       = 0.001 s
+cmttest4.core[*].server*[*].netPerfMeter[*].startTime         = uniform(0.9s,1.1s)
+cmttest4.core[*].server*[*].netPerfMeter[*].resetTime         = 19 s
+cmttest4.core[*].server*[*].netPerfMeter[*].stopTime          = 60 s
+cmttest4.core[*].server*[*].netPerfMeter[*].queueSize         = 1e+06 B
+cmttest4.core[*].server*[*].netPerfMeter[*].unordered         = 1
+cmttest4.core[*].server*[*].netPerfMeter[*].unreliable        = 0
+cmttest4.core[*].server*[*].netPerfMeter[*].maxInboundStreams = 16
+cmttest4.core[*].server*[*].netPerfMeter[*].decoupleSaturatedStreams = false
+cmttest4.core[*].server*[*].netPerfMeter[*].frameRate         = 0 Hz
+cmttest4.core[*].server*[*].netPerfMeter[*].frameSize         = 0 B
+cmttest4.core[*].server*[*].netPerfMeter[*].frameRateString   = ""
+cmttest4.core[*].server*[*].netPerfMeter[*].frameSizeString   = ""
+cmttest4.core[*].server*[*].netPerfMeter[*].maxMsgSize        = 1452 B
+# cmttest4.core[*].server*[*].tcpdump.dumpFile                  = ${N2=fullPath()}+".pcap"   # *** Enable pcap dump here! ***
+
+# ----- NetPerfMeter Connections -------------------------
+cmttest4.core[0].clientReference[*].numNetPerfMeters     = 1
+cmttest4.core[0].serverReference[*].numNetPerfMeters     = 1
+cmttest4.core[0].clientMain[*].numNetPerfMeters          = 1
+cmttest4.core[0].serverMain[*].numNetPerfMeters          = 1
+cmttest4.core[1].clientReference[*].numNetPerfMeters     = 1
+cmttest4.core[1].serverReference[*].numNetPerfMeters     = 1
+cmttest4.core[1].clientMain[*].numNetPerfMeters          = 1
+cmttest4.core[1].serverMain[*].numNetPerfMeters          = 1
+cmttest4.core[2].clientReference[*].numNetPerfMeters     = 1
+cmttest4.core[2].serverReference[*].numNetPerfMeters     = 1
+cmttest4.core[2].clientMain[*].numNetPerfMeters          = 1
+cmttest4.core[2].serverMain[*].numNetPerfMeters          = 1
+cmttest4.core[0].clientReference[*].netPerfMeter[*].localPort     = 20000+${alphaReferenceClientNetPerfMeterID=ancestorIndex(0)}
+cmttest4.core[0].clientReference[*].netPerfMeter[*].remotePort    = 8000+${alphaReferenceClientNetPerfMeterID}
+cmttest4.core[0].clientReference[*].netPerfMeter[*].remoteAddress = "cmttest4.core[0].serverReference[" + string(${alphaReferenceClientID=ancestorIndex(1)}) + "]/ppp0"
+cmttest4.core[0].clientReference[*].netPerfMeter[*].primaryPath   = "cmttest4.core[0].serverReference[" + string(${alphaReferenceClientID}) + "]/ppp0"
+cmttest4.core[0].serverReference[*].netPerfMeter[*].localPort     = 8000+${alphaReferenceServerNetPerfMeterID=ancestorIndex(0)}
+cmttest4.core[0].clientReference[*].netPerfMeter[*].protocol      = "SCTP"
+cmttest4.core[0].serverReference[*].netPerfMeter[*].protocol      = "SCTP"
+cmttest4.core[0].clientMain[*].netPerfMeter[*].localPort     = 20000+${alphaMainClientNetPerfMeterID=ancestorIndex(0)}
+cmttest4.core[0].clientMain[*].netPerfMeter[*].remotePort    = 8000+${alphaMainClientNetPerfMeterID}
+cmttest4.core[0].clientMain[*].netPerfMeter[*].remoteAddress = "cmttest4.core[0].serverMain[" + string(${alphaMainClientID=ancestorIndex(1)}) + "]/ppp0"
+cmttest4.core[0].clientMain[*].netPerfMeter[*].primaryPath   = "cmttest4.core[0].serverMain[" + string(${alphaMainClientID}) + "]/ppp0"
+cmttest4.core[0].serverMain[*].netPerfMeter[*].localPort     = 8000+${alphaMainServerNetPerfMeterID=ancestorIndex(0)}
+cmttest4.core[0].clientMain[*].netPerfMeter[*].protocol      = "SCTP"
+cmttest4.core[0].serverMain[*].netPerfMeter[*].protocol      = "SCTP"
+cmttest4.core[1].clientReference[*].netPerfMeter[*].localPort     = 20000+${betaReferenceClientNetPerfMeterID=ancestorIndex(0)}
+cmttest4.core[1].clientReference[*].netPerfMeter[*].remotePort    = 8000+${betaReferenceClientNetPerfMeterID}
+cmttest4.core[1].clientReference[*].netPerfMeter[*].remoteAddress = "cmttest4.core[1].serverReference[" + string(${betaReferenceClientID=ancestorIndex(1)}) + "]/ppp0"
+cmttest4.core[1].clientReference[*].netPerfMeter[*].primaryPath   = "cmttest4.core[1].serverReference[" + string(${betaReferenceClientID}) + "]/ppp0"
+cmttest4.core[1].serverReference[*].netPerfMeter[*].localPort     = 8000+${betaReferenceServerNetPerfMeterID=ancestorIndex(0)}
+cmttest4.core[1].clientReference[*].netPerfMeter[*].protocol      = "SCTP"
+cmttest4.core[1].serverReference[*].netPerfMeter[*].protocol      = "SCTP"
+cmttest4.core[1].clientMain[*].netPerfMeter[*].localPort     = 20000+${betaMainClientNetPerfMeterID=ancestorIndex(0)}
+cmttest4.core[1].clientMain[*].netPerfMeter[*].remotePort    = 8000+${betaMainClientNetPerfMeterID}
+cmttest4.core[1].clientMain[*].netPerfMeter[*].remoteAddress = "cmttest4.core[1].serverMain[" + string(${betaMainClientID=ancestorIndex(1)}) + "]/ppp0"
+cmttest4.core[1].clientMain[*].netPerfMeter[*].primaryPath   = "cmttest4.core[1].serverMain[" + string(${betaMainClientID}) + "]/ppp0"
+cmttest4.core[1].serverMain[*].netPerfMeter[*].localPort     = 8000+${betaMainServerNetPerfMeterID=ancestorIndex(0)}
+cmttest4.core[1].clientMain[*].netPerfMeter[*].protocol      = "SCTP"
+cmttest4.core[1].serverMain[*].netPerfMeter[*].protocol      = "SCTP"
+cmttest4.core[2].clientReference[*].netPerfMeter[*].localPort     = 20000+${gammaReferenceClientNetPerfMeterID=ancestorIndex(0)}
+cmttest4.core[2].clientReference[*].netPerfMeter[*].remotePort    = 8000+${gammaReferenceClientNetPerfMeterID}
+cmttest4.core[2].clientReference[*].netPerfMeter[*].remoteAddress = "cmttest4.core[2].serverReference[" + string(${gammaReferenceClientID=ancestorIndex(1)}) + "]/ppp0"
+cmttest4.core[2].clientReference[*].netPerfMeter[*].primaryPath   = "cmttest4.core[2].serverReference[" + string(${gammaReferenceClientID}) + "]/ppp0"
+cmttest4.core[2].serverReference[*].netPerfMeter[*].localPort     = 8000+${gammaReferenceServerNetPerfMeterID=ancestorIndex(0)}
+cmttest4.core[2].clientReference[*].netPerfMeter[*].protocol      = "SCTP"
+cmttest4.core[2].serverReference[*].netPerfMeter[*].protocol      = "SCTP"
+cmttest4.core[2].clientMain[*].netPerfMeter[*].localPort     = 20000+${gammaMainClientNetPerfMeterID=ancestorIndex(0)}
+cmttest4.core[2].clientMain[*].netPerfMeter[*].remotePort    = 8000+${gammaMainClientNetPerfMeterID}
+cmttest4.core[2].clientMain[*].netPerfMeter[*].remoteAddress = "cmttest4.core[2].serverMain[" + string(${gammaMainClientID=ancestorIndex(1)}) + "]/ppp0"
+cmttest4.core[2].clientMain[*].netPerfMeter[*].primaryPath   = "cmttest4.core[2].serverMain[" + string(${gammaMainClientID}) + "]/ppp0"
+cmttest4.core[2].serverMain[*].netPerfMeter[*].localPort     = 8000+${gammaMainServerNetPerfMeterID=ancestorIndex(0)}
+cmttest4.core[2].clientMain[*].netPerfMeter[*].protocol      = "SCTP"
+cmttest4.core[2].serverMain[*].netPerfMeter[*].protocol      = "SCTP"
+
+# ===== SCTP Parameters ==================================
+cmttest4.core[*].*[*].sctp.arwnd                       = 5e+05
+cmttest4.core[*].*[*].sctp.cmtSendAllVariant           = "smallestLastTransmission"
+cmttest4.core[*].*[*].sctp.cmtRetransmissionVariant    = "normal"
+cmttest4.core[*].*[*].sctp.cmtBufferSplitVariant       = "bothSides"
+cmttest4.core[*].*[*].sctp.cmtBufferSplittingUsesOSB   = true
+cmttest4.core[*].*[*].sctp.cmtCUCVariant               = "pseudoCumAckV2"
+cmttest4.core[*].*[*].sctp.cmtUseSFR                   = true
+cmttest4.core[*].*[*].sctp.cmtUseDAC                   = true
+cmttest4.core[*].*[*].sctp.cmtUseFRC                   = true
+cmttest4.core[*].*[*].sctp.cmtCCVariant                = "cmt"
+cmttest4.core[*].*[*].sctp.cmtCCPathGroups             = ""
+cmttest4.core[*].*[*].sctp.cmtSackPath                 = "smallestSRTT"
+cmttest4.core[*].*[*].sctp.nrSack                      = true
+cmttest4.core[*].*[*].sctp.disableReneging             = false
+cmttest4.core[*].*[*].sctp.gapReportLimit              = 1e+08
+cmttest4.core[*].*[*].sctp.gapListOptimizationVariant  = "none"
+cmttest4.core[*].*[*].sctp.smartOverfullSACKHandling   = true
+cmttest4.core[*].*[*].sctp.cmtUseOOPG                  = false
+cmttest4.core[*].*[*].sctp.strictCwndBooking           = false
+cmttest4.core[*].*[*].sctp.osbWithHeader               = false
+cmttest4.core[*].*[*].sctp.sackNow                     = true
+cmttest4.core[*].*[*].sctp.packetDrop                  = false
+cmttest4.core[*].*[*].sctp.highSpeedCC                 = false
+cmttest4.core[*].*[*].sctp.maxBurst                    = 4
+cmttest4.core[*].*[*].sctp.maxBurstVariant             = "maxBurst"
+cmttest4.core[*].*[*].sctp.initialWindow               = 0
+cmttest4.core[*].*[*].sctp.cmtSmartT3Reset             = true
+cmttest4.core[*].*[*].sctp.cmtSmartReneging            = true
+cmttest4.core[*].*[*].sctp.cmtSmartFastRTX             = true
+cmttest4.core[*].*[*].sctp.cmtSlowPathRTTUpdate        = true
+cmttest4.core[*].*[*].sctp.cmtSendBufferControlVariant = "none"
+cmttest4.core[*].*[*].sctp.cmtSendBufferBlockThreshold = 0.5
+cmttest4.core[*].*[*].sctp.cmtSuspendPathOnBlocking    = false
+cmttest4.core[*].*[*].sctp.cmtMovedChunksReduceCwnd    = true
+cmttest4.core[*].*[*].sctp.movedChunkFastRTXFactor     = 2
+cmttest4.core[*].*[*].sctp.streamsToPaths              = ""
+cmttest4.core[*].*[*].sctp.RTXMethod                   = 0   # "once"
+cmttest4.core[*].*[*].sctp.ssModule                    = 0   # "roundRobin"
+cmttest4.core[*].*[*].sctp.allowQoSTracking            = false
+cmttest4.core[*].*[*].sctp.qosTrackingInterval         = 1 s
+
+# ===== TCP Parameters ===================================
+cmttest4.core[*].*[*].tcp.advertisedWindow       = 5e+05
+cmttest4.core[*].*[*].tcp.mss                    = 1452
+cmttest4.core[*].*[*].tcp.tcpAlgorithmClass      = "TCPReno"
+cmttest4.core[*].*[*].tcp.sendQueueClass         = "TCPMsgBasedSendQueue"
+cmttest4.core[*].*[*].tcp.receiveQueueClass      = "TCPMsgBasedRcvQueue"
+cmttest4.core[*].*[*].tcp.sackSupport            = false
+cmttest4.core[*].*[*].tcp.timestampSupport       = false
+cmttest4.core[*].*[*].tcp.windowScalingSupport   = true
+cmttest4.core[*].*[*].tcp.delayedAcksEnabled     = false
+cmttest4.core[*].*[*].tcp.limitedTransmitEnabled = false
+cmttest4.core[*].*[*].tcp.increasedIWEnabled     = false
+
+# ===== IP Parameters ====================================
+cmttest4.core[*].*[*].ip.procDelay         = 10us
+cmttest4.core[*].*[*].routing.procDelay    = 0.2us
+cmttest4.core[*].*[*].inputQueue.procDelay = 0.1us
+
+# ===== Test Parameters ==================================
+cmttest4.core[*].*[*].testValue0   = 0
+cmttest4.core[*].*[*].testValue1   = 0
+cmttest4.core[*].*[*].testValue2   = 0
+cmttest4.core[*].*[*].testValue3   = 0
+cmttest4.core[*].*[*].testValue4   = 0
+cmttest4.core[*].*[*].testString0  = ""
+cmttest4.core[*].*[*].testString1  = ""
+cmttest4.core[*].*[*].testString2  = ""
+cmttest4.core[*].*[*].testString3  = ""
+cmttest4.core[*].*[*].testString4  = ""
+
+
+
+#############################################################################
+#### CONFIGURATION SETS                                                  ####
+#############################################################################
+
+[Config multiPathTransfer]
+**.core[*].client*[*].tcpdump.dumpFile = "MultiPathTransfer-" + ${N1=fullPath()} + ".pcap"
+**.core[*].server*[*].tcpdump.dumpFile = "MultiPathTransfer-" + ${N2=fullPath()} + ".pcap"
+**.cores                          = 1
+**.core[0].systemsMain            = 1
+**.core[0].disjointTrails         = 2
+
+**.cmtCCVariant                   = "cmt"   # Activate CMT
+**.cmtCUCVariant                  = "pseudoCumAckV2"
+**.cmtUseSFR                      = true
+**.cmtUseDAC                      = true
+**.cmtUseFRC                      = true
+
+cmttest4.core[*].westernCoreRouter[*].pppg$o[0].channel.datarate = 1 Mbps
+cmttest4.core[*].westernCoreRouter[*].pppg$o[0].channel.delay    = 1 ms
+cmttest4.core[*].easternCoreRouter[*].pppg$o[0].channel.datarate = 1 Mbps
+cmttest4.core[*].easternCoreRouter[*].pppg$o[0].channel.delay    = 1 ms
+
+
+[Config primaryViaNorthernTrail]
+**.core[*].client*[*].tcpdump.dumpFile = "PrimaryViaNorthernTrail-" + ${N1=fullPath()} + ".pcap"
+**.core[*].server*[*].tcpdump.dumpFile = "PrimaryViaNorthernTrail-" + ${N2=fullPath()} + ".pcap"
+**.cores                          = 1
+**.core[0].systemsMain            = 1
+**.core[0].disjointTrails         = 2
+
+**.cmtCCVariant                   = "off"   # Deactivate CMT
+cmttest4.core[0].clientMain[0].netPerfMeter[0].primaryPath = "cmttest4.core[0].clientMain[0]/ppp0"
+
+cmttest4.core[*].westernCoreRouter[*].pppg$o[0].channel.datarate = 1 Mbps
+cmttest4.core[*].westernCoreRouter[*].pppg$o[0].channel.delay    = 1 ms
+cmttest4.core[*].easternCoreRouter[*].pppg$o[0].channel.datarate = 1 Mbps
+cmttest4.core[*].easternCoreRouter[*].pppg$o[0].channel.delay    = 1 ms
+
+
+[Config primaryViaSouthernTrail]
+**.core[*].client*[*].tcpdump.dumpFile = "PrimaryViaSouthernTrail-" + ${N1=fullPath()} + ".pcap"
+**.core[*].server*[*].tcpdump.dumpFile = "PrimaryViaSouthernTrail-" + ${N2=fullPath()} + ".pcap"
+**.cores                          = 1
+**.core[0].systemsMain            = 1
+**.core[0].disjointTrails         = 2
+
+**.cmtCCVariant                   = "off"   # Deactivate CMT
+cmttest4.core[0].clientMain[0].netPerfMeter[0].primaryPath = "cmttest4.core[0].clientMain[0]/ppp1"
+
+cmttest4.core[*].westernCoreRouter[*].pppg$o[0].channel.datarate = 1 Mbps
+cmttest4.core[*].westernCoreRouter[*].pppg$o[0].channel.delay    = 1 ms
+cmttest4.core[*].easternCoreRouter[*].pppg$o[0].channel.datarate = 1 Mbps
+cmttest4.core[*].easternCoreRouter[*].pppg$o[0].channel.delay    = 1 ms
+
+
+[Config fairnessCMT]
+**.core[*].client*[*].tcpdump.dumpFile = "FairnessCMT-" + ${N1=fullPath()} + ".pcap"
+**.core[*].server*[*].tcpdump.dumpFile = "FairnessCMT-" + ${N2=fullPath()} + ".pcap"
+**.cores                          = 1
+**.core[0].systemsMain            = 1
+**.core[0].systemsReference       = 1
+**.core[0].disjointTrails         = 2
+
+**.core[*].clientReference[*].sctp.cmtCCVariant = "off"
+
+**.cmtCCVariant                   = "cmt"   # Activate CMT
+**.cmtCUCVariant                  = "pseudoCumAckV2"
+**.cmtUseSFR                      = true
+**.cmtUseDAC                      = true
+**.cmtUseFRC                      = true
+
+cmttest4.core[*].westernCoreRouter[*].pppg$o[0].channel.datarate = 1 Mbps
+cmttest4.core[*].westernCoreRouter[*].pppg$o[0].channel.delay    = 1 ms
+cmttest4.core[*].easternCoreRouter[*].pppg$o[0].channel.datarate = 1 Mbps
+cmttest4.core[*].easternCoreRouter[*].pppg$o[0].channel.delay    = 1 ms
+
+
+[Config queueBlocking]
+**.core[*].client*[*].tcpdump.dumpFile = "QueueBlocking-" + ${N1=fullPath()} + ".pcap"
+**.core[*].server*[*].tcpdump.dumpFile = "QueueBlocking-" + ${N2=fullPath()} + ".pcap"
+**.cores                          = 2
+**.core[0].disjointTrails         = 1
+**.core[0].downlinkTrails         = 1
+**.core[1].disjointTrails         = 1
+**.core[1].uplinkTrails           = 1
+**.core[0].systemsMain            = 0
+**.core[1].systemsMain            = 1
+
+**.core[*].client*[*].netPerfMeter[*].unordered = 1.0   # !!! Unordered Delivery
+**.core[*].client*[*].netPerfMeter[*].queueSize = 50000 B
+**.core[*].server*[*].sctp.arwnd                = 50000
+
+**.cmtCCVariant                   = "cmt"   # Activate CMT
+**.cmtCUCVariant                  = "pseudoCumAckV2"
+**.cmtUseSFR                      = true
+**.cmtUseDAC                      = true
+**.cmtUseFRC                      = true
+
+**.sackNow                        = true
+**.packetDrop                     = true
+**.highSpeedCC                    = false
+**.checkSackSeqNumber             = false
+**.checkQueues                    = false         # !!! Do not call checkOutstandingBytes() -> significant speed-up!
+
+**.nrSack                         = true          # !!!
+**.cmtSmartT3Reset                = true          # !!!
+**.cmtSmartFastRTX                = true          # !!!
+**.cmtSmartReneging               = true          # !!!
+**.cmtSlowPathRTTUpdate           = true          # !!!
+
+**.cmtBufferSplitVariant          = "bothSides"   # !!!
+**.cmtBufferSplittingUsesOSB      = true          # !!!
+
+**.cmtSendBufferControlVariant    = "none"        # !!!
+**.cmtSendBufferBlockThreshold    = 0.5
+**.cmtSuspendPathOnBlocking       = false
+**.cmtMovedChunksReduceCwnd       = true          # !!!!!!
+#**.maxBurstVariant = "congestionWindowLimiting"
+#**.maxBurstVariant = "aggressiveMaxBurst"
+#**.maxBurstVariant = "maxBurst"
+**.maxBurstVariant = "useItOrLoseIt"
+**.maxBurst = 4
+
+cmttest4.core[0].westernCoreRouter[*].pppg$o[0].channel.datarate = 1 Mbps
+cmttest4.core[0].westernCoreRouter[*].pppg$o[0].channel.delay    = 1 ms
+cmttest4.core[0].easternCoreRouter[*].pppg$o[0].channel.datarate = 1 Mbps
+cmttest4.core[0].easternCoreRouter[*].pppg$o[0].channel.delay    = 1 ms
+
+cmttest4.core[1].westernCoreRouter[*].pppg$o[0].channel.datarate = 0.3 Mbps
+cmttest4.core[1].westernCoreRouter[*].pppg$o[0].channel.delay    = 10 ms
+cmttest4.core[1].easternCoreRouter[*].pppg$o[0].channel.datarate = 0.3 Mbps
+cmttest4.core[1].easternCoreRouter[*].pppg$o[0].channel.delay    = 10 ms
+
+
+[Config multiStreamTransfer]
+**.core[*].client*[*].tcpdump.dumpFile = "QueueBlocking-" + ${N1=fullPath()} + ".pcap"
+**.core[*].server*[*].tcpdump.dumpFile = "QueueBlocking-" + ${N2=fullPath()} + ".pcap"
+**.cores                          = 2
+**.core[0].disjointTrails         = 1
+**.core[0].downlinkTrails         = 1
+**.core[1].disjointTrails         = 1
+**.core[1].uplinkTrails           = 1
+**.core[0].systemsMain            = 0
+**.core[1].systemsMain            = 1
+
+**.core[*].client*[*].sctp.streamsToPaths               = "0 1"   # !!!
+**.core[*].client*[*].netPerfMeter[*].outboundStreams   = 2       # !!!
+**.core[*].server*[*].netPerfMeter[*].maxInboundStreams = 2       # !!!
+
+**.core[*].client*[*].netPerfMeter[*].unordered = 1.0     # !!! Unordered Delivery
+**.core[*].client*[*].netPerfMeter[*].queueSize = 750000 B
+**.core[*].server*[*].sctp.arwnd                = 750000
+
+#enum SCTPStreamSchedulers {
+#   ROUND_ROBIN            = 0
+#   ROUND_ROBIN_PACKET     = 1,
+#   RANDOM_SCHEDULE        = 2,
+#   RANDOM_SCHEDULE_PACKET = 3,
+#   FAIR_BANDWITH          = 4,
+#   FAIR_BANDWITH_PACKET   = 5,
+#   PRIORITY               = 6,
+#   FCFS                   = 7,
+#   PATH_ROUND_ROBIN       = 8,
+#   PATH_MAP_TO_PATH       = 9
+#};
+
+**.ssModule                       = 8
+
+**.allowQoSTracking               = true
+**.qosTrackingInterval            = 5s
+
+
+**.cmtCCVariant                   = "cmt"   # Activate CMT
+**.cmtCUCVariant                  = "pseudoCumAckV2"
+**.cmtUseSFR                      = true
+**.cmtUseDAC                      = true
+**.cmtUseFRC                      = true
+
+**.sackNow                        = true
+**.packetDrop                     = true
+**.highSpeedCC                    = false
+**.checkSackSeqNumber             = false
+**.checkQueues                    = false         # !!! Do not call checkOutstandingBytes() -> significant speed-up!
+
+**.nrSack                         = true          # !!!
+**.cmtSmartT3Reset                = true          # !!!
+**.cmtSmartFastRTX                = true          # !!!
+**.cmtSmartReneging               = true          # !!!
+**.cmtSlowPathRTTUpdate           = true          # !!!
+
+**.cmtBufferSplitVariant          = "bothSides"   # !!!
+**.cmtBufferSplittingUsesOSB      = true          # !!!
+
+**.cmtSendBufferControlVariant    = "none"        # !!!
+**.cmtSendBufferBlockThreshold    = 0.5
+**.cmtSuspendPathOnBlocking       = false
+**.cmtMovedChunksReduceCwnd       = true          # !!!!!!
+#**.maxBurstVariant = "congestionWindowLimiting"
+#**.maxBurstVariant = "aggressiveMaxBurst"
+#**.maxBurstVariant = "maxBurst"
+**.maxBurstVariant = "useItOrLoseIt"
+**.maxBurst = 4
+
+cmttest4.core[0].westernCoreRouter[*].pppg$o[0].channel.datarate = 100 Mbps
+cmttest4.core[0].westernCoreRouter[*].pppg$o[0].channel.delay    = 1 ms
+cmttest4.core[0].easternCoreRouter[*].pppg$o[0].channel.datarate = 100 Mbps
+cmttest4.core[0].easternCoreRouter[*].pppg$o[0].channel.delay    = 1 ms
+
+cmttest4.core[1].westernCoreRouter[*].pppg$o[0].channel.datarate = 100 Mbps
+cmttest4.core[1].westernCoreRouter[*].pppg$o[0].channel.delay    = 10 ms
+cmttest4.core[1].easternCoreRouter[*].pppg$o[0].channel.datarate = 100 Mbps
+cmttest4.core[1].easternCoreRouter[*].pppg$o[0].channel.delay    = 10 ms
diff --git a/examples/sctp/cmttest4/run b/examples/sctp/cmttest4/run
new file mode 100755
index 0000000..120ea5e
--- /dev/null
+++ b/examples/sctp/cmttest4/run
@@ -0,0 +1 @@
+../../../src/inet -n ../..:../../../src $*
diff --git a/examples/sctp/cmttest4/run1-parameters.ini b/examples/sctp/cmttest4/run1-parameters.ini
new file mode 100644
index 0000000..0adc633
--- /dev/null
+++ b/examples/sctp/cmttest4/run1-parameters.ini
@@ -0,0 +1,344 @@
+# ###### Created on Fri Apr 27 09:55:46 2012 ######
+# Script version: $Id: simulate-version5.R 1028 2011-12-14 14:26:38Z adhari $
+
+[General]
+network             = cmttest4
+rng-class           = cMersenneTwister
+seed-0-mt           = 1
+output-scalar-file  = run1-scalars.sca
+output-vector-file  = run1-vectors.vec
+sim-time-limit      = 0s 3600s 1ms
+simtime-scale       = -8   # 10ns time scale
+
+
+cmdenv-express-mode = yes     # *** Enable debugging messages here! ***
+**.testing          = false   # *** Enable debugging messages here! ***
+**.checkQueues      = false   # *** Enable checkOutstandingBytes() calls here! ***
+
+cmttest4.**.vector-recording = no
+cmttest4.**.vector-recording-intervals = 0s..0s 3600s
+
+# ====== Special Settings ==============================
+cmttest4.core[0].client*[1].sctp.cmtCCVariant = "off"
+
+# ===== General Scenario Settings ======================
+cmttest4.cores                  = 3
+cmttest4.core[0].downlinkTrails = 2
+cmttest4.core[1].uplinkTrails   = 2
+cmttest4.core[1].downlinkTrails = 1
+cmttest4.core[2].uplinkTrails   = 1
+# ---- Alpha ----------------------------------------------
+cmttest4.core[0].systemsMain                          = 1
+cmttest4.core[0].systemsReference                     = 0
+cmttest4.core[0].clientReference[*].sctp.cmtCCVariant = "off"
+cmttest4.core[0].serverReference[*].sctp.cmtCCVariant = "off"
+cmttest4.core[0].disjointTrails                       = 2
+cmttest4.core[0].bottleneckTrails                     = 0
+# ---- Beta -----------------------------------------------
+cmttest4.core[1].systemsMain                          = 0
+cmttest4.core[1].systemsReference                     = 0
+cmttest4.core[1].clientReference[*].sctp.cmtCCVariant = "off"
+cmttest4.core[1].serverReference[*].sctp.cmtCCVariant = "off"
+cmttest4.core[1].disjointTrails                       = 1
+cmttest4.core[1].bottleneckTrails                     = 0
+# ---- Gamma ----------------------------------------------
+cmttest4.core[2].systemsMain                          = 0
+cmttest4.core[2].systemsReference                     = 0
+cmttest4.core[2].clientReference[*].sctp.cmtCCVariant = "off"
+cmttest4.core[2].serverReference[*].sctp.cmtCCVariant = "off"
+cmttest4.core[2].disjointTrails                       = 1
+cmttest4.core[2].bottleneckTrails                     = 0
+
+# ===== Network QoS Settings ===========================
+# ----- Alpha Trail ------------------------------------
+cmttest4.core[0].westernCoreRouter[*].ppp[0].ppp.mtu             = 1500   # NOTE: mtu := max(commonMTU, coreMTU)
+cmttest4.core[0].westernCoreRouter[*].ppp[0].queueType           = "REDQueue"
+cmttest4.core[0].westernCoreRouter[*].ppp[0].queue.wq            = 0.002
+cmttest4.core[0].westernCoreRouter[*].ppp[0].queue.minth         = 30
+cmttest4.core[0].westernCoreRouter[*].ppp[0].queue.maxth         = 90
+cmttest4.core[0].westernCoreRouter[*].ppp[0].queue.maxp          = 0.1
+cmttest4.core[0].westernCoreRouter[*].ppp[0].queue.frameCapacity = 100
+cmttest4.core[0].westernCoreRouter[*].ppp[0].queue.pkrate        = 1041.667
+cmttest4.core[0].westernCoreRouter[*].pppg$o[0].channel.datarate = 10 Mbps
+cmttest4.core[0].westernCoreRouter[*].pppg$o[0].channel.delay    = 10 ms
+cmttest4.core[0].westernCoreRouter[*].pppg$o[0].channel.per      = 0
+cmttest4.core[0].westernCoreRouter[*].pppg$o[0].channel.ber      = 0
+cmttest4.core[0].easternCoreRouter[*].ppp[0].ppp.mtu             = 1500   # NOTE: mtu := max(commonMTU, coreMTU)
+cmttest4.core[0].easternCoreRouter[*].ppp[0].queueType           = "REDQueue"
+cmttest4.core[0].easternCoreRouter[*].ppp[0].queue.wq            = 0.002
+cmttest4.core[0].easternCoreRouter[*].ppp[0].queue.minth         = 30
+cmttest4.core[0].easternCoreRouter[*].ppp[0].queue.maxth         = 90
+cmttest4.core[0].easternCoreRouter[*].ppp[0].queue.maxp          = 0.1
+cmttest4.core[0].easternCoreRouter[*].ppp[0].queue.frameCapacity = 100
+cmttest4.core[0].easternCoreRouter[*].ppp[0].queue.pkrate        = 1041.667
+cmttest4.core[0].easternCoreRouter[*].pppg$o[0].channel.datarate = 10 Mbps
+cmttest4.core[0].easternCoreRouter[*].pppg$o[0].channel.delay    = 10 ms
+cmttest4.core[0].easternCoreRouter[*].pppg$o[0].channel.per      = 0
+cmttest4.core[0].easternCoreRouter[*].pppg$o[0].channel.ber      = 0
+cmttest4.core[0].client*[*].ppp[0].ppp.mtu = 1500   # Core
+cmttest4.core[0].server*[*].ppp[0].ppp.mtu = 1500   # Core
+cmttest4.core[0].client*[*].ppp[1].ppp.mtu = 1500   # Core
+cmttest4.core[0].server*[*].ppp[1].ppp.mtu = 1500   # Core
+
+# ----- Beta Trail -------------------------------------
+cmttest4.core[1].westernCoreRouter[*].ppp[0].ppp.mtu             = 1500   # NOTE: mtu := max(commonMTU, coreMTU)
+cmttest4.core[1].westernCoreRouter[*].ppp[0].queueType           = "REDQueue"
+cmttest4.core[1].westernCoreRouter[*].ppp[0].queue.wq            = 0.002
+cmttest4.core[1].westernCoreRouter[*].ppp[0].queue.minth         = 30
+cmttest4.core[1].westernCoreRouter[*].ppp[0].queue.maxth         = 90
+cmttest4.core[1].westernCoreRouter[*].ppp[0].queue.maxp          = 0.1
+cmttest4.core[1].westernCoreRouter[*].ppp[0].queue.frameCapacity = 100
+cmttest4.core[1].westernCoreRouter[*].ppp[0].queue.pkrate        = 1041.667
+cmttest4.core[1].westernCoreRouter[*].pppg$o[0].channel.datarate = 12500000 bps
+cmttest4.core[1].westernCoreRouter[*].pppg$o[0].channel.delay    = 10 ms
+cmttest4.core[1].westernCoreRouter[*].pppg$o[0].channel.per      = 0
+cmttest4.core[1].westernCoreRouter[*].pppg$o[0].channel.ber      = 0
+cmttest4.core[1].easternCoreRouter[*].ppp[0].ppp.mtu             = 1500   # NOTE: mtu := max(commonMTU, coreMTU)
+cmttest4.core[1].easternCoreRouter[*].ppp[0].queueType           = "REDQueue"
+cmttest4.core[1].easternCoreRouter[*].ppp[0].queue.wq            = 0.002
+cmttest4.core[1].easternCoreRouter[*].ppp[0].queue.minth         = 30
+cmttest4.core[1].easternCoreRouter[*].ppp[0].queue.maxth         = 90
+cmttest4.core[1].easternCoreRouter[*].ppp[0].queue.maxp          = 0.1
+cmttest4.core[1].easternCoreRouter[*].ppp[0].queue.frameCapacity = 100
+cmttest4.core[1].easternCoreRouter[*].ppp[0].queue.pkrate        = 1041.667
+cmttest4.core[1].easternCoreRouter[*].pppg$o[0].channel.datarate = 12500000 bps
+cmttest4.core[1].easternCoreRouter[*].pppg$o[0].channel.delay    = 10 ms
+cmttest4.core[1].easternCoreRouter[*].pppg$o[0].channel.per      = 0
+cmttest4.core[1].easternCoreRouter[*].pppg$o[0].channel.ber      = 0
+cmttest4.core[1].client*[*].ppp[0].ppp.mtu = 1500   # Core
+cmttest4.core[1].server*[*].ppp[0].ppp.mtu = 1500   # Core
+cmttest4.core[1].client*[*].ppp[1].ppp.mtu = 1500   # Uplink; NOTE: mtu := max(commonMTU, uplinkMTU)
+cmttest4.core[1].server*[*].ppp[1].ppp.mtu = 1500   # Uplink; NOTE: mtu := max(commonMTU, uplinkMTU)
+cmttest4.core[1].client*[*].ppp[2].ppp.mtu = 1500   # Uplink; NOTE: mtu := max(commonMTU, uplinkMTU)
+cmttest4.core[1].server*[*].ppp[2].ppp.mtu = 1500   # Uplink; NOTE: mtu := max(commonMTU, uplinkMTU)
+
+# ----- Gamma Trail ------------------------------------
+cmttest4.core[2].westernCoreRouter[*].ppp[0].ppp.mtu             = 1500   # NOTE: mtu := max(commonMTU, coreMTU)
+cmttest4.core[2].westernCoreRouter[*].ppp[0].queueType           = "REDQueue"
+cmttest4.core[2].westernCoreRouter[*].ppp[0].queue.wq            = 0.002
+cmttest4.core[2].westernCoreRouter[*].ppp[0].queue.minth         = 30
+cmttest4.core[2].westernCoreRouter[*].ppp[0].queue.maxth         = 90
+cmttest4.core[2].westernCoreRouter[*].ppp[0].queue.maxp          = 0.1
+cmttest4.core[2].westernCoreRouter[*].ppp[0].queue.frameCapacity = 100
+cmttest4.core[2].westernCoreRouter[*].ppp[0].queue.pkrate        = 1041.667
+cmttest4.core[2].westernCoreRouter[*].pppg$o[0].channel.datarate = 12500000 bps
+cmttest4.core[2].westernCoreRouter[*].pppg$o[0].channel.delay    = 10 ms
+cmttest4.core[2].westernCoreRouter[*].pppg$o[0].channel.per      = 0
+cmttest4.core[2].westernCoreRouter[*].pppg$o[0].channel.ber      = 0
+cmttest4.core[2].easternCoreRouter[*].ppp[0].ppp.mtu             = 1500   # NOTE: mtu := max(commonMTU, coreMTU)
+cmttest4.core[2].easternCoreRouter[*].ppp[0].queueType           = "REDQueue"
+cmttest4.core[2].easternCoreRouter[*].ppp[0].queue.wq            = 0.002
+cmttest4.core[2].easternCoreRouter[*].ppp[0].queue.minth         = 30
+cmttest4.core[2].easternCoreRouter[*].ppp[0].queue.maxth         = 90
+cmttest4.core[2].easternCoreRouter[*].ppp[0].queue.maxp          = 0.1
+cmttest4.core[2].easternCoreRouter[*].ppp[0].queue.frameCapacity = 100
+cmttest4.core[2].easternCoreRouter[*].ppp[0].queue.pkrate        = 1041.667
+cmttest4.core[2].easternCoreRouter[*].pppg$o[0].channel.datarate = 12500000 bps
+cmttest4.core[2].easternCoreRouter[*].pppg$o[0].channel.delay    = 10 ms
+cmttest4.core[2].easternCoreRouter[*].pppg$o[0].channel.per      = 0
+cmttest4.core[2].easternCoreRouter[*].pppg$o[0].channel.ber      = 0
+cmttest4.core[2].client*[*].ppp[0].ppp.mtu = 1500   # Core
+cmttest4.core[2].server*[*].ppp[0].ppp.mtu = 1500   # Core
+cmttest4.core[2].client*[*].ppp[1].ppp.mtu = 1500   # Uplink; NOTE: mtu := max(commonMTU, uplinkMTU)
+cmttest4.core[2].server*[*].ppp[1].ppp.mtu = 1500   # Uplink; NOTE: mtu := max(commonMTU, uplinkMTU)
+
+# ===== Background Traffic ===============================
+# ----- Western Nodes-------------------------------------
+cmttest4.core[*].westernCoreRouter[*].numNetPerfMeters              = 1
+cmttest4.core[*].westernCoreRouter[*].netPerfMeter[*].activeMode    = true
+cmttest4.core[*].westernCoreRouter[*].netPerfMeter[*].protocol      = "UDP"
+cmttest4.core[*].westernCoreRouter[*].netPerfMeter[*].frameRate     = 0
+cmttest4.core[*].westernCoreRouter[*].netPerfMeter[*].frameSize     = 0
+cmttest4.core[*].westernCoreRouter[*].netPerfMeter[*].maxMsgSize    = 1472 B
+cmttest4.core[*].westernCoreRouter[*].netPerfMeter[*].unordered     = 0.0
+cmttest4.core[*].westernCoreRouter[*].netPerfMeter[*].unreliable    = 0.0
+cmttest4.core[*].westernCoreRouter[*].netPerfMeter[*].remoteAddress = "cmttest4.core[*].easternCoreRouter[" + string(${WesternCoreRouterID=ancestorIndex(1)}) + "]/ppp0"
+cmttest4.core[*].westernCoreRouter[*].netPerfMeter[*].localPort     = 20000+${WesternCoreRouterClientID=ancestorIndex(0)}
+cmttest4.core[*].westernCoreRouter[*].netPerfMeter[*].remotePort    = 8000+${WesternCoreRouterClientID}
+# ----- Eastern Nodes-------------------------------------
+cmttest4.core[*].easternCoreRouter[*].numNetPerfMeters              = 1
+cmttest4.core[*].easternCoreRouter[*].netPerfMeter[*].activeMode    = false
+cmttest4.core[*].easternCoreRouter[*].netPerfMeter[*].protocol      = "UDP"
+cmttest4.core[*].easternCoreRouter[*].netPerfMeter[*].frameRate     = 0
+cmttest4.core[*].easternCoreRouter[*].netPerfMeter[*].frameSize     = 0
+cmttest4.core[*].easternCoreRouter[*].netPerfMeter[*].maxMsgSize    = 1472 B
+cmttest4.core[*].easternCoreRouter[*].netPerfMeter[*].unordered     = 0.0
+cmttest4.core[*].easternCoreRouter[*].netPerfMeter[*].unreliable    = 0.0
+cmttest4.core[*].easternCoreRouter[*].netPerfMeter[*].localPort     = 8000+${EasternCoreRouterServerID=ancestorIndex(0)}
+
+# ----- Common Settings --------------------------------
+cmttest4.core[*].*[*].ppp[*].ppp.mtu = 1500
+
+# ===== Application Parameters ===========================
+# ----- NetPerfMeter Active Node--------------------------
+cmttest4.core[*].client*[*].netPerfMeter[*].activeMode      = true
+cmttest4.core[*].client*[*].netPerfMeter[*].connectTime     = 0.001 s
+cmttest4.core[*].client*[*].netPerfMeter[*].startTime       = uniform(0.9s,1.1s)
+cmttest4.core[*].client*[*].netPerfMeter[*].resetTime       = 19 s
+cmttest4.core[*].client*[*].netPerfMeter[*].stopTime        = 60 s
+cmttest4.core[*].client*[*].netPerfMeter[*].queueSize       = 2500000 B
+cmttest4.core[*].client*[*].netPerfMeter[*].unordered       = 1
+cmttest4.core[*].client*[*].netPerfMeter[*].unreliable      = 0
+cmttest4.core[*].client*[*].netPerfMeter[*].outboundStreams = 1
+cmttest4.core[*].client*[*].netPerfMeter[*].decoupleSaturatedStreams = false
+cmttest4.core[*].client*[*].netPerfMeter[*].maxMsgSize      = 1452 B
+cmttest4.core[*].client*[*].netPerfMeter[*].frameRate       = 0 Hz
+cmttest4.core[*].client*[*].netPerfMeter[*].frameSize       = 1452 B
+cmttest4.core[*].client*[*].netPerfMeter[*].frameRateString = ""
+cmttest4.core[*].client*[*].netPerfMeter[*].frameSizeString = ""
+cmttest4.core[*].client*[*].netPerfMeter[*].onTime          = -1s
+cmttest4.core[*].client*[*].netPerfMeter[*].offTime         = -1s
+cmttest4.core[*].client*[*].netPerfMeter[*].maxReconnects   = 0
+# cmttest4.core[*].client*[*].tcpdump.dumpFile                = ${N1=fullPath()}+".pcap"   # *** Enable pcap dump here! ***
+
+# ----- NetPerfMeter Passive Node ------------------------
+cmttest4.core[*].server*[*].netPerfMeter[*].activeMode        = false
+cmttest4.core[*].server*[*].netPerfMeter[*].connectTime       = 0.001 s
+cmttest4.core[*].server*[*].netPerfMeter[*].startTime         = uniform(0.9s,1.1s)
+cmttest4.core[*].server*[*].netPerfMeter[*].resetTime         = 19 s
+cmttest4.core[*].server*[*].netPerfMeter[*].stopTime          = 60 s
+cmttest4.core[*].server*[*].netPerfMeter[*].queueSize         = 2500000 B
+cmttest4.core[*].server*[*].netPerfMeter[*].unordered         = 1
+cmttest4.core[*].server*[*].netPerfMeter[*].unreliable        = 0
+cmttest4.core[*].server*[*].netPerfMeter[*].maxInboundStreams = 16
+cmttest4.core[*].server*[*].netPerfMeter[*].decoupleSaturatedStreams = false
+cmttest4.core[*].server*[*].netPerfMeter[*].frameRate         = 0 Hz
+cmttest4.core[*].server*[*].netPerfMeter[*].frameSize         = 0 B
+cmttest4.core[*].server*[*].netPerfMeter[*].frameRateString   = ""
+cmttest4.core[*].server*[*].netPerfMeter[*].frameSizeString   = ""
+cmttest4.core[*].server*[*].netPerfMeter[*].maxMsgSize        = 1452 B
+# cmttest4.core[*].server*[*].tcpdump.dumpFile                  = ${N2=fullPath()}+".pcap"   # *** Enable pcap dump here! ***
+
+# ----- NetPerfMeter Connections -------------------------
+cmttest4.core[0].clientReference[*].numNetPerfMeters     = 1
+cmttest4.core[0].serverReference[*].numNetPerfMeters     = 1
+cmttest4.core[0].clientMain[*].numNetPerfMeters          = 1
+cmttest4.core[0].serverMain[*].numNetPerfMeters          = 1
+cmttest4.core[1].clientReference[*].numNetPerfMeters     = 1
+cmttest4.core[1].serverReference[*].numNetPerfMeters     = 1
+cmttest4.core[1].clientMain[*].numNetPerfMeters          = 1
+cmttest4.core[1].serverMain[*].numNetPerfMeters          = 1
+cmttest4.core[2].clientReference[*].numNetPerfMeters     = 1
+cmttest4.core[2].serverReference[*].numNetPerfMeters     = 1
+cmttest4.core[2].clientMain[*].numNetPerfMeters          = 1
+cmttest4.core[2].serverMain[*].numNetPerfMeters          = 1
+cmttest4.core[0].clientReference[*].netPerfMeter[*].localPort     = 20000+${alphaReferenceClientNetPerfMeterID=ancestorIndex(0)}
+cmttest4.core[0].clientReference[*].netPerfMeter[*].remotePort    = 8000+${alphaReferenceClientNetPerfMeterID}
+cmttest4.core[0].clientReference[*].netPerfMeter[*].remoteAddress = "cmttest4.core[0].serverReference[" + string(${alphaReferenceClientID=ancestorIndex(1)}) + "]/ppp0"
+cmttest4.core[0].clientReference[*].netPerfMeter[*].primaryPath   = "cmttest4.core[0].serverReference[" + string(${alphaReferenceClientID}) + "]/ppp0"
+cmttest4.core[0].serverReference[*].netPerfMeter[*].localPort     = 8000+${alphaReferenceServerNetPerfMeterID=ancestorIndex(0)}
+cmttest4.core[0].clientReference[*].netPerfMeter[*].protocol      = "SCTP"
+cmttest4.core[0].serverReference[*].netPerfMeter[*].protocol      = "SCTP"
+cmttest4.core[0].clientMain[*].netPerfMeter[*].localPort     = 20000+${alphaMainClientNetPerfMeterID=ancestorIndex(0)}
+cmttest4.core[0].clientMain[*].netPerfMeter[*].remotePort    = 8000+${alphaMainClientNetPerfMeterID}
+cmttest4.core[0].clientMain[*].netPerfMeter[*].remoteAddress = "cmttest4.core[0].serverMain[" + string(${alphaMainClientID=ancestorIndex(1)}) + "]/ppp0"
+cmttest4.core[0].clientMain[*].netPerfMeter[*].primaryPath   = "cmttest4.core[0].serverMain[" + string(${alphaMainClientID}) + "]/ppp0"
+cmttest4.core[0].serverMain[*].netPerfMeter[*].localPort     = 8000+${alphaMainServerNetPerfMeterID=ancestorIndex(0)}
+cmttest4.core[0].clientMain[*].netPerfMeter[*].protocol      = "SCTP"
+cmttest4.core[0].serverMain[*].netPerfMeter[*].protocol      = "SCTP"
+cmttest4.core[1].clientReference[*].netPerfMeter[*].localPort     = 20000+${betaReferenceClientNetPerfMeterID=ancestorIndex(0)}
+cmttest4.core[1].clientReference[*].netPerfMeter[*].remotePort    = 8000+${betaReferenceClientNetPerfMeterID}
+cmttest4.core[1].clientReference[*].netPerfMeter[*].remoteAddress = "cmttest4.core[1].serverReference[" + string(${betaReferenceClientID=ancestorIndex(1)}) + "]/ppp0"
+cmttest4.core[1].clientReference[*].netPerfMeter[*].primaryPath   = "cmttest4.core[1].serverReference[" + string(${betaReferenceClientID}) + "]/ppp0"
+cmttest4.core[1].serverReference[*].netPerfMeter[*].localPort     = 8000+${betaReferenceServerNetPerfMeterID=ancestorIndex(0)}
+cmttest4.core[1].clientReference[*].netPerfMeter[*].protocol      = "SCTP"
+cmttest4.core[1].serverReference[*].netPerfMeter[*].protocol      = "SCTP"
+cmttest4.core[1].clientMain[*].netPerfMeter[*].localPort     = 20000+${betaMainClientNetPerfMeterID=ancestorIndex(0)}
+cmttest4.core[1].clientMain[*].netPerfMeter[*].remotePort    = 8000+${betaMainClientNetPerfMeterID}
+cmttest4.core[1].clientMain[*].netPerfMeter[*].remoteAddress = "cmttest4.core[1].serverMain[" + string(${betaMainClientID=ancestorIndex(1)}) + "]/ppp0"
+cmttest4.core[1].clientMain[*].netPerfMeter[*].primaryPath   = "cmttest4.core[1].serverMain[" + string(${betaMainClientID}) + "]/ppp0"
+cmttest4.core[1].serverMain[*].netPerfMeter[*].localPort     = 8000+${betaMainServerNetPerfMeterID=ancestorIndex(0)}
+cmttest4.core[1].clientMain[*].netPerfMeter[*].protocol      = "SCTP"
+cmttest4.core[1].serverMain[*].netPerfMeter[*].protocol      = "SCTP"
+cmttest4.core[2].clientReference[*].netPerfMeter[*].localPort     = 20000+${gammaReferenceClientNetPerfMeterID=ancestorIndex(0)}
+cmttest4.core[2].clientReference[*].netPerfMeter[*].remotePort    = 8000+${gammaReferenceClientNetPerfMeterID}
+cmttest4.core[2].clientReference[*].netPerfMeter[*].remoteAddress = "cmttest4.core[2].serverReference[" + string(${gammaReferenceClientID=ancestorIndex(1)}) + "]/ppp0"
+cmttest4.core[2].clientReference[*].netPerfMeter[*].primaryPath   = "cmttest4.core[2].serverReference[" + string(${gammaReferenceClientID}) + "]/ppp0"
+cmttest4.core[2].serverReference[*].netPerfMeter[*].localPort     = 8000+${gammaReferenceServerNetPerfMeterID=ancestorIndex(0)}
+cmttest4.core[2].clientReference[*].netPerfMeter[*].protocol      = "SCTP"
+cmttest4.core[2].serverReference[*].netPerfMeter[*].protocol      = "SCTP"
+cmttest4.core[2].clientMain[*].netPerfMeter[*].localPort     = 20000+${gammaMainClientNetPerfMeterID=ancestorIndex(0)}
+cmttest4.core[2].clientMain[*].netPerfMeter[*].remotePort    = 8000+${gammaMainClientNetPerfMeterID}
+cmttest4.core[2].clientMain[*].netPerfMeter[*].remoteAddress = "cmttest4.core[2].serverMain[" + string(${gammaMainClientID=ancestorIndex(1)}) + "]/ppp0"
+cmttest4.core[2].clientMain[*].netPerfMeter[*].primaryPath   = "cmttest4.core[2].serverMain[" + string(${gammaMainClientID}) + "]/ppp0"
+cmttest4.core[2].serverMain[*].netPerfMeter[*].localPort     = 8000+${gammaMainServerNetPerfMeterID=ancestorIndex(0)}
+cmttest4.core[2].clientMain[*].netPerfMeter[*].protocol      = "SCTP"
+cmttest4.core[2].serverMain[*].netPerfMeter[*].protocol      = "SCTP"
+
+# ===== SCTP Parameters ==================================
+cmttest4.core[*].*[*].sctp.arwnd                       = 2500000
+cmttest4.core[*].*[*].sctp.hbInterval                  = 30 s
+cmttest4.core[*].*[*].sctp.enableHeartbeats            = true
+cmttest4.core[*].*[*].sctp.sendHeartbeatsOnActivePaths = false
+cmttest4.core[*].*[*].sctp.cmtSendAllVariant           = "smallestLastTransmission"
+cmttest4.core[*].*[*].sctp.cmtRetransmissionVariant    = "normal"
+cmttest4.core[*].*[*].sctp.cmtBufferSplitVariant       = "bothSides"
+cmttest4.core[*].*[*].sctp.cmtBufferSplittingUsesOSB   = true
+cmttest4.core[*].*[*].sctp.cmtCUCVariant               = "pseudoCumAckV2"
+cmttest4.core[*].*[*].sctp.cmtUseSFR                   = true
+cmttest4.core[*].*[*].sctp.cmtUseDAC                   = true
+cmttest4.core[*].*[*].sctp.cmtUseFRC                   = true
+cmttest4.core[*].*[*].sctp.cmtCCVariant                = "cmt"
+cmttest4.core[*].*[*].sctp.cmtCCPathGroups             = ""
+cmttest4.core[*].*[*].sctp.rpPathBlocking              = true
+cmttest4.core[*].*[*].sctp.rpScaleBlockingTimeout      = false
+cmttest4.core[*].*[*].sctp.rpMinCwnd                   = 1
+cmttest4.core[*].*[*].sctp.cmtSackPath                 = "smallestSRTT"
+cmttest4.core[*].*[*].sctp.nrSack                      = true
+cmttest4.core[*].*[*].sctp.disableReneging             = false
+cmttest4.core[*].*[*].sctp.gapReportLimit              = 1e+08
+cmttest4.core[*].*[*].sctp.gapListOptimizationVariant  = "none"
+cmttest4.core[*].*[*].sctp.smartOverfullSACKHandling   = true
+cmttest4.core[*].*[*].sctp.cmtUseOOPG                  = false
+cmttest4.core[*].*[*].sctp.strictCwndBooking           = false
+cmttest4.core[*].*[*].sctp.osbWithHeader               = false
+cmttest4.core[*].*[*].sctp.sackNow                     = true
+cmttest4.core[*].*[*].sctp.packetDrop                  = false
+cmttest4.core[*].*[*].sctp.highSpeedCC                 = false
+cmttest4.core[*].*[*].sctp.maxBurst                    = 4
+cmttest4.core[*].*[*].sctp.maxBurstVariant             = "maxBurst"
+cmttest4.core[*].*[*].sctp.initialWindow               = 0
+cmttest4.core[*].*[*].sctp.cmtSmartT3Reset             = true
+cmttest4.core[*].*[*].sctp.cmtSmartReneging            = false
+cmttest4.core[*].*[*].sctp.cmtSmartFastRTX             = true
+cmttest4.core[*].*[*].sctp.cmtSlowPathRTTUpdate        = false
+cmttest4.core[*].*[*].sctp.cmtChunkReschedulingVariant   = "none"
+cmttest4.core[*].*[*].sctp.cmtChunkReschedulingThreshold = 0.5
+cmttest4.core[*].*[*].sctp.cmtMovedChunksReduceCwnd    = true
+cmttest4.core[*].*[*].sctp.movedChunkFastRTXFactor     = 2
+cmttest4.core[*].*[*].sctp.streamsToPaths              = ""
+cmttest4.core[*].*[*].sctp.RTXMethod                   = 0   # "once"
+cmttest4.core[*].*[*].sctp.ssModule                    = 0   # "roundRobin"
+cmttest4.core[*].*[*].sctp.allowQoSTracking            = false
+cmttest4.core[*].*[*].sctp.qosTrackingInterval         = 1 s
+
+# ===== TCP Parameters ===================================
+cmttest4.core[*].*[*].tcp.advertisedWindow       = 2500000
+cmttest4.core[*].*[*].tcp.mss                    = 1452
+cmttest4.core[*].*[*].tcp.tcpAlgorithmClass      = "TCPReno"
+cmttest4.core[*].*[*].tcp.sendQueueClass         = "TCPMsgBasedSendQueue"
+cmttest4.core[*].*[*].tcp.receiveQueueClass      = "TCPMsgBasedRcvQueue"
+cmttest4.core[*].*[*].tcp.sackSupport            = false
+cmttest4.core[*].*[*].tcp.timestampSupport       = false
+cmttest4.core[*].*[*].tcp.windowScalingSupport   = true
+cmttest4.core[*].*[*].tcp.delayedAcksEnabled     = false
+cmttest4.core[*].*[*].tcp.limitedTransmitEnabled = false
+cmttest4.core[*].*[*].tcp.increasedIWEnabled     = false
+
+# ===== IP Parameters ====================================
+cmttest4.core[*].*[*].ip.procDelay         = 10us
+cmttest4.core[*].*[*].routing.procDelay    = 0.2us
+cmttest4.core[*].*[*].inputQueue.procDelay = 0.1us
+
+# ===== Test Parameters ==================================
+cmttest4.core[*].*[*].sctp.testValue0   = 0
+cmttest4.core[*].*[*].sctp.testValue1   = 0
+cmttest4.core[*].*[*].sctp.testValue2   = 0
+cmttest4.core[*].*[*].sctp.testValue3   = 0
+cmttest4.core[*].*[*].sctp.testValue4   = 0
+cmttest4.core[*].*[*].sctp.testString0  = ""
+cmttest4.core[*].*[*].sctp.testString1  = ""
+cmttest4.core[*].*[*].sctp.testString2  = ""
+cmttest4.core[*].*[*].sctp.testString3  = ""
+cmttest4.core[*].*[*].sctp.testString4  = ""
+
diff --git a/examples/sctp/cmttest4/test1 b/examples/sctp/cmttest4/test1
new file mode 100755
index 0000000..a899157
--- /dev/null
+++ b/examples/sctp/cmttest4/test1
@@ -0,0 +1,3 @@
+#!/bin/sh
+../../../src/inet  -n ../..:../../../src  -u Cmdenv  -c multiPathTransfer  $@  >x 2>&1   && \
+grep "Total Reception Bit" scalars.sca
diff --git a/examples/sctp/cmttest4/test2 b/examples/sctp/cmttest4/test2
new file mode 100755
index 0000000..6563889
--- /dev/null
+++ b/examples/sctp/cmttest4/test2
@@ -0,0 +1,21 @@
+#!/bin/sh
+rm -f core ; (cd ../../.. && make -j2 ) && \
+../../../src/inet  -n ../..:../../../src  -u Cmdenv  -f run1-parameters.ini  $@  >x 2>&1   && \
+(
+   grep "Retrans" run1-scalars.sca | grep client
+   grep "Number of Duplicates" run1-scalars.sca | grep server
+   grep "Utilization Average Queued Received Bytes 2:Total" run1-scalars.sca | grep server
+   grep "Utilization Maximum Queued Received Bytes 2:Total" run1-scalars.sca | grep server
+   grep "Average Congestion Window 2:" run1-scalars.sca
+   grep "\"Average Outstanding Bytes 2:" run1-scalars.sca
+   grep "Total Reception Bit" run1-scalars.sca | grep -v Router | grep -v client
+   grep "Overfull SACKs" run1-scalars.sca | grep -v client
+   grep "Drops Because" run1-scalars.sca | grep -v client
+   grep "Chunks Reneged" run1-scalars.sca | grep -v client
+   grep "Average Length of SACK Sent" run1-scalars.sca
+   grep "StdDev of Length of SACK Sent" run1-scalars.sca
+   grep "Reception Bit Rate Stream" run1-scalars.sca | grep server
+   grep "Average Number of [a-Z\-]* Gap Blocks S" run1-scalars.sca
+   grep "Sum of" run1-scalars.sca | grep client
+   grep "statistic cmttest4.serverBeta....netPerfMeter..." -A2 run1-scalars.sca | grep -v "field count"
+)
diff --git a/examples/sctp/cmttest4/test3 b/examples/sctp/cmttest4/test3
new file mode 100755
index 0000000..97d1bb7
--- /dev/null
+++ b/examples/sctp/cmttest4/test3
@@ -0,0 +1,3 @@
+#!/bin/sh
+../../../src/inet  -n ../..:../../../src  -u Cmdenv  -c fairnessCMT  $@ >x 2>&1   && \
+grep "Total Reception Bit" scalars.sca
diff --git a/examples/sctp/cmttest4/test4 b/examples/sctp/cmttest4/test4
new file mode 100755
index 0000000..a0b2ffb
--- /dev/null
+++ b/examples/sctp/cmttest4/test4
@@ -0,0 +1,20 @@
+#!/bin/sh
+./run -u Cmdenv -c queueBlocking >x 2>&1 && \
+grep "Number of Fast Retransmissions 1:" scalars.sca && \
+grep "Number of Timer-Based Retransmissions 1:" scalars.sca && \
+grep "Number of PacketDrop Reports" scalars.sca && \
+grep "Average Congestion Window 1:" scalars.sca && \
+grep "Average Slow Start Threshold 1:" scalars.sca && \
+grep "\"Maximum Queued Sent Bytes 1:" scalars.sca && \
+grep "\"Average Queued Sent Bytes 1:" scalars.sca && \
+grep "\"Maximum Queued Received Bytes 2:" scalars.sca && \
+grep "\"Average Queued Received Bytes 2:" scalars.sca && \
+grep "\"Maximum Outstanding Bytes 1:" scalars.sca && \
+grep "\"Average Outstanding Bytes 1:" scalars.sca && \
+grep "\"Maximum RTT 1:" scalars.sca && \
+grep "\"Average RTT 1:" scalars.sca && \
+grep "Number of Fast Retransmissions 1:" scalars.sca && \
+grep "Number of Timer-Based Retransmissions 1:" scalars.sca && \
+grep "Number of Duplicates 2:" scalars.sca && \
+grep "Blocking TSNs" scalars.sca && \
+grep "Total Reception Bit" scalars.sca
diff --git a/src/networklayer/autorouting/MultihomedFlatNetworkConfigurator.cc b/src/networklayer/autorouting/MultihomedFlatNetworkConfigurator.cc
new file mode 100644
index 0000000..ef30061
--- /dev/null
+++ b/src/networklayer/autorouting/MultihomedFlatNetworkConfigurator.cc
@@ -0,0 +1,435 @@
+// * --------------------------------------------------------------------------
+// *
+// *     //====//  //===== <===//===>  //====//
+// *    //        //          //      //    //    SCTP Optimization Project
+// *   //=====   //          //      //====//   ==============================
+// *        //  //          //      //           University of Duisburg-Essen
+// *  =====//  //=====     //      //
+// *
+// * --------------------------------------------------------------------------
+// *
+// *   Copyright (C) 2009-2012 by Thomas Dreibholz
+// *
+// *   This program is free software: you can redistribute it and/or modify
+// *   it under the terms of the GNU General Public License as published by
+// *   the Free Software Foundation, either version 3 of the License, or
+// *   (at your option) any later version.
+// *
+// *   This program is distributed in the hope that it will be useful,
+// *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+// *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// *   GNU General Public License for more details.
+// *
+// *   You should have received a copy of the GNU General Public License
+// *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+// *
+// *   Contact: dreibh@iem.uni-due.de
+
+#include <algorithm>
+#include "IRoutingTable.h"
+#include "IInterfaceTable.h"
+#include "IPAddressResolver.h"
+#include "MultihomedFlatNetworkConfigurator.h"
+#include "InterfaceEntry.h"
+#include "IPv4InterfaceData.h"
+
+
+Define_Module(MultihomedFlatNetworkConfigurator);
+
+
+// ###### Initialize: perform autorouting ###################################
+void MultihomedFlatNetworkConfigurator::initialize(int stage)
+{
+   if(stage == 2) {
+      cTopology      fullTopology;
+      NodeInfoVector fullNodeInfoVector;
+      extractTopology(fullTopology, fullNodeInfoVector, true, true, 0);
+
+      // Assign addresses to all nodes
+      std::set<unsigned int> networkSet = assignAddresses(fullTopology, fullNodeInfoVector);
+
+      // Compute routing tables for each network ID
+      for(std::set<unsigned int>::iterator iterator = networkSet.begin();
+         iterator != networkSet.end(); iterator++) {
+         const unsigned int networkID = *iterator;
+         EV << "###### Computing routing table for network ID " << networkID << " ... ######" << endl;
+
+         cTopology      fullTopologyForNetwork;
+         NodeInfoVector fullNodeInfoVectorForNetwork;
+         extractTopology(fullTopologyForNetwork, fullNodeInfoVectorForNetwork, true, false, networkID);
+
+         computeRouting(fullTopologyForNetwork, fullNodeInfoVectorForNetwork, networkID);      
+         // dumpConfiguration(fullTopologyForNetwork, fullNodeInfoVectorForNetwork, true);
+      }
+      
+      dumpConfiguration(fullTopology, fullNodeInfoVector);
+      setDisplayString(fullTopology, fullNodeInfoVector);
+   }
+}
+
+
+// ###### Update route if new one has a better metric #######################
+static void updateIfMetricIsBetter(IRoutingTable* routingTable,
+                                   IPRoute*       newRoute)
+{
+   const IPRoute* oldRoute = routingTable->findRoute(newRoute->getHost(), newRoute->getNetmask(), IPAddress());
+   if(oldRoute) {
+      if(oldRoute->getMetric() <= newRoute->getMetric()) {
+         // Old route is better or equal -> keep it and ignore new one.
+         delete newRoute;
+         return;
+      }
+      else {
+         // New route is better -> get rid of the old one.
+         routingTable->deleteRoute(oldRoute);
+      }
+   }
+      
+   std::vector<IPAddress> ownAddresses = routingTable->gatherAddresses();
+   for(std::vector<IPAddress>::iterator iterator = ownAddresses.begin();
+       iterator != ownAddresses.end(); iterator++) {
+      if(newRoute->getHost() == *iterator) {
+          // New route is a loop to myself -> ignore it.
+         delete newRoute;
+         return;
+      }
+   }
+   
+   routingTable->addRoute(newRoute);
+}
+
+
+// ###### Get Network ID from gate ##########################################
+static unsigned int getNetworkID(cChannel* channel)
+{
+   unsigned int networkID = 0;
+   if(channel) {
+      if(channel->hasPar("netID")) {
+         networkID = channel->par("netID");
+      }
+   }
+   return(networkID);
+}
+
+// ###### Get Network ID from gate ##########################################
+static unsigned int getNetworkID(cModule*        module,
+                                 InterfaceEntry* interfaceEntry)
+{
+   int          outputGateID = interfaceEntry->getNodeOutputGateId();
+   cGate*       outputGate   = module->gate(outputGateID);
+   cChannel*    channel      = outputGate->getChannel();
+   return(getNetworkID(channel));
+}
+
+
+// ###### Get Network ID from gate ##########################################
+static unsigned int getNetworkID(cModule*            module,
+                                 cTopology::LinkOut* link)
+{
+   int          outputGateID = link->getLocalGateId();
+   cGate*       outputGate   = module->gate(outputGateID);
+   cChannel*    channel      = outputGate->getChannel();
+   return(getNetworkID(channel));
+}
+
+
+
+// ###### Search filter to find nodes or routers only #######################
+struct NodeFilterParameters
+{
+   bool         AllNetworks;
+   bool         FullTopology;
+   unsigned int NetworkID;
+};
+
+static bool nodeFilter(cModule* module, void* userData)
+{
+   const NodeFilterParameters* parameters = (const NodeFilterParameters*)userData;
+
+   cProperty* nodeProperty = module->getProperties()->get("node");
+   if(nodeProperty) {
+      // ====== Check whether this is a router ==============================
+      IRoutingTable* routingTable = IPAddressResolver().routingTableOf(module);
+      if(routingTable) {
+         if( (parameters->FullTopology) || (routingTable->isIPForwardingEnabled()) ) {
+            // ====== Are nodes in arbitrary networks requested? ============
+            if(parameters->AllNetworks) {
+               return(true);
+            }
+
+            // ====== Is there an interface in the right network? ===========
+            IInterfaceTable* interfaceTable = IPAddressResolver().interfaceTableOf(module);
+            if(interfaceTable) {
+               bool foundNetwork = false;
+               for(int k = 0;k < interfaceTable->getNumInterfaces(); k++) {
+                  InterfaceEntry*    interfaceEntry     = interfaceTable->getInterface(k);
+                  if(!interfaceEntry->isLoopback()) {
+                     const unsigned int interfaceNetworkID = getNetworkID(module, interfaceEntry);
+                     if( (interfaceNetworkID == 0) ||
+                         (interfaceNetworkID == parameters->NetworkID) ) {
+                        foundNetwork = true;
+                        break;
+                     }
+                  }
+               }
+               if(foundNetwork) {
+                  return(true);
+               }
+            }
+         }
+      }
+   }
+   return(false);
+}
+
+
+// ###### Extract the topology (full or routers only) #######################
+void MultihomedFlatNetworkConfigurator::extractTopology(cTopology&      topology,
+                                                        NodeInfoVector& nodeInfo,
+                                                        const bool      fullTopology,
+                                                        const bool      allNetworks,
+                                                        unsigned int    networkID)
+{
+   NodeFilterParameters parameters;
+   parameters.FullTopology = fullTopology;
+   parameters.AllNetworks  = allNetworks;
+   parameters.NetworkID    = networkID;
+
+   topology.extractFromNetwork(nodeFilter, &parameters);
+   EV << "cTopology found " << topology.getNumNodes() << " nodes for network "
+      << networkID << endl;
+
+   nodeInfo.resize(topology.getNumNodes());
+   for(int i = 0; i < topology.getNumNodes(); i++) {
+      // ====== Cache pointers to interface and routing tables ==============
+      cTopology::Node* node   = topology.getNode(i);
+      cModule*         module = node->getModule();
+      nodeInfo[i].isIPNode = (IPAddressResolver().findInterfaceTableOf(module) != NULL);
+      if(nodeInfo[i].isIPNode) {
+         nodeInfo[i].interfaceTable = IPAddressResolver().interfaceTableOf(module);
+         nodeInfo[i].routingTable   = IPAddressResolver().routingTableOf(module);
+      }
+
+      // ====== Prune links having the wrong network ID =====================
+      for(int j = 0; j < node->getNumOutLinks(); j++) {
+         cTopology::LinkOut* link          = node->getLinkOut(j);
+         const unsigned int  linkNetworkID = getNetworkID(module, link);
+         if( (linkNetworkID != networkID) && (linkNetworkID != 0) ) {
+            link->disable();
+         }
+      }
+   }
+}
+
+
+#define MAX_HOSTS_SHIFT    16
+#define MAX_NETWORKS_SHIFT (32 - MAX_HOSTS_SHIFT - 2)
+
+// ###### Assign addresses to all nodes #####################################
+std::set<unsigned int> MultihomedFlatNetworkConfigurator::assignAddresses(cTopology&      topology,
+                                                                          NodeInfoVector& nodeInfo)
+{
+   // ====== Initialize per-network node counters ===========================
+   unsigned int hostsOfNetwork[1 << MAX_NETWORKS_SHIFT];
+   for(unsigned int i = 0;i < (1 << MAX_NETWORKS_SHIFT);i++) {
+      hostsOfNetwork[i] = 0;
+   }
+   std::set<unsigned int> networkSet;
+
+   TotalNumberOfInterfaces = 0;
+   for(int i=0; i<topology.getNumNodes(); i++) {
+      // ====== Skip bus types ==============================================
+      if (!nodeInfo[i].isIPNode) {
+          continue;
+      }
+
+      // ====== Assign address to each IP interface =========================
+      IInterfaceTable* interfaceTable = nodeInfo[i].interfaceTable;
+      cTopology::Node* atNode         = topology.getNode(i);
+      EV << "Node " << atNode->getModule()->getFullName() << ":" << endl;
+      for(int k = 0; k < interfaceTable->getNumInterfaces(); k++) {
+         InterfaceEntry* interfaceEntry = interfaceTable->getInterface(k);
+         if(!interfaceEntry->isLoopback()) {
+            const unsigned int networkID = getNetworkID(atNode->getModule(), interfaceEntry);
+            networkSet.insert(networkID);
+
+            if(networkID >= (1 << MAX_NETWORKS_SHIFT) - 1) {
+               error("Network ID %u is too large!", networkID);
+            }
+
+            const uint32 address =
+               0x80000000                     |   // beginning with binary 10 (i.e. 128.0.0.0 .. 191.255.255.255)
+               (networkID << MAX_HOSTS_SHIFT) |
+               (++hostsOfNetwork[networkID]);
+            TotalNumberOfInterfaces++;
+
+            if(hostsOfNetwork[networkID] >= (1 << (32 - 2 - MAX_NETWORKS_SHIFT)) - 1) {
+               error("Too many hosts (%u) for network ID %u!", hostsOfNetwork[networkID], networkID);
+            }
+
+            EV << "   Interface " << interfaceEntry->getName() << ": "
+               << IPAddress(address).str().c_str() << endl;
+            interfaceEntry->ipv4Data()->setIPAddress(IPAddress(address));
+            interfaceEntry->ipv4Data()->setNetmask(IPAddress::ALLONES_ADDRESS);
+         }
+      }
+   }
+   return(networkSet);
+}
+
+
+// ###### Print configuration computed ######################################
+void MultihomedFlatNetworkConfigurator::dumpConfiguration(cTopology&      topology,
+                                                          NodeInfoVector& nodeInfo,
+                                                          const bool      intermediateVersion)
+{
+   EV << "Routing Configuration by MultihomedFlatNetworkConfigurator: --------------" << endl;
+   for(int n = 0; n < topology.getNumNodes(); n++) {
+      cTopology::Node* node               = topology.getNode(n);
+      cModule*         nodeModule         = node->getModule();
+      IRoutingTable*   nodeRoutingTable   = nodeInfo[n].routingTable;
+      IInterfaceTable* nodeInterfaceTable = nodeInfo[n].interfaceTable;
+      
+      EV << "Node " << nodeModule->getFullPath() << ":" << endl;
+      EV << "   Forwarding: " << (nodeRoutingTable->isIPForwardingEnabled() ? "yes" : "no") << endl;
+
+/*
+      for(int k = 0;k < nodeInterfaceTable->getNumInterfaces();k++) {
+         InterfaceEntry* interfaceEntry = nodeInterfaceTable->getInterface(k);
+         EV << "   Interface " << interfaceEntry->getName() << ":\t"
+            << interfaceEntry->ipv4Data()->getIPAddress().str().c_str() << endl;
+      }
+*/
+
+      unsigned int num = 0;
+      for(int j = 0; j < node->getNumOutLinks(); j++) {
+         cTopology::Node* neighbourNode               = node->getLinkOut(j)->getRemoteNode();
+         IInterfaceTable* neighbourNodeInterfaceTable = IPAddressResolver().interfaceTableOf(neighbourNode->getModule());
+         const int        neighbourGateID             = node->getLinkOut(j)->getRemoteGate()->getId();
+         InterfaceEntry*  neighbourInterfaceEntry     = neighbourNodeInterfaceTable->getInterfaceByNodeInputGateId(neighbourGateID);
+         const int        outputGateID                = node->getLinkOut(j)->getLocalGate()->getId();
+         InterfaceEntry*  outputInterfaceEntry        = nodeInterfaceTable->getInterfaceByNodeOutputGateId(outputGateID);
+         unsigned int     outputInterfaceNetworkID    = getNetworkID(node->getModule(), outputInterfaceEntry);
+
+         EV << ++num << "   Interface "
+               << outputInterfaceEntry->getName() << ":\t"
+               << outputInterfaceEntry->ipv4Data()->getIPAddress().str().c_str()
+            << "\t<-->\t"
+               << neighbourNode->getModule()->getFullPath() << " Interface "
+               << neighbourInterfaceEntry->getName() << ":\t"
+               << neighbourInterfaceEntry->ipv4Data()->getIPAddress().str().c_str()
+            << "\tNetID: " << outputInterfaceNetworkID
+            << endl;
+      }
+
+      if(nodeInfo[n].usesDefaultRoute) {
+         EV << "   Using default route" << endl;
+      }
+      else {
+         for (int r = 0;r< nodeRoutingTable->getNumRoutes();r++) {
+            const IPRoute* route = nodeRoutingTable->getRoute(r);
+            ev << ++num << "   Route to "
+               << route->getHost().str().c_str() << " via "
+               << route->getInterface()->getName() << ", metric "
+               << route->getMetric() << endl;
+         }
+         if( ((unsigned int)nodeRoutingTable->getNumRoutes() > TotalNumberOfInterfaces) &&
+             (!intermediateVersion) ) {
+            error("Routing table has more routes (%u) than interfaces in the network (%u)!",
+                  (unsigned int)nodeRoutingTable->getNumRoutes(), TotalNumberOfInterfaces);
+         }
+      }
+   }
+   EV << "--------------------------------------------------------------------------" << endl;
+}
+
+
+// ###### Set MultihomedFlatNetworkConfigurator description text ############
+void MultihomedFlatNetworkConfigurator::setDisplayString(cTopology&      topology,
+                                                         NodeInfoVector& nodeInfo)
+{
+   int numIPNodes = 0;
+   for(int i = 0; i < topology.getNumNodes(); i++) {
+      if(nodeInfo[i].isIPNode) {
+         numIPNodes++;
+      }
+   }
+
+   char buffer[80];
+   snprintf(buffer, sizeof(buffer), "%d IP nodes\n%d non-IP nodes",
+            numIPNodes, topology.getNumNodes() - numIPNodes);
+   getDisplayString().setTagArg("t", 0, buffer);
+}
+
+
+// ###### Compute the routing tables for given network ID ###################
+void MultihomedFlatNetworkConfigurator::computeRouting(cTopology&         topology,
+                                                       NodeInfoVector&    nodeInfo,
+                                                       const unsigned int networkID)
+{
+   for(int i = 0;i < topology.getNumNodes();i++) {
+      // ====== Get destination router data =================================
+      cTopology::Node* destinationNode = topology.getNode(i);
+      // skip bus types
+      if(!nodeInfo[i].isIPNode) {
+         continue;
+      }
+      IInterfaceTable* destinationNodeInterfaceTable = nodeInfo[i].interfaceTable;
+
+      // ====== Calculate shortest paths ====================================
+      topology.calculateUnweightedSingleShortestPathsTo(destinationNode);
+
+      
+      // ====== Update routing tables of all nodes with shortest paths ======
+      for (int j = 0; j < topology.getNumNodes(); j++) {
+         // ====== Is this node useful? =====================================
+         cTopology::Node* atNode = topology.getNode(j);
+         if( (i == j) || (!nodeInfo[j].isIPNode) ) {
+            continue;   // same node or bus type
+         }
+         if(atNode->getNumPaths() == 0) {
+            continue;   // not connected
+         }
+
+         // ====== Get output interface at node "atNode" ====================
+         IInterfaceTable* sourceNodeInterfaceTable = nodeInfo[j].interfaceTable;
+         const int        outputGateId             = atNode->getPath(0)->getLocalGate()->getId();
+         InterfaceEntry*  outputInterfaceEntry     = sourceNodeInterfaceTable->getInterfaceByNodeOutputGateId(outputGateId);
+         if(outputInterfaceEntry == NULL) {
+            error("%s has no interface for output gate id %d",
+                  sourceNodeInterfaceTable->getFullPath().c_str(), outputGateId);
+         }
+         
+         // ====== Get input interface at node "destinationNode" ============
+         cTopology::LinkOut* path = atNode->getPath(0);
+         while(path->getRemoteNode() != destinationNode) {
+            cTopology::Node* nextRouter = path->getRemoteNode();
+            path = nextRouter->getPath(0);
+         }
+         
+         // ====== Add routing table entries for the destination router =====
+         IRoutingTable* routingTable = nodeInfo[j].routingTable;
+         for(int k = 0;k < destinationNodeInterfaceTable->getNumInterfaces();k++) {
+            // Add a routing table entry for each interface of the destination ...
+            InterfaceEntry* interfaceEntry = destinationNodeInterfaceTable->getInterface(k);
+            if(interfaceEntry->isLoopback()) {
+               continue;   // ... except for its loopback address
+            }
+            const unsigned int destinationNetworkID = getNetworkID(destinationNode->getModule(), interfaceEntry);
+            if( (destinationNetworkID != networkID) && (destinationNetworkID != 0) ) {
+               continue;   // ... except for links belonging to the wrong network
+            }
+            const IPAddress destinationAddress = interfaceEntry->ipv4Data()->getIPAddress();
+
+            IPRoute* route = new IPRoute();
+            route->setHost(destinationAddress);
+            route->setNetmask(IPAddress(255,255,255,255));      // full match needed
+            route->setInterface(outputInterfaceEntry);
+            route->setType(IPRoute::DIRECT);
+            route->setSource(IPRoute::MANUAL);
+            route->setMetric(atNode->getDistanceToTarget());    // hop count metric
+            updateIfMetricIsBetter(routingTable, route);
+         }
+      }
+   }
+}
diff --git a/src/networklayer/autorouting/MultihomedFlatNetworkConfigurator.h b/src/networklayer/autorouting/MultihomedFlatNetworkConfigurator.h
new file mode 100644
index 0000000..f6bae47
--- /dev/null
+++ b/src/networklayer/autorouting/MultihomedFlatNetworkConfigurator.h
@@ -0,0 +1,79 @@
+// * --------------------------------------------------------------------------
+// *
+// *     //====//  //===== <===//===>  //====//
+// *    //        //          //      //    //    SCTP Optimization Project
+// *   //=====   //          //      //====//   ==============================
+// *        //  //          //      //           University of Duisburg-Essen
+// *  =====//  //=====     //      //
+// *
+// * --------------------------------------------------------------------------
+// *
+// *   Copyright (C) 2009-2012 by Thomas Dreibholz
+// *
+// *   This program is free software: you can redistribute it and/or modify
+// *   it under the terms of the GNU General Public License as published by
+// *   the Free Software Foundation, either version 3 of the License, or
+// *   (at your option) any later version.
+// *
+// *   This program is distributed in the hope that it will be useful,
+// *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+// *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// *   GNU General Public License for more details.
+// *
+// *   You should have received a copy of the GNU General Public License
+// *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+// *
+// *   Contact: dreibh@iem.uni-due.de
+
+#ifndef __INET_MULTIHOMEDFLATNETWORKCONFIGURATOR_H
+#define __INET_MULTIHOMEDFLATNETWORKCONFIGURATOR_H
+
+#include <omnetpp.h>
+#include <set>
+#include "FlatNetworkConfigurator.h"
+
+
+class INET_API MultihomedFlatNetworkConfigurator : public cSimpleModule
+{
+   protected:
+   struct NodeInfo {
+      NodeInfo() {
+         isIPNode         = false;
+         interfaceTable   = NULL;
+         routingTable     = NULL;
+         usesDefaultRoute = false; }
+      bool             isIPNode;
+      IInterfaceTable* interfaceTable;
+      IRoutingTable*   routingTable;
+      bool             usesDefaultRoute;
+   };
+   typedef std::vector<NodeInfo> NodeInfoVector;
+  
+
+   protected:
+   virtual int numInitStages() const { return(3); }
+   virtual void initialize(int stage);
+   virtual void extractTopology(cTopology&         topology,
+                                NodeInfoVector&    nodeInfo,
+                                const bool         fullTopology,
+                                const bool         allNetworks,
+                                const unsigned int networkID);
+   virtual std::set<unsigned int> assignAddresses(cTopology&      topology,
+                                                  NodeInfoVector& nodeInfo);
+   virtual void computeRouting(cTopology&         topology,
+                               NodeInfoVector&    nodeInfo,
+                               const unsigned int networkID);
+   virtual void setDisplayString(cTopology&      topology,
+                                 NodeInfoVector& nodeInfo);
+
+
+   private:
+   typedef std::set<IPAddress> HostSet;
+   unsigned int                TotalNumberOfInterfaces;
+
+   void dumpConfiguration(cTopology&      topo,
+                          NodeInfoVector& nodeInfo,
+                          const bool      intermediateVersion = false);
+};
+
+#endif
diff --git a/src/networklayer/autorouting/MultihomedFlatNetworkConfigurator.ned b/src/networklayer/autorouting/MultihomedFlatNetworkConfigurator.ned
new file mode 100644
index 0000000..5a6f8f8
--- /dev/null
+++ b/src/networklayer/autorouting/MultihomedFlatNetworkConfigurator.ned
@@ -0,0 +1,36 @@
+// * --------------------------------------------------------------------------
+// *
+// *     //====//  //===== <===//===>  //====//
+// *    //        //          //      //    //    SCTP Optimization Project
+// *   //=====   //          //      //====//   ==============================
+// *        //  //          //      //           University of Duisburg-Essen
+// *  =====//  //=====     //      //
+// *
+// * --------------------------------------------------------------------------
+// *
+// *   Copyright (C) 2009-2012 by Thomas Dreibholz
+// *
+// *   This program is free software: you can redistribute it and/or modify
+// *   it under the terms of the GNU General Public License as published by
+// *   the Free Software Foundation, either version 3 of the License, or
+// *   (at your option) any later version.
+// *
+// *   This program is distributed in the hope that it will be useful,
+// *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+// *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// *   GNU General Public License for more details.
+// *
+// *   You should have received a copy of the GNU General Public License
+// *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+// *
+// *   Contact: dreibh@iem.uni-due.de
+
+
+package inet.networklayer.autorouting;
+
+
+simple MultihomedFlatNetworkConfigurator
+{
+    parameters:
+        @display("i=block/cogwheel_s");
+}
diff --git a/src/networklayer/queue/DropTailQueue.cc b/src/networklayer/queue/DropTailQueue.cc
index 453033e..0c90c49 100644
--- a/src/networklayer/queue/DropTailQueue.cc
+++ b/src/networklayer/queue/DropTailQueue.cc
@@ -1,5 +1,6 @@
 //
 // Copyright (C) 2005 Andras Varga
+// Copyright (C) 2010-2012 Thomas Dreibholz
 //
 // This program is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public License
@@ -15,11 +16,23 @@
 // along with this program; if not, see <http://www.gnu.org/licenses/>.
 //
 
-
 #include <omnetpp.h>
+
+// ====== Activate debugging mode here! ===================
+// #define DTQUEUE_DEBUG                 // Print drops, queue status, etc.
+// #define DTQUEUE_DEBUG_FORWARDS        // Print all forwards
+// ========================================================
+
+#ifdef DTQUEUE_DEBUG
+#include "IPDatagram_m.h"
+#include "SCTPMessage.h"
+#include "SCTPAssociation.h"
+#define EV std::cout
+#endif
 #include "DropTailQueue.h"
 
 
+
 Define_Module(DropTailQueue);
 
 void DropTailQueue::initialize()
@@ -41,12 +54,18 @@ bool DropTailQueue::enqueue(cMessage *msg)
     if (frameCapacity && queue.length() >= frameCapacity)
     {
         EV << "Queue full, dropping packet.\n";
+#ifdef DTQUEUE_DEBUG
+        dumpInfo("DROPPING", msg);
+#endif
         delete msg;
         dropVec.record(1);
         return true;
     }
     else
     {
+#ifdef DTQUEUE_DEBUG_FORWARDS
+        dumpInfo("Queuing", msg);
+#endif
         queue.insert(msg);
         qlenVec.record(queue.length());
         return false;
@@ -58,7 +77,7 @@ cMessage *DropTailQueue::dequeue()
     if (queue.empty())
         return NULL;
 
-   cMessage *pk = (cMessage *)queue.pop();
+    cMessage *pk = (cMessage *)queue.pop();
 
     // statistics
     qlenVec.record(queue.length());
@@ -68,7 +87,44 @@ cMessage *DropTailQueue::dequeue()
 
 void DropTailQueue::sendOut(cMessage *msg)
 {
+#ifdef DTQUEUE_DEBUG_FORWARDS
+    dumpInfo("Sending", msg);
+    EV << endl;
+#endif
     send(msg, outGate);
 }
 
-
+#ifdef DTQUEUE_DEBUG
+// T.D. 03.03.2010: Print information on forwarded/dropped packets.
+//                  For SCTP, also the ports and DATA chunk TSNs are printed.
+void DropTailQueue::dumpInfo(const char* info, cMessage* msg)
+{
+   const IPDatagram*  ip      = dynamic_cast<const IPDatagram*>(msg);
+   SCTPMessage*       sctpMsg = dynamic_cast<SCTPMessage*>(ip->getEncapsulatedPacket());
+   if(sctpMsg) {
+      EV << simTime() << "\t" << getFullPath() << ":\t" << info << " SCTP message "
+         << ip->getSrcAddress()  << ":" << sctpMsg->getSrcPort()  << " - "
+         << ip->getDestAddress() << ":" << sctpMsg->getDestPort() << " -->";
+
+      for(uint32 i = 0;i < sctpMsg->getChunksArraySize();i++) {
+         const SCTPChunk* chunk = (const SCTPChunk*)sctpMsg->getChunks(i);
+         if(chunk->getChunkType() == DATA) {
+            const SCTPDataChunk* dataChunk = dynamic_cast<const SCTPDataChunk*>(chunk);
+            EV << "\t" << "DATA " << dataChunk->getTsn();
+         }
+         else if(chunk->getChunkType() == HEARTBEAT) {
+            EV << "\t" << "HEARTBEAT";
+         }
+         else if(chunk->getChunkType() == HEARTBEAT_ACK) {
+            EV << "\t" << "HEARTBEAT_ACK";
+         }
+      }
+   }
+   else {
+      EV << simTime() << ": " << info << " message "
+         << ip->getSrcAddress()  << " - "
+         << ip->getDestAddress() << "   ";
+   }
+   EV << "\tqueueLength=" << queue.length() << endl;
+}
+#endif
diff --git a/src/networklayer/queue/DropTailQueue.h b/src/networklayer/queue/DropTailQueue.h
index 5cb08d2..2b9a64a 100644
--- a/src/networklayer/queue/DropTailQueue.h
+++ b/src/networklayer/queue/DropTailQueue.h
@@ -45,7 +45,7 @@ class INET_API DropTailQueue : public PassiveQueueBase
     /**
      * Redefined from PassiveQueueBase.
      */
-    virtual bool enqueue(cMessage *msg);
+    virtual bool enqueue(cMessage* msg);
 
     /**
      * Redefined from PassiveQueueBase.
@@ -55,9 +55,14 @@ class INET_API DropTailQueue : public PassiveQueueBase
     /**
      * Redefined from PassiveQueueBase.
      */
-    virtual void sendOut(cMessage *msg);
-};
+    virtual void sendOut(cMessage* msg);
 
+#ifdef DTQUEUE_DEBUG
+    /**
+      * Print message information.
+      */
+    void dumpInfo(const char* info, cMessage* msg);
 #endif
+};
 
-
+#endif
diff --git a/src/networklayer/queue/REDQueue.cc b/src/networklayer/queue/REDQueue.cc
index f6a5dd5..de42f21 100644
--- a/src/networklayer/queue/REDQueue.cc
+++ b/src/networklayer/queue/REDQueue.cc
@@ -1,5 +1,6 @@
 //
 // Copyright (C) 2005 Andras Varga
+// Copyright (C) 2009-2012 Thomas Dreibholz
 //
 // This program is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public License
@@ -15,8 +16,19 @@
 // along with this program; if not, see <http://www.gnu.org/licenses/>.
 //
 
-
 #include <omnetpp.h>
+
+// ====== Activate debugging mode here! =====================================
+// #define REDQUEUE_DEBUG             // Print drops, queue status, etc.
+// #define REDQUEUE_DEBUG_FORWARDS    // Print all forwards
+// ==========================================================================
+
+#ifdef REDQUEUE_DEBUG
+#include "IPDatagram_m.h"
+#include "SCTPMessage.h"
+#include "SCTPAssociation.h"
+#define EV std::cout
+#endif
 #include "REDQueue.h"
 
 
@@ -50,9 +62,27 @@ void REDQueue::initialize()
     WATCH(q_time);
     WATCH(count);
     WATCH(numEarlyDrops);
+
+#ifdef REDQUEUE_DEBUG
+    // print configuration
+    const cModule* ppp = outGate->getPathEndGate()->getOwnerModule();
+    if(ppp) {
+        const cGate* networkOutputGate = ppp->gate("phys$o");
+        if(networkOutputGate) {
+            const cModule* remoteSide = networkOutputGate->getPathEndGate()->getOwnerModule();
+            if(remoteSide) {
+                EV << "REDQueue from " << ppp->getFullPath() << " to "
+                          << remoteSide->getFullPath()
+                          << ":\twq=" << wq
+                          << "\tminth=" << minth << "\tmaxth=" << maxth
+                          << "\tmaxp=" << maxp << "\tpkrate=" << pkrate << endl;
+            }
+        }
+    }
+#endif
 }
 
-bool REDQueue::enqueue(cMessage *msg)
+bool REDQueue::enqueue(cMessage* msg)
 {
     //"
     // for each packet arrival
@@ -95,12 +125,37 @@ bool REDQueue::enqueue(cMessage *msg)
     //"
 
     bool mark = false;
-    if (minth<=avg && avg<maxth)
+    if ((minth <= avg) && (avg < maxth))   // avg in [minth,maxth)
     {
         count++;
-        double pb = maxp*(avg-minth) / (maxth-minth);
-        double pa = pb / (1-count*pb);
-        if (dblrand() < pa)
+        const double pb = maxp*(avg-minth) / (maxth-minth);
+        double pa;
+        if(count*pb >= 1) {
+           // T.D. 29.07.2011: This condition must be checked. Otherwise, pa
+           //                  may become negative => queue works like FIFO.
+           pa = 1.0;
+        }
+        else {
+           pa = pb / (1-count*pb);
+        }
+        const double r = dblrand();
+
+#if 0
+        const IPDatagram*  ip      = dynamic_cast<const IPDatagram*>(msg);
+        SCTPMessage*       sctpMsg = dynamic_cast<SCTPMessage*>(ip->getEncapsulatedPacket());
+        if(sctpMsg) {
+           std::cout << simTime() << "\t" << getFullPath() << ":\t" << " SCTP message "
+                     << ip->getSrcAddress()  << ":" << sctpMsg->getSrcPort()  << " - "
+                     << ip->getDestAddress() << ":" << sctpMsg->getDestPort() << " -->"
+                     << "\tpa="    << pa
+                     << "\tpb="    << pb
+                     << "\tcount=" << count
+                     << "\tr="     << r
+                     << "\tmark="  << (r < pa) << endl;
+        }
+#endif
+
+        if (r < pa)
         {
             EV << "Random early packet drop (avg queue len=" << avg << ", pa=" << pa << ")\n";
             mark = true;
@@ -108,9 +163,13 @@ bool REDQueue::enqueue(cMessage *msg)
             numEarlyDrops++;
         }
     }
-    else if (maxth <= avg)
+    else if ( (avg >= maxth) /* || (queue.length() >= maxth) */ )
+       // maxth is also the "hard" limit
     {
-        EV << "Avg queue len " << avg << " >= maxth, dropping packet.\n";
+       // T.D. 10.12.09: The hard limit must be checked here.
+       // When mark is set to "true", the count must be reset to 0!
+        EV << "Avg queue len " << avg << ", queue len "
+           << queue.length() << " => dropping packet.\n";
         mark = true;
         count = 0;
     }
@@ -120,14 +179,22 @@ bool REDQueue::enqueue(cMessage *msg)
     }
 
     // carry out decision
-    if (mark || queue.length()>=maxth) // maxth is also the "hard" limit
+    if (mark)
     {
+#ifdef REDQUEUE_DEBUG
+        dumpInfo("DROPPING", msg);
+        EV << " mark=" << (mark ? "yes" : "no") << endl;
+#endif
         delete msg;
         dropVec.record(1);
         return true;
     }
     else
     {
+#ifdef REDQUEUE_DEBUG_FORWARDS
+        dumpInfo("Queuing", msg);
+        EV << endl;
+#endif
         queue.insert(msg);
         qlenVec.record(queue.length());
         return false;
@@ -153,8 +220,12 @@ cMessage *REDQueue::dequeue()
     return pk;
 }
 
-void REDQueue::sendOut(cMessage *msg)
+void REDQueue::sendOut(cMessage* msg)
 {
+#ifdef REDQUEUE_DEBUG_FORWARDS
+    dumpInfo("Sending", msg);
+    EV << endl;
+#endif
     send(msg, outGate);
 }
 
@@ -163,3 +234,42 @@ void REDQueue::finish()
     PassiveQueueBase::finish();
     recordScalar("packets dropped early by RED", numEarlyDrops);
 }
+
+#ifdef REDQUEUE_DEBUG
+// T.D. 10.12.09: Print information on forwarded/dropped packets.
+//                For SCTP, also the ports and DATA chunk TSNs are printed.
+void REDQueue::dumpInfo(const char* info, cMessage* msg)
+{
+   const IPDatagram*  ip      = dynamic_cast<const IPDatagram*>(msg);
+   SCTPMessage*       sctpMsg = dynamic_cast<SCTPMessage*>(ip->getEncapsulatedPacket());
+   if(sctpMsg) {
+      EV << simTime() << "\t" << getFullPath() << ":\t" << info << " SCTP message "
+         << ip->getSrcAddress()  << ":" << sctpMsg->getSrcPort()  << " - "
+         << ip->getDestAddress() << ":" << sctpMsg->getDestPort() << " -->";
+
+      for(uint32 i = 0;i < sctpMsg->getChunksArraySize();i++) {
+         const SCTPChunk* chunk = (const SCTPChunk*)sctpMsg->getChunks(i);
+         if(chunk->getChunkType() == DATA) {
+            const SCTPDataChunk* dataChunk = dynamic_cast<const SCTPDataChunk*>(chunk);
+            EV << "\t" << "DATA " << dataChunk->getTsn();
+         }
+         else if(chunk->getChunkType() == HEARTBEAT) {
+            EV << "\t" << "HEARTBEAT";
+         }
+         else if(chunk->getChunkType() == HEARTBEAT_ACK) {
+            EV << "\t" << "HEARTBEAT_ACK";
+         }
+      }
+   }
+   else {
+      EV << simTime() << ": " << info << " message "
+         << ip->getSrcAddress()  << " - "
+         << ip->getDestAddress() << "   ";
+   }
+   EV << "\tqueueLength=" << queue.length()
+      << "\tavg=" << avg
+      << "\tminTh=" << minth
+      << "\tmaxTh=" << maxth
+      << "\tcount=" << count;
+}
+#endif
diff --git a/src/networklayer/queue/REDQueue.h b/src/networklayer/queue/REDQueue.h
index 660b376..df70f56 100644
--- a/src/networklayer/queue/REDQueue.h
+++ b/src/networklayer/queue/REDQueue.h
@@ -1,5 +1,6 @@
 //
 // Copyright (C) 2005 Andras Varga
+// Copyright (C) 2009-2012 Thomas Dreibholz
 //
 // This program is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public License
@@ -22,6 +23,11 @@
 #include <omnetpp.h>
 #include "PassiveQueueBase.h"
 
+
+// Uncomment to print info on forwarded/dropped messages
+// #define REDQUEUE_DEBUG
+
+
 /**
  * RED queue. See NED for more info.
  */
@@ -56,7 +62,7 @@ class INET_API REDQueue : public PassiveQueueBase
     /**
      * Redefined from PassiveQueueBase.
      */
-    virtual bool enqueue(cMessage *msg);
+    virtual bool enqueue(cMessage* msg);
 
     /**
      * Redefined from PassiveQueueBase.
@@ -66,10 +72,14 @@ class INET_API REDQueue : public PassiveQueueBase
     /**
      * Redefined from PassiveQueueBase.
      */
-    virtual void sendOut(cMessage *msg);
+    virtual void sendOut(cMessage* msg);
 
+#ifdef REDQUEUE_DEBUG
+    /**
+      * Print message information.
+      */
+    void dumpInfo(const char* info, cMessage* msg);
+#endif
 };
 
 #endif
-
-
diff --git a/src/nodes/inet/StandardHost.ned b/src/nodes/inet/StandardHost.ned
index ef4bd6d..da1ba9d 100644
--- a/src/nodes/inet/StandardHost.ned
+++ b/src/nodes/inet/StandardHost.ned
@@ -1,4 +1,5 @@
 //
+// Copyright (C) 2009-2012 Thomas Dreibholz
 // Copyright (C) 2004 Andras Varga
 // Copyright (C) 2000 Institut fuer Telematik, Universitaet Karlsruhe
 //
@@ -19,124 +20,140 @@
 
 package inet.nodes.inet;
 
+import inet.applications.netperfmeter.NetPerfMeter;
 import inet.applications.pingapp.PingApp;
-import inet.applications.sctpapp.SCTPApp;
 import inet.applications.tcpapp.TCPApp;
 import inet.applications.udpapp.UDPApp;
+import inet.applications.sctpapp.SCTPApp;   //I.R.
 import inet.base.NotificationBoard;
 import inet.linklayer.ethernet.EthernetInterface;
-import inet.linklayer.ext.ExtInterface;
 import inet.linklayer.ppp.PPPInterface;
+import inet.linklayer.ext.ExtInterface; //I.R.
 import inet.networklayer.common.InterfaceTable;
 import inet.networklayer.ipv4.RoutingTable;
-import inet.transport.sctp.SCTP;
-import inet.transport.tcp.ITCP;
+import inet.transport.tcp.TCP;
 import inet.transport.udp.UDP;
+import inet.transport.sctp.SCTP;    //I.R.
+import inet.util.TCPDump;   //I.R.
 import inet.util.NAMTraceWriter;
-import inet.util.TCPDump;
 
 
 //
-// \IP host with SCTP, TCP, UDP layers and applications.
+// \IP host with TCP, UDP layers and applications.
 //
 module StandardHost
 {
     parameters:
         @node();
-        @labels(node,ethernet-node);
-        @display("i=device/pc2");
+        int numNetPerfMeters = default(0);   // T.D. 17.11.09
         int numTcpApps = default(0);
         int numUdpApps = default(0);
-        int numSctpApps = default(0);
+        int numSctpApps = default(0);   //I.R.
         string tcpAppType = default("n/a");
         string udpAppType = default("n/a");
-        string sctpAppType = default("n/a");
-        string tcpType = default("TCP");  // tcp implementation (e.g. TCP, TCP_old, TCP_NSC)
+        string sctpAppType = default("n/a");    //I.R.
         bool IPForward = default(false);
         int namid = default(-1);
         string routingFile = default("");
-        int numExtInterfaces = default(0);
+        @display("i=device/pc2");
     gates:
-        inout pppg[] @labels(PPPFrame-conn);
-        inout ethg[] @labels(EtherFrame-conn);
+        inout pppg[];
+        inout ethg[];
+        inout extg[];
     submodules:
-        namTrace: NAMTraceWriter {
-            parameters:
-                namid = namid;
-                @display("p=57,294");
-        }
         notificationBoard: NotificationBoard {
             parameters:
-                @display("p=57,54");
+                @display("p=60,60");
         }
         interfaceTable: InterfaceTable {
             parameters:
-                @display("p=57,134");
+                @display("p=60,160");
         }
         routingTable: RoutingTable {
             parameters:
                 IPForward = IPForward;
                 routerId = "";
                 routingFile = routingFile;
-                @display("p=57,214");
+                @display("p=60,260");
         }
-        tcpApp[numTcpApps]: <tcpAppType> like TCPApp {
+        namTrace: NAMTraceWriter {
+            parameters:
+                namid = namid;
+                @display("p=60,360");
+        }
+
+        netPerfMeter[numNetPerfMeters]: NetPerfMeter {  // T.D. 17.11.09
             parameters:
-                @display("p=186,54");
+                @display("p=280,60;i=block/timer");
         }
-        tcp: <tcpType> like ITCP {
+        tcpApp[numTcpApps]: <tcpAppType> like TCPApp {
             parameters:
-                @display("p=186,141");
+                @display("p=180,60");
         }
         udpApp[numUdpApps]: <udpAppType> like UDPApp {
             parameters:
-                @display("p=336,54");
+                @display("p=280,60");
         }
-        udp: UDP {
+        sctpApp[numSctpApps]: <sctpAppType> like SCTPApp {  //I.R.
             parameters:
-                @display("p=336,141");
+                @display("p=380,60");
         }
-        sctpApp[numSctpApps]: <sctpAppType> like SCTPApp {
+        pingApp: PingApp {
             parameters:
-                @display("p=501,54");
+                @display("p=360,230");
         }
-        sctp: SCTP {
-            @display("p=501,141;i=block/wheelbarrow");
+
+        tcp: TCP {
+            parameters:
+                @display("p=180,160");
         }
-        pingApp: PingApp {
+        udp: UDP {
             parameters:
-                @display("p=501,230");
+                @display("p=280,160");
+        }
+        sctp: SCTP {    //I.R.
+            @display("p=380,160;i=block/wheelbarrow");
         }
+
         networkLayer: NetworkLayer {
             parameters:
                 proxyARP = false;
-                @display("p=336,230;q=queue");
+                @display("p=280,250;q=queue");
             gates:
-                ifIn[sizeof(pppg)+sizeof(ethg)+numExtInterfaces];
-                ifOut[sizeof(pppg)+sizeof(ethg)+numExtInterfaces];
+                ifIn[sizeof(pppg)+sizeof(ethg)+sizeof(extg)];
+                ifOut[sizeof(pppg)+sizeof(ethg)+sizeof(extg)];
         }
         ppp[sizeof(pppg)]: PPPInterface {
             parameters:
-                @display("p=186,390,row,90;q=txQueue");
+                @display("p=235,360,row,90;q=txQueue;i=block/ifcard");
         }
         eth[sizeof(ethg)]: EthernetInterface {
             parameters:
-                @display("p=336,390,row,90;q=txQueue");
+                @display("p=335,360,row,90;q=txQueue;i=block/ifcard");
         }
-        ext[numExtInterfaces]: ExtInterface {
+        ext[sizeof(extg)]: ExtInterface {   //I.R.
             parameters:
-                @display("p=501,390,row,90;q=txQueue;i=block/ifcard");
+                @display("p=400,390,row,90;q=txQueue;i=block/ifcard");
         }
-        tcpdump: TCPDump {
+        tcpdump: TCPDump {  //I.R.
             parameters:
-                @display("p=336,302;i=abstract/cache_s");
+                @display("p=280,310;i=abstract/cache_s");
             gates:
-                ifIn[sizeof(pppg)+sizeof(ethg)+numExtInterfaces];
-                in2[sizeof(pppg)+sizeof(ethg)+numExtInterfaces];
-                ifOut[sizeof(pppg)+sizeof(ethg)+numExtInterfaces];
-                out2[sizeof(pppg)+sizeof(ethg)+numExtInterfaces];
+                ifIn[sizeof(pppg)+sizeof(ethg)+sizeof(extg)];
+                in2[sizeof(pppg)+sizeof(ethg)+sizeof(extg)];
+                ifOut[sizeof(pppg)+sizeof(ethg)+sizeof(extg)];
+                out2[sizeof(pppg)+sizeof(ethg)+sizeof(extg)];
         }
     connections allowunconnected:
+        for i=0..numNetPerfMeters-1 {
+            netPerfMeter[i].tcpOut --> tcp.appIn++;
+            netPerfMeter[i].tcpIn <-- tcp.appOut++;
+            netPerfMeter[i].sctpOut --> sctp.from_appl++;
+            netPerfMeter[i].sctpIn <-- sctp.to_appl++;
+            netPerfMeter[i].udpOut --> udp.appIn++;
+            netPerfMeter[i].udpIn <-- udp.appOut++;
+        }
+
         for i=0..numTcpApps-1 {
             tcpApp[i].tcpOut --> tcp.appIn++;
             tcpApp[i].tcpIn <-- tcp.appOut++;
@@ -153,10 +170,11 @@ module StandardHost
         udp.ipOut --> networkLayer.udpIn;
         udp.ipIn <-- networkLayer.udpOut;
 
-        for i=0..numSctpApps-1 {
+        for i=0..numSctpApps-1 {    //I.R.
             sctpApp[i].sctpOut --> sctp.from_appl++;
             sctp.to_appl++ --> sctpApp[i].sctpIn;
         }
+
         sctp.to_ip --> networkLayer.sctpIn;
         networkLayer.sctpOut --> sctp.from_ip;
 
@@ -180,7 +198,7 @@ module StandardHost
             tcpdump.in2[sizeof(pppg)+i] <-- networkLayer.ifOut[sizeof(pppg)+i];
         }
 
-        for i=0..numExtInterfaces-1 {
+        for i=0..sizeof(extg)-1 {
             ext[i].netwOut --> tcpdump.ifIn[sizeof(pppg)+sizeof(ethg)+i];
             tcpdump.out2[sizeof(pppg)+sizeof(ethg)+i] --> networkLayer.ifIn[sizeof(pppg)+sizeof(ethg)+i];
             ext[i].netwIn <-- tcpdump.ifOut[sizeof(pppg)+sizeof(ethg)+i];
diff --git a/src/transport/contract/TCPCommand.msg b/src/transport/contract/TCPCommand.msg
index f2c3f64..171c8db 100644
--- a/src/transport/contract/TCPCommand.msg
+++ b/src/transport/contract/TCPCommand.msg
@@ -1,5 +1,7 @@
 //
 // Copyright (C) 2004 Andras Varga
+// Copyright (C) 2010 Robin Seggelmann
+// Copyright (C) 2010-2012 Thomas Dreibholz
 //
 // This program is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public License
@@ -38,6 +40,7 @@ enum TcpCommandCode
     TCP_C_CLOSE = 5;         // "I have no more data to send"
     TCP_C_ABORT = 6;         // abort connection
     TCP_C_STATUS = 7;        // request status info (TCP_I_STATUS) from TCP
+    TCP_C_QUEUE_BYTES_LIMIT = 8; // set send queue limit (in bytes)
 }
 
 
@@ -59,6 +62,7 @@ enum TcpStatusInd
     TCP_I_CONNECTION_RESET = 7;  // connection reset
     TCP_I_TIMED_OUT = 8;         // conn-estab timer went off, or max retransm. count reached
     TCP_I_STATUS = 9;            // status info (will carry TCPStatusInfo)
+    TCP_I_SEND_MSG = 10;         // send queue abated, send more messages
 }
 
 
diff --git a/src/transport/contract/TCPSocket.cc b/src/transport/contract/TCPSocket.cc
index 938faab..ad2a0d9 100644
--- a/src/transport/contract/TCPSocket.cc
+++ b/src/transport/contract/TCPSocket.cc
@@ -175,6 +175,11 @@ void TCPSocket::send(cMessage *msg)
     sendToTCP(msg);
 }
 
+void TCPSocket::sendCommand(cMessage *msg)
+{
+    sendToTCP(msg);
+}
+
 void TCPSocket::close()
 {
     if (sockstate!=CONNECTED && sockstate!=PEER_CLOSED && sockstate!=CONNECTING && sockstate!=LISTENING)
diff --git a/src/transport/contract/TCPSocket.h b/src/transport/contract/TCPSocket.h
index 7d379e9..c7c62ad 100644
--- a/src/transport/contract/TCPSocket.h
+++ b/src/transport/contract/TCPSocket.h
@@ -1,5 +1,7 @@
 //
 // Copyright (C) 2004 Andras Varga
+// Copyright (C) 2010 Robin Seggelmann
+// Copyright (C) 2010-2012 Thomas Dreibholz
 //
 // This program is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public License
@@ -300,6 +302,11 @@ class INET_API TCPSocket
     void send(cMessage *msg);
 
     /**
+     * Sends command.
+     */
+    void sendCommand(cMessage *msg);
+
+    /**
      * Closes the local end of the connection. With TCP, a CLOSE operation
      * means "I have no more data to send", and thus results in a one-way
      * connection until the remote TCP closes too (or the FIN_WAIT_1 timeout
diff --git a/src/transport/sctp/SCTP.cc b/src/transport/sctp/SCTP.cc
index 2c38424..51c1d48 100644
--- a/src/transport/sctp/SCTP.cc
+++ b/src/transport/sctp/SCTP.cc
@@ -758,6 +758,9 @@ void SCTP::removeAssociation(SCTPAssociation* assoc)
     }
     assoc->statisticsQueuedSentBytes->setUtilizationMaximum(assoc->state->sendQueueLimit);
     assoc->statisticsQueuedReceivedBytes->setUtilizationMaximum((double)par("arwnd"));
+#ifdef PRIVATE
+    recordScalar("Blocking TSNs Moved", assoc->state->blockingTSNsMoved);
+#endif
 
     assoc->removePath();
     assoc->deleteStreams();
diff --git a/src/transport/sctp/SCTP.ned b/src/transport/sctp/SCTP.ned
index 4105408..c3c0f29 100644
--- a/src/transport/sctp/SCTP.ned
+++ b/src/transport/sctp/SCTP.ned
@@ -32,6 +32,8 @@ simple SCTP
         double rtoAlpha                     = default(0.125);
         double rtoBeta                      = default(0.250);
         int    maxBurst                     = default(4);
+        string maxBurstVariant              = default("useItOrLoseIt");   // T.D. 22.02.2010   // PRIVATE
+        int    initialWindow                = default(0);                 // T.D. 09.09.2010   // PRIVATE
         int    assocMaxRetrans              = default(10);
         int    pathMaxRetrans               = default(5);
         int    maxInitRetrans               = default(8);
@@ -94,6 +96,8 @@ simple SCTP
         //#====== SACK Now ====================================================
         bool   sackNow                      = default(false);
 
+        //#====== High-Speed CC ===============================================       // PRIVATE
+        bool   highSpeedCC                  = default(false);    // T.D. 22.02.2010   // PRIVATE
 
         //#====== SACK Sequence Numbers =======================================
         bool   checkSackSeqNumber           = default(false);    // T.D. 23.02.2010
@@ -101,6 +105,51 @@ simple SCTP
         //#====== NR-SACK =====================================================
         bool   nrSack                       = default(false);    // T.D. 03.03.2010
         bool   disableReneging              = default(false);    // T.D. 29.10.2010
+        int    gapReportLimit               = default(100000000);// T.D. 29.10.2010   // PRIVATE
+        string gapListOptimizationVariant   = default("none");   // T.D. 18.10.2010   // PRIVATE
+        bool   smartOverfullSACKHandling    = default(false);    // T.D. 25.10.2010   // PRIVATE
+
+        //#====== QoS-SCTP ====================================================       // PRIVATE
+        bool   allowQoSTracking             = default(false);    // T.D. 11.08.2009   // PRIVATE
+        double qosTrackingInterval @unit(s) = default(1.0s);     // T.D. 12.08.2009   // PRIVATE
+
+        //#====== CMT-SCTP ====================================================       // PRIVATE
+        string cmtSendAllVariant            = default("normal"); // T.D. 20.03.2009   // PRIVATE
+        string cmtRetransmissionVariant     = default("normal"); // T.D. 20.03.2009   // PRIVATE
+        string cmtCUCVariant                = default("normal"); // T.D. 23.03.2009   // PRIVATE
+        string cmtBufferSplitVariant        = default("none");   // T.D. 03.03.2010   // PRIVATE
+        bool   cmtBufferSplittingUsesOSB    = default(false);    // T.D. 19.11.2010   // PRIVATE
+        bool   cmtUseSFR                    = default(true);     // T.D. 24.03.2009   // PRIVATE
+        bool   cmtUseDAC                    = default(true);     // T.D. 25.03.2009   // PRIVATE
+        bool   cmtUseFRC                    = default(true);     // T.D. 02.12.2009   // PRIVATE
+        bool   cmtSmartT3Reset              = default(true);     // T.D. 02.03.2010   // PRIVATE
+        bool   cmtSmartFastRTX              = default(true);     // T.D. 11.03.2010   // PRIVATE
+        bool   cmtSmartReneging             = default(false);    // T.D. 24.02.2010   // PRIVATE
+        bool   cmtSlowPathRTTUpdate         = default(false);    // T.D. 25.02.2010   // PRIVATE
+        string cmtChunkReschedulingVariant  = default("none");   // T.D. 10.02.2010   // PRIVATE
+        double cmtChunkReschedulingThreshold= default(0.5);      // T.D. 10.02.2010   // PRIVATE
+        bool   cmtMovedChunksReduceCwnd     = default(true);     // T.D. 28.02.2010   // PRIVATE
+        double movedChunkFastRTXFactor      = default(2.0);      // T.D. 18.02.2010   // PRIVATE
+        string cmtSackPath                  = default("standard"); // T.D. 15.07.2011 // PRIVATE
+        //#====== CMT/RP-SCTP =================================================       // PRIVATE
+        bool   strictCwndBooking            = default(false);    // T.D. 06.01.2010   // PRIVATE
+        string cmtCCVariant                 = default("off");    // T.D. 19.01.2011   // PRIVATE
+        string cmtCCPathGroups              = default("");       // T.D. 28.01.2011   // PRIVATE
+        bool   rpPathBlocking               = default(false);    // T.D. 15.08.2011   // PRIVATE
+        bool   rpScaleBlockingTimeout       = default(false);    // T.D. 15.08.2011   // PRIVATE
+        int    rpMinCwnd                    = default(1);        // T.D. 15.08.2011   // PRIVATE
+
+        //#====== Test ========================================================       // PRIVATE
+        double testValue0                   = default(0);   // PRIVATE
+        double testValue1                   = default(0);   // PRIVATE
+        double testValue2                   = default(0);   // PRIVATE
+        double testValue3                   = default(0);   // PRIVATE
+        double testValue4                   = default(0);   // PRIVATE
+        string testString0                  = default("");  // PRIVATE
+        string testString1                  = default("");  // PRIVATE
+        string testString2                  = default("");  // PRIVATE
+        string testString3                  = default("");  // PRIVATE
+        string testString4                  = default("");  // PRIVATE
 
     gates:
         input  from_appl[] @labels(SCTPCommand/down);
diff --git a/src/transport/sctp/SCTPAlg.cc b/src/transport/sctp/SCTPAlg.cc
index 289144a..6b2f48d 100644
--- a/src/transport/sctp/SCTPAlg.cc
+++ b/src/transport/sctp/SCTPAlg.cc
@@ -58,7 +58,16 @@ void SCTPAlg::processTimer(cMessage* timer, SCTPEventCode& event)
 
 void SCTPAlg::sendCommandInvoked(SCTPPathVariables* path)
 {
-    assoc->sendOnPath(path);
+#ifdef PRIVATE
+    if(state->allowCMT) {
+       assoc->sendOnAllPaths(path);
+    }
+    else {
+#endif
+        assoc->sendOnPath(path);
+#ifdef PRIVATE
+    }
+#endif
 }
 
 void SCTPAlg::receivedDataAck(uint32)
diff --git a/src/transport/sctp/SCTPAssociation.h b/src/transport/sctp/SCTPAssociation.h
index 23584b9..f3d8310 100644
--- a/src/transport/sctp/SCTPAssociation.h
+++ b/src/transport/sctp/SCTPAssociation.h
@@ -28,6 +28,9 @@
 #include "InterfaceTable.h"
 #include "InterfaceTableAccess.h"
 #include "TimeStatsCollector.h"
+#ifdef PRIVATE
+#include "QoSStatsCollector.h"
+#endif
 #include "ChunkMap.h"
 #include "GapList.h"
 #include "SCTPSeqNumbers.h"
@@ -246,6 +249,9 @@ enum SCTPStreamSchedulers
 #define SCTP_COOKIE_LENGTH                             76
 #define HB_INTERVAL                                    30
 #define PATH_MAX_RETRANS                                5
+#ifdef PRIVATE
+#define SCTP_COMPRESSED_NRSACK_CHUNK_LENGTH            16
+#endif
 
 #define SCTP_TIMEOUT_INIT_REXMIT           3   // initially 3 seconds
 #define SCTP_TIMEOUT_INIT_REXMIT_MAX     240   // 4 mins
@@ -306,6 +312,9 @@ class INET_API SCTPPathVariables : public cPolymorphic
     uint32             pmtu;
     // ====== Congestion Control ==========================================
     uint32             cwnd;
+#ifdef PRIVATE
+    uint32             tempCwnd;                       // I.R. 08.04.2010
+#endif
     uint32             ssthresh;
     uint32             partialBytesAcked;
     uint32             queuedBytes;                    // T.D. 19.02.2010
@@ -329,6 +338,48 @@ class INET_API SCTPPathVariables : public cPolymorphic
     cMessage*           BlockingTimer;
     cMessage*           ResetTimer;
     cMessage*           AsconfTimer;
+#ifdef PRIVATE
+    // ====== QoS-SCTP ====================================================
+    QoSStatsCollector  QoS;                            // T.D. 11.08.2010
+    // ====== High-Speed CC ===============================================
+    unsigned int       highSpeedCCThresholdIdx;        // T.D. 22.02.2010
+    // ====== Max Burst ===================================================
+    uint32             packetsInBurst;                 // T.D. 22.02.2010
+    // ====== CMT Split Fast Retransmission ===============================
+    bool               sawNewAck;                      // T.D. 24.03.2009
+    uint32             lowestNewAckInSack;             // T.D. 04.02.2010
+    uint32             highestNewAckInSack;            // T.D. 24.03.2009
+    // ====== CMT Pseudo CumAck (CUCv1) ===================================
+    bool               findPseudoCumAck;               // T.D. 23.03.2009
+    bool               newPseudoCumAck;                // T.D. 23.03.2009
+    uint32             pseudoCumAck;                   // T.D. 23.03.2009
+    // ====== CMT RTX Pseudo CumAck (CUCv2) ===============================
+    bool               findRTXPseudoCumAck;            // T.D. 24.03.2009
+    bool               newRTXPseudoCumAck;             // T.D. 24.03.2009
+    uint32             rtxPseudoCumAck;                // T.D. 24.03.2009
+    uint32             oldestChunkTSN;                 // T.D. 02.03.2010
+    simtime_t          oldestChunkSendTime;            // T.D. 02.03.2010
+    simtime_t          newOldestChunkSendTime;         // T.D. 02.03.2010
+    // ====== CMT Round-Robin among Paths =================================
+    simtime_t          lastTransmission;               // T.D. 24.03.2009
+    unsigned int       sendAllRandomizer;
+    // ====== CMT/RP-SCTP =================================================
+    unsigned int       cmtCCGroup;                     // T.D. 27.01.2011
+    unsigned int       cmtGroupPaths;                  // T.D. 01.02.2011
+    uint32             utilizedCwnd;                   // T.D. 03.02.2011
+    uint32             cmtGroupTotalUtilizedCwnd;      // T.D. 03.02.2011
+    uint32             cmtGroupTotalCwnd;              // T.D. 01.02.2011
+    uint32             cmtGroupTotalSsthresh;          // T.D. 01.02.2011
+    double             cmtGroupTotalCwndBandwidth;     // T.D. 03.02.2011
+    double             cmtGroupTotalUtilizedCwndBandwidth; // T.D. 03.02.2011
+    double             cmtGroupAlpha;                  // T.D. 01.02.2011
+    // ====== CMT Sender Buffer Control ===================================
+    simtime_t          blockingTimeout;                // T.D. 15.02.2010: do not use path until given time
+    // ====== CMT Slow Path RTT Calculation ===============================
+    bool               waitingForRTTCalculaton;        // T.D. 25.02.2010
+    simtime_t          txTimeForRTTCalculation;        // T.D. 25.02.2010
+    uint32             tsnForRTTCalculation;           // T.D. 25.02.2010
+#endif
 
     // ====== Path Status =================================================
     simtime_t           heartbeatTimeout;
@@ -372,6 +423,11 @@ class INET_API SCTPPathVariables : public cPolymorphic
     cOutVector*         vectorPathTSNTimerBased;
     cOutVector*         vectorPathAckedTSNCumAck;
     cOutVector*         vectorPathAckedTSNGapAck;
+#ifdef PRIVATE
+    cOutVector*         vectorPathPseudoCumAck;
+    cOutVector*         vectorPathRTXPseudoCumAck;
+    cOutVector*         vectorPathBlockingTSNsMoved;
+#endif
     cOutVector*         vectorPathSentTSN;
     cOutVector*         vectorPathReceivedTSN;
     cOutVector*         vectorPathHb;
@@ -616,6 +672,87 @@ class INET_API SCTPStateVariables : public cPolymorphic
     uint32                   rtxMethod;
     // ====== Max Burst ===================================================
     uint32                   maxBurst;
+#ifdef PRIVATE
+    enum MBVariant {
+       MBV_UseItOrLoseIt                    = 0,
+       MBV_CongestionWindowLimiting         = 1,
+       MBV_UseItOrLoseItTempCwnd            = 2,
+       MBV_CongestionWindowLimitingTempCwnd = 3,
+       MBV_MaxBurst                         = 4,
+       MBV_AggressiveMaxBurst               = 5,
+       MBV_TotalMaxBurst                    = 6
+    };
+    MBVariant                maxBurstVariant;
+    uint32                   initialWindow;
+    // ====== CMT-SCTP ====================================================
+    bool                     allowCMT;
+    bool                     (*cmtSendAllComparisonFunction)(const SCTPPathVariables* left, const SCTPPathVariables* right);
+    const char*              cmtRetransmissionVariant;
+
+    enum CUCVariant {
+       CUCV_Normal         = 0,
+       CUCV_PseudoCumAck   = 1,
+       CUCV_PseudoCumAckV2 = 2
+    };
+    CUCVariant               cmtCUCVariant;               // Cwnd Update for CMT (CUC)
+
+    enum BufferSplitVariant {
+       CBSV_None         = 0,
+       CBSV_SenderOnly   = 1,
+       CBSV_ReceiverOnly = 2,
+       CBSV_BothSides    = 3
+    };
+    BufferSplitVariant       cmtBufferSplitVariant;       // Buffer Splitting for CMT
+    bool                     cmtBufferSplittingUsesOSB;  // Use outstanding instead of queued bytes for Buffer Splitting
+
+    enum ChunkReschedulingVariant {
+       CCRV_None         = 0,
+       CCRV_SenderOnly   = 1,
+       CCRV_ReceiverOnly = 2,
+       CCRV_BothSides    = 3,
+       CCRV_Test         = 99    // Test only!
+    };
+    ChunkReschedulingVariant cmtChunkReschedulingVariant;   // Chunk Rescheduling
+    double                   cmtChunkReschedulingThreshold; // Blocking Threshold for Chunk Rescheduling
+
+    bool                     cmtSmartT3Reset;            // Smart T3 Reset for CMT
+    bool                     cmtSmartFastRTX;            // Smart Fast RTX for CMT
+    bool                     cmtSmartReneging;           // Smart Reneging for CMT
+    bool                     cmtSlowPathRTTUpdate;       // Slow Path RTT Update for CMT
+    bool                     cmtUseSFR;                  // Split Fast Retransmission (SFR) for CMT
+    bool                     cmtUseDAC;                  // Delayed Ack for CMT (DAC)
+    bool                     cmtUseFRC;                  // Fast Recovery for CMT (FRC)
+    bool                     cmtIntelligentReneging;     // Consider SACK path on reneging
+    bool                     cmtSuspendPathOnBlocking;   // After moving blocking chunk, do not use path for Timer-Based RTX during 1 RTO
+    bool                     cmtMovedChunksReduceCwnd;   // Subtract moved chunk from cwnd of old path
+    double                   movedChunkFastRTXFactor;
+    unsigned int             blockingTSNsMoved;
+    bool                     strictCwndBooking;          // Strict overbooking handling
+    enum CSackPath {
+       CSP_Standard     = 0,
+       CSP_Primary      = 1,
+       CSP_RoundRobin   = 2,
+       CSP_SmallestSRTT = 3
+    };
+    CSackPath                cmtSackPath;                // SACK path selection variant for CMT
+    // ====== High-Speed SCTP =============================================
+    bool                     highSpeedCC;                // HighSpeed CC (RFC 3649)
+
+    // ====== CMT/RP-SCTP =================================================
+    enum CCCVariant {
+       CCCV_Off         = 0,   // Standard SCTP
+       CCCV_CMT         = 1,   // CMT-SCTP
+       CCCV_CMTRPv1     = 2,   // CMT/RP-SCTP with path MTU optimization
+       CCCV_CMTRPv2     = 3,   // CMT/RP-SCTP with path MTU optimization and bandwidth consideration
+       CCCV_Like_MPTCP  = 4,   // RP like MPTCP
+       CCCV_CMTRP_Test1 = 100,
+       CCCV_CMTRP_Test2 = 101
+    };
+    CCCVariant               cmtCCVariant;
+    bool                     rpPathBlocking;          // T.D. 10.08.2011: CMT/RP path blocking
+    bool                     rpScaleBlockingTimeout;  // T.D. 15.08.2011: Scale blocking timeout by number of paths
+    uint32                   rpMinCwnd;               // T.D. 15.08.2011: Minimum cwnd in MTUs
+#endif
 
     // ====== SACK Sequence Number Checker ================================
     bool                     checkSackSeqNumber;         // Ensure handling SACKs in original sequence
@@ -742,6 +879,10 @@ class INET_API SCTPAssociation : public cObject
     cMessage*             FairStartTimer;
     cMessage*             FairStopTimer;
 
+#ifdef PRIVATE
+    // ------ CMT Delayed Ack (DAC) ---------------------
+    uint8_t               dacPacketsRcvd;
+#endif
 
   protected:
     AddressVector         localAddressList;
@@ -994,6 +1135,11 @@ class INET_API SCTPAssociation : public cObject
     void putInDeliveryQ(const uint16 sid);
     bool msgMustBeAbandoned(SCTPDataMsg* msg, int32 stream, bool ordered); //PR-SCTP
     void advancePeerTsn();
+#ifdef PRIVATE
+    inline void cucProcessGapReports(const SCTPDataVariables* chunk,
+                                     SCTPPathVariables*       path,
+                                     const bool               isAcked);   // CMT-SCTP
+#endif
 
     /** Utility: prints local/remote addr/port and app gate index/assocId */
     void printAssocBrief();
@@ -1140,6 +1286,9 @@ class INET_API SCTPAssociation : public cObject
     void timeForSack(bool& sackOnly, bool& sackWithData);
     void sendSACKviaSelectedPath(SCTPMessage* sctpMsg);
     void checkOutstandingBytes();
+#ifdef PRIVATE
+      void updateHighSpeedCCThresholdIdx(SCTPPathVariables* path);
+#endif
     uint32 getInitialCwnd(const SCTPPathVariables* path) const;
     void recordCwndUpdate(SCTPPathVariables* path);
     void generateSendQueueAbatedIndication(const uint64 bytes);
@@ -1195,6 +1344,17 @@ class INET_API SCTPAssociation : public cObject
     void recordAcknowledgement(SCTPDataVariables* chunk, SCTPPathVariables* path);
     void recordDequeuing(SCTPDataVariables* chunk);
 
+#ifdef PRIVATE
+    void checkPseudoCumAck(const SCTPPathVariables* path);
+    static bool pathMapLargestSSThreshold(const SCTPPathVariables* left, const SCTPPathVariables* right);
+    static bool pathMapLargestSpace(const SCTPPathVariables* left, const SCTPPathVariables* right);
+    static bool pathMapLargestSpaceAndSSThreshold(const SCTPPathVariables* left, const SCTPPathVariables* right);
+    static bool pathMapSmallestLastTransmission(const SCTPPathVariables* left, const SCTPPathVariables* right);
+    static bool pathMapRandomized(const SCTPPathVariables* left, const SCTPPathVariables* right);
+    std::vector<SCTPPathVariables*> getSortedPathMap();
+    void chunkReschedulingControl(SCTPPathVariables* path);
+#endif
+
     void dumpPaths(std::ostream& os = sctpEV3) const;
     void dumpQueue(std::ostream& os = sctpEV3);
 
diff --git a/src/transport/sctp/SCTPAssociationBase.cc b/src/transport/sctp/SCTPAssociationBase.cc
index 975922a..25c7433 100644
--- a/src/transport/sctp/SCTPAssociationBase.cc
+++ b/src/transport/sctp/SCTPAssociationBase.cc
@@ -69,9 +69,33 @@ SCTPPathVariables::SCTPPathVariables(const IPvXAddress& addr,
     cwndTimeout = pathRto;
     cwnd = 0;
     ssthresh = 0;
+#ifdef PRIVATE
+    tempCwnd = 0;
+#endif
     rttUpdateTime = 0.0;
     fastRecoveryExitPoint = 0;
     fastRecoveryActive = false;
+#ifdef PRIVATE   // T.D. 23.03.2009
+     cmtCCGroup               = 0;
+     lastTransmission         = simTime();
+     sendAllRandomizer        = uniform(0, (1 << 31));
+     pseudoCumAck             = 0;
+     newPseudoCumAck          = false;
+     findPseudoCumAck         = true;   // Set findPseudoCumAck to TRUE for new destination.
+     rtxPseudoCumAck          = 0;
+     newRTXPseudoCumAck       = false;
+     findRTXPseudoCumAck      = true;   // Set findRTXPseudoCumAck to TRUE for new destination.
+     oldestChunkTSN           = 0;
+     oldestChunkSendTime      = simTime();
+     highestNewAckInSack      = 0;
+     lowestNewAckInSack       = 0;
+     waitingForRTTCalculaton  = false;
+     tsnForRTTCalculation     = 0;
+     txTimeForRTTCalculation  = 0;
+     blockingTimeout          = simTime();
+     packetsInBurst           = 0;
+     highSpeedCCThresholdIdx  = 0;
+#endif
 
     numberOfFastRetransmissions = 0;
     numberOfTimerBasedRetransmissions = 0;
@@ -119,6 +143,13 @@ SCTPPathVariables::SCTPPathVariables(const IPvXAddress& addr,
     AsconfTimer->setControlInfo(pinfo->dup());
 
     // ====== Statistics =====================================================
+#ifdef PRIVATE
+   snprintf(str, sizeof(str), "Path %d:%s", assoc->assocId, addr.str().c_str());
+   QoS.initialize(assoc->sctpMain, str);
+   if((bool)assoc->getSctpMain()->par("allowQoSTracking") == true) {
+      QoS.activate(((simtime_t)assoc->getSctpMain()->par("qosTrackingInterval")).dbl());
+   }
+#endif
     snprintf(str, sizeof(str), "RTO %d:%s", assoc->assocId, addr.str().c_str());
     statisticsPathRTO = new TimeStatsCollector(assoc->sctpMain, str, "s");
     snprintf(str, sizeof(str), "RTT %d:%s", assoc->assocId, addr.str().c_str());
@@ -176,6 +207,14 @@ SCTPPathVariables::SCTPPathVariables(const IPvXAddress& addr,
     snprintf(str, sizeof(str), "TSN Acked GapAck %d:%s", assoc->assocId, addr.str().c_str());
     vectorPathAckedTSNGapAck = new cOutVector(str);
 
+#ifdef PRIVATE
+    snprintf(str, sizeof(str), "TSN PseudoCumAck %d:%s", assoc->assocId, addr.str().c_str());
+    vectorPathPseudoCumAck = new cOutVector(str);
+    snprintf(str, sizeof(str), "TSN RTXPseudoCumAck %d:%s", assoc->assocId, addr.str().c_str());
+    vectorPathRTXPseudoCumAck = new cOutVector(str);
+    snprintf(str, sizeof(str), "Blocking TSNs Moved %d:%s", assoc->assocId, addr.str().c_str());
+    vectorPathBlockingTSNsMoved = new cOutVector(str);
+#endif
 }
 
 SCTPPathVariables::~SCTPPathVariables()
@@ -217,6 +256,11 @@ SCTPPathVariables::~SCTPPathVariables()
     delete vectorPathAckedTSNCumAck;
     delete vectorPathAckedTSNGapAck;
 
+#ifdef PRIVATE
+    delete vectorPathPseudoCumAck;
+    delete vectorPathRTXPseudoCumAck;
+    delete vectorPathBlockingTSNsMoved;
+#endif
 }
 
 
@@ -372,6 +416,9 @@ SCTPStateVariables::SCTPStateVariables()
         peerTieTag[i] = 0;
     }
     count = 0;
+#ifdef PRIVATE
+    blockingTSNsMoved = 0;
+#endif
 }
 
 SCTPStateVariables::~SCTPStateVariables()
@@ -519,6 +566,10 @@ SCTPAssociation::SCTPAssociation(SCTP* _module, int32 _appGateIndex, int32 _asso
     snprintf(vectorName, sizeof(vectorName), "End to End Delay");
     EndToEndDelay = new cOutVector(vectorName);
 
+#ifdef PRIVATE
+    // ====== CMT Delayed Ack ================================================
+    dacPacketsRcvd = 0;   // T.D. 25.03.09: CMT DAC
+#endif
 
     // ====== Assoc throughput ===============================================
     snprintf(vectorName, sizeof(vectorName), "Throughput of Association %d", assocId);
@@ -1009,6 +1060,212 @@ void SCTPAssociation::stateEntered(int32 status)
             state->checkSackSeqNumber = (bool)sctpMain->par("checkSackSeqNumber");
             state->outgoingSackSeqNum = 0;
             state->incomingSackSeqNum = 0;
+#ifdef PRIVATE
+            state->highSpeedCC                 = (bool)sctpMain->par("highSpeedCC");
+            state->initialWindow               = (uint32)sctpMain->par("initialWindow");
+            if(strcmp((const char*)sctpMain->par("maxBurstVariant"), "useItOrLoseIt") == 0) {
+               state->maxBurstVariant = SCTPStateVariables::MBV_UseItOrLoseIt;
+            }
+            else if(strcmp((const char*)sctpMain->par("maxBurstVariant"), "congestionWindowLimiting") == 0) {
+               state->maxBurstVariant = SCTPStateVariables::MBV_CongestionWindowLimiting;
+            }
+            else if(strcmp((const char*)sctpMain->par("maxBurstVariant"), "maxBurst") == 0) {
+               state->maxBurstVariant = SCTPStateVariables::MBV_MaxBurst;
+            }
+            else if(strcmp((const char*)sctpMain->par("maxBurstVariant"), "aggressiveMaxBurst") == 0) {
+               state->maxBurstVariant = SCTPStateVariables::MBV_AggressiveMaxBurst;
+            }
+            else if(strcmp((const char*)sctpMain->par("maxBurstVariant"), "totalMaxBurst") == 0) {
+               state->maxBurstVariant = SCTPStateVariables::MBV_TotalMaxBurst;
+            }
+            else if(strcmp((const char*)sctpMain->par("maxBurstVariant"), "useItOrLoseItTempCwnd") == 0) {
+               state->maxBurstVariant = SCTPStateVariables::MBV_UseItOrLoseItTempCwnd;
+            }
+            else if(strcmp((const char*)sctpMain->par("maxBurstVariant"), "congestionWindowLimitingTempCwnd") == 0) {
+               state->maxBurstVariant = SCTPStateVariables::MBV_CongestionWindowLimitingTempCwnd;
+            }
+            else {
+               throw cRuntimeError("Invalid setting of maxBurstVariant: %s.",
+                        (const char*)sctpMain->par("maxBurstVariant"));
+            }
+
+            if(strcmp((const char*)sctpMain->par("cmtSendAllVariant"), "normal") == 0) {
+               state->cmtSendAllComparisonFunction = NULL;
+            }
+            else if(strcmp((const char*)sctpMain->par("cmtSendAllVariant"), "smallestLastTransmission") == 0) {
+               state->cmtSendAllComparisonFunction = pathMapSmallestLastTransmission;
+            }
+            else if(strcmp((const char*)sctpMain->par("cmtSendAllVariant"), "randomized") == 0) {
+               state->cmtSendAllComparisonFunction = pathMapRandomized;
+            }
+            else if(strcmp((const char*)sctpMain->par("cmtSendAllVariant"), "largestSSThreshold") == 0) {
+               state->cmtSendAllComparisonFunction = pathMapLargestSSThreshold;
+            }
+            else if(strcmp((const char*)sctpMain->par("cmtSendAllVariant"), "largestSpace") == 0) {
+               state->cmtSendAllComparisonFunction = pathMapLargestSpace;
+            }
+            else if(strcmp((const char*)sctpMain->par("cmtSendAllVariant"), "largestSpaceAndSSThreshold") == 0) {
+               state->cmtSendAllComparisonFunction = pathMapLargestSpaceAndSSThreshold;
+            }
+            else {
+               throw cRuntimeError("Invalid setting of cmtSendAllVariant: %s.",
+                        (const char*)sctpMain->par("cmtSendAllVariant"));
+            }
+
+            state->cmtRetransmissionVariant = sctpMain->par("cmtRetransmissionVariant");
+            if(strcmp((const char*)sctpMain->par("cmtCUCVariant"), "normal") == 0) {
+            state->cmtCUCVariant = SCTPStateVariables::CUCV_Normal;
+            }
+            else if(strcmp((const char*)sctpMain->par("cmtCUCVariant"), "pseudoCumAck") == 0) {
+               state->cmtCUCVariant = SCTPStateVariables::CUCV_PseudoCumAck;
+            }
+            else if(strcmp((const char*)sctpMain->par("cmtCUCVariant"), "pseudoCumAckV2") == 0) {
+               state->cmtCUCVariant = SCTPStateVariables::CUCV_PseudoCumAckV2;
+            }
+            else {
+               throw cRuntimeError("Bad setting for cmtCUCVariant: %s\n",
+                        (const char*)sctpMain->par("cmtCUCVariant"));
+            }
+            state->smartOverfullSACKHandling = (bool)sctpMain->par("smartOverfullSACKHandling");
+
+            if(strcmp((const char*)sctpMain->par("cmtChunkReschedulingVariant"), "none") == 0) {
+            state->cmtChunkReschedulingVariant = SCTPStateVariables::CCRV_None;
+            }
+            else if(strcmp((const char*)sctpMain->par("cmtChunkReschedulingVariant"), "senderOnly") == 0) {
+               state->cmtChunkReschedulingVariant = SCTPStateVariables::CCRV_SenderOnly;
+            }
+            else if(strcmp((const char*)sctpMain->par("cmtChunkReschedulingVariant"), "receiverOnly") == 0) {
+               state->cmtChunkReschedulingVariant = SCTPStateVariables::CCRV_ReceiverOnly;
+            }
+            else if(strcmp((const char*)sctpMain->par("cmtChunkReschedulingVariant"), "bothSides") == 0) {
+               state->cmtChunkReschedulingVariant = SCTPStateVariables::CCRV_BothSides;
+            }
+            else if(strcmp((const char*)sctpMain->par("cmtChunkReschedulingVariant"), "test") == 0) {
+               state->cmtChunkReschedulingVariant = SCTPStateVariables::CCRV_Test;
+            }
+            else {
+               throw cRuntimeError("Bad setting for cmtChunkReschedulingVariant: %s\n",
+                        (const char*)sctpMain->par("cmtChunkReschedulingVariant"));
+            }
+
+            if(strcmp((const char*)sctpMain->par("cmtBufferSplitVariant"), "none") == 0) {
+            state->cmtBufferSplitVariant = SCTPStateVariables::CBSV_None;
+            }
+            else if(strcmp((const char*)sctpMain->par("cmtBufferSplitVariant"), "senderOnly") == 0) {
+               state->cmtBufferSplitVariant = SCTPStateVariables::CBSV_SenderOnly;
+            }
+            else if(strcmp((const char*)sctpMain->par("cmtBufferSplitVariant"), "receiverOnly") == 0) {
+               state->cmtBufferSplitVariant = SCTPStateVariables::CBSV_ReceiverOnly;
+            }
+            else if(strcmp((const char*)sctpMain->par("cmtBufferSplitVariant"), "bothSides") == 0) {
+               state->cmtBufferSplitVariant = SCTPStateVariables::CBSV_BothSides;
+            }
+            else {
+               throw cRuntimeError("Bad setting for cmtBufferSplitVariant: %s\n",
+                        (const char*)sctpMain->par("cmtBufferSplitVariant"));
+            }
+            state->cmtBufferSplittingUsesOSB = (bool)sctpMain->par("cmtBufferSplittingUsesOSB");
+
+            if(strcmp((const char*)sctpMain->par("gapListOptimizationVariant"), "none") == 0) {
+               state->gapListOptimizationVariant = SCTPStateVariables::GLOV_None;
+            }
+            else if(strcmp((const char*)sctpMain->par("gapListOptimizationVariant"), "optimized1") == 0) {
+               state->gapListOptimizationVariant = SCTPStateVariables::GLOV_Optimized1;
+            }
+            else if(strcmp((const char*)sctpMain->par("gapListOptimizationVariant"), "optimized2") == 0) {
+               state->gapListOptimizationVariant = SCTPStateVariables::GLOV_Optimized2;
+            }
+            else if(strcmp((const char*)sctpMain->par("gapListOptimizationVariant"), "shrunken") == 0) {
+               state->gapListOptimizationVariant = SCTPStateVariables::GLOV_Shrunken;
+            }
+            else {
+               throw cRuntimeError("Bad setting for gapListOptimizationVariant: %s\n",
+                        (const char*)sctpMain->par("gapListOptimizationVariant"));
+            }
+
+            state->cmtUseSFR                     = (bool)sctpMain->par("cmtUseSFR");
+            state->cmtUseDAC                     = (bool)sctpMain->par("cmtUseDAC");
+            state->cmtUseFRC                     = (bool)sctpMain->par("cmtUseFRC");
+            state->gapReportLimit                = (uint32)sctpMain->par("gapReportLimit");
+            state->cmtSmartT3Reset               = (bool)sctpMain->par("cmtSmartT3Reset");
+            state->cmtSmartReneging              = (bool)sctpMain->par("cmtSmartReneging");
+            state->cmtSmartFastRTX               = (bool)sctpMain->par("cmtSmartFastRTX");
+            state->cmtSlowPathRTTUpdate          = (bool)sctpMain->par("cmtSlowPathRTTUpdate");
+            state->cmtMovedChunksReduceCwnd      = (bool)sctpMain->par("cmtMovedChunksReduceCwnd");
+            state->cmtChunkReschedulingThreshold = (double)sctpMain->par("cmtChunkReschedulingThreshold");
+            state->movedChunkFastRTXFactor       = (double)sctpMain->par("movedChunkFastRTXFactor");
+            state->strictCwndBooking             = (bool)sctpMain->par("strictCwndBooking");
+
+            if(strcmp((const char*)sctpMain->par("cmtSackPath"), "standard") == 0) {
+               state->cmtSackPath = SCTPStateVariables::CSP_Standard;
+            }
+            else if(strcmp((const char*)sctpMain->par("cmtSackPath"), "primary") == 0) {
+               state->cmtSackPath = SCTPStateVariables::CSP_Primary;
+            }
+            else if(strcmp((const char*)sctpMain->par("cmtSackPath"), "roundRobin") == 0) {
+               state->cmtSackPath = SCTPStateVariables::CSP_RoundRobin;
+            }
+            else if(strcmp((const char*)sctpMain->par("cmtSackPath"), "smallestSRTT") == 0) {
+               state->cmtSackPath = SCTPStateVariables::CSP_SmallestSRTT;
+            }
+            else {
+               throw cRuntimeError("Bad setting for cmtSackPath: %s\n",
+                        (const char*)sctpMain->par("cmtSackPath"));
+            }
+
+            if(strcmp((const char*)sctpMain->par("cmtCCVariant"), "off") == 0) {
+               state->cmtCCVariant = SCTPStateVariables::CCCV_Off;
+               state->allowCMT     = false;
+            }
+            else if(strcmp((const char*)sctpMain->par("cmtCCVariant"), "cmt") == 0) {
+               state->cmtCCVariant = SCTPStateVariables::CCCV_CMT;
+               state->allowCMT     = true;
+            }
+            else if( (strcmp((const char*)sctpMain->par("cmtCCVariant"), "like-mptcp") == 0) ||
+                     (strcmp((const char*)sctpMain->par("cmtCCVariant"), "mptcp-like") == 0) ) {
+               state->cmtCCVariant = SCTPStateVariables::CCCV_Like_MPTCP;
+               state->allowCMT     = true;
+            }
+            else if( (strcmp((const char*)sctpMain->par("cmtCCVariant"), "cmtrp") == 0) ||
+                     (strcmp((const char*)sctpMain->par("cmtCCVariant"), "cmtrpv1") == 0) ) {
+               state->cmtCCVariant = SCTPStateVariables::CCCV_CMTRPv1;
+               state->allowCMT     = true;
+            }
+            else if(strcmp((const char*)sctpMain->par("cmtCCVariant"), "cmtrpv2") == 0) {
+               state->cmtCCVariant = SCTPStateVariables::CCCV_CMTRPv2;
+               state->allowCMT     = true;
+            }
+            else if(strcmp((const char*)sctpMain->par("cmtCCVariant"), "cmtrp-t1") == 0) {
+               state->cmtCCVariant = SCTPStateVariables::CCCV_CMTRP_Test1;
+               state->allowCMT     = true;
+            }
+            else if(strcmp((const char*)sctpMain->par("cmtCCVariant"), "cmtrp-t2") == 0) {
+               state->cmtCCVariant = SCTPStateVariables::CCCV_CMTRP_Test2;
+               state->allowCMT     = true;
+            }
+            else {
+               throw cRuntimeError("Bad setting for cmtCCVariant: %s\n",
+                        (const char*)sctpMain->par("cmtCCVariant"));
+            }
+
+            state->rpPathBlocking         = (bool)sctpMain->par("rpPathBlocking");
+            state->rpScaleBlockingTimeout = (bool)sctpMain->par("rpScaleBlockingTimeout");
+            state->rpMinCwnd              = sctpMain->par("rpMinCwnd");
+
+            cStringTokenizer pathGroupsTokenizer(sctpMain->par("cmtCCPathGroups").stringValue());
+            if(pathGroupsTokenizer.hasMoreTokens()) {
+               SCTPPathMap::iterator pathIterator = sctpPathMap.begin();
+               while(pathIterator != sctpPathMap.end()) {
+                  const char* token = pathGroupsTokenizer.nextToken();
+                  if(token == NULL) {
+                     throw cRuntimeError("Too few cmtCCGroup values to cover all paths!");
+                  }
+                  SCTPPathVariables* path = pathIterator->second;
+                  path->cmtCCGroup = atol(token);
+                  pathIterator++;
+               }
+            }
+#endif
 
             state->osbWithHeader = (bool)sctpMain->par("osbWithHeader");
             state->padding = (bool)sctpMain->par("padding");
diff --git a/src/transport/sctp/SCTPAssociationEventProc.cc b/src/transport/sctp/SCTPAssociationEventProc.cc
index dc52357..d945b7a 100644
--- a/src/transport/sctp/SCTPAssociationEventProc.cc
+++ b/src/transport/sctp/SCTPAssociationEventProc.cc
@@ -241,7 +241,17 @@ void SCTPAssociation::process_SEND(SCTPEventCode& event, SCTPCommand* sctpComman
     // ------ Set initial destination address -----------------------------
     if (sendCommand->getPrimary()) {
         if (sendCommand->getRemoteAddr() == IPvXAddress("0.0.0.0")) {
-            datMsg->setInitialDestination(remoteAddr);
+#ifdef PRIVATE
+            if(state->allowCMT == false) {
+#endif
+                datMsg->setInitialDestination(remoteAddr);
+#ifdef PRIVATE
+            }
+            else {
+                // Do not make a path decision for CMT yet!
+                datMsg->setInitialDestination(IPvXAddress());
+            }
+#endif
         }
         else {
             datMsg->setInitialDestination(sendCommand->getRemoteAddr());
@@ -270,12 +280,18 @@ void SCTPAssociation::process_SEND(SCTPEventCode& event, SCTPCommand* sctpComman
     if (sendUnordered == 1) {
         datMsg->setOrdered(false);
         stream->getUnorderedStreamQ()->insert(datMsg);
+#ifdef PRIVATE
+        stream->UnorderedQoS.recordEnqueuing(datMsg->getByteLength(), simTime());
+#endif
     }
     else {
         datMsg->setOrdered(true);
         stream->getStreamQ()->insert(datMsg);
 
         sendQueue->record(stream->getStreamQ()->getLength());
+#ifdef PRIVATE
+        stream->OrderedQoS.recordEnqueuing(datMsg->getByteLength(), simTime());
+#endif
     }
 
     // ------ Send buffer full? -------------------------------------------
diff --git a/src/transport/sctp/SCTPAssociationRcvMessage.cc b/src/transport/sctp/SCTPAssociationRcvMessage.cc
index 880e2a1..d8929e3 100644
--- a/src/transport/sctp/SCTPAssociationRcvMessage.cc
+++ b/src/transport/sctp/SCTPAssociationRcvMessage.cc
@@ -235,7 +235,11 @@ bool SCTPAssociation::process_RCV_Message(SCTPMessage*       sctpmsg,
                 if (!(fsm->getState() == SCTP_S_SHUTDOWN_RECEIVED || fsm->getState() == SCTP_S_SHUTDOWN_ACK_SENT)) {
                     SCTPDataChunk* dataChunk;
                     dataChunk = check_and_cast<SCTPDataChunk*>(header);
-                    if ((dataChunk->getByteLength()- 16) > 0) {
+                    if ((dataChunk->getByteLength() - 16) > 0) {
+#ifdef PRIVATE
+                        // T.D. 25.03.09: CMT DAC
+                        dacPacketsRcvd++;
+#endif
                         const SCTPEventCode event = processDataArrived(dataChunk);
                         if (event == SCTP_E_DELIVERED) {
                             if ((state->streamReset) &&
@@ -899,6 +903,12 @@ void SCTPAssociation::tsnWasReneged(SCTPDataVariables*       chunk,
         const SCTPPathVariables* sackPath,
         const int                type)
 {
+#ifdef PRIVATE
+    if( (state->allowCMT) && (state->cmtSmartReneging) &&
+        (sackPath != chunk->ackedOnPath) ) {
+        return;
+    }
+#endif
 
     sctpEV3 << "TSN " << chunk->tsn << " has been reneged (type "
             << type << ")" << endl;
@@ -915,6 +925,63 @@ void SCTPAssociation::tsnWasReneged(SCTPDataVariables*       chunk,
 }
 
 
+#ifdef PRIVATE
+// T.D. 22.11.09: Rewrite of CUCv2 for better readability
+// SACK processing code iterates over all TSNs in the RTX queue.
+// Calls cucProcessGapReports() for each TSN, setting isAcked=TRUE
+//   for chunks being acked, isAcked=FALSE otherwise.
+inline void SCTPAssociation::cucProcessGapReports(const SCTPDataVariables* chunk,
+                                                  SCTPPathVariables*       path,
+                                                  const bool               isAcked)
+{
+   // T.D. 03.02.2010: We only care for newly acked chunks.
+   //                  Therefore, the previous state must be "unacked".
+   if(chunkHasBeenAcked(chunk) == false) {
+      // T.D. 04.12.09: CUCv2
+      // For CUCv2, it has to be checked whether it is the first transmission.
+      // Otherwise, the behaviour will be like CUCv1 -> decreasing PseudoCumAck on T3 RTX!
+      if((path->findPseudoCumAck == true) &&
+         ( (chunk->numberOfRetransmissions == 0) ||
+            (state->cmtCUCVariant == SCTPStateVariables::CUCV_PseudoCumAck)) ) {
+         path->pseudoCumAck     = chunk->tsn;
+         path->findPseudoCumAck = false;
+      }
+      if((isAcked) &&   /* Not acked before and acked now => ack for the first time */
+         (path->pseudoCumAck == chunk->tsn)) {
+         path->newPseudoCumAck  = true;
+         path->findPseudoCumAck = true;
+      }
+
+      // T.D. 24.03.09: CUCv2
+      if((path->findRTXPseudoCumAck == true) &&
+         (chunk->numberOfRetransmissions > 0) ) {
+         path->rtxPseudoCumAck     = chunk->tsn;
+         path->findRTXPseudoCumAck = false;
+      }
+      if((isAcked) &&   /* Not acked before and acked now => ack for the first time */
+         (path->rtxPseudoCumAck == chunk->tsn)) {
+         path->newRTXPseudoCumAck  = true;
+         path->findRTXPseudoCumAck = true;
+      }
+   }
+
+/*
+   if(sctpMain->testing) {
+      sctpEV3 << "cucProcessing: "
+              << chunk->tsn << " on " << path->remoteAddress
+              << " (" << ((chunkHasBeenAcked(chunk) == false) ? (isAcked ? "NEWLY ACKED" : "not acked") : "acked")
+              << ( (chunk->numberOfRetransmissions == 0) ? "" : ",rtx!") << ")  \t  "
+              << "findPseudoCumAck="    << ((path->findPseudoCumAck == true) ? "true" : "false")    << "\t"
+              << "pseudoCumAck="        << path->pseudoCumAck    << "\t"
+              << "newPseudoCumAck="     << ((path->newPseudoCumAck == true) ? "true" : "false")     << "  \t  "
+              << "findRTXPseudoCumAck=" << ((path->findRTXPseudoCumAck == true) ? "true" : "false") << "\t"
+              << "rtxPseudoCumAck="     << path->rtxPseudoCumAck << "\t"
+              << "newRTXPseudoCumAck="  << ((path->newRTXPseudoCumAck == true) ? "true" : "false")  << "\t"
+              << endl;
+   }
+*/
+}
+#endif
 
 
 SCTPEventCode SCTPAssociation::processSackArrived(SCTPSackChunk* sackChunk)
@@ -989,6 +1056,14 @@ SCTPEventCode SCTPAssociation::processSackArrived(SCTPSackChunk* sackChunk)
                 << "outstanding=" << path->outstandingBytes << "\t"
                 << "T3scheduled=" << path->T3_RtxTimer->getArrivalTime() << " "
                 << (path->T3_RtxTimer->isScheduled() ? "[ok]" : "[NOT SCHEDULED]") << "\t"
+#ifdef PRIVATE
+                << "findPseudoCumAck="    << ((myPath->findPseudoCumAck == true) ? "true" : "false")    << "\t"
+                << "pseudoCumAck="        << myPath->pseudoCumAck    << "\t"
+                << "newPseudoCumAck="     << ((myPath->newPseudoCumAck == true) ? "true" : "false")     << "\t"
+                << "findRTXPseudoCumAck=" << ((myPath->findRTXPseudoCumAck == true) ? "true" : "false") << "\t"
+                << "rtxPseudoCumAck="     << myPath->rtxPseudoCumAck << "\t"
+                << "newRTXPseudoCumAck="  << ((myPath->newRTXPseudoCumAck == true) ? "true" : "false")  << "\t"
+#endif
                 << endl;
     }
 
@@ -1033,6 +1108,15 @@ SCTPEventCode SCTPAssociation::processSackArrived(SCTPSackChunk* sackChunk)
         myPath->gapUnackedChunksInLastSACK = 0;
         myPath->newlyAckedBytes = 0;
         myPath->newCumAck = false;   // Check whether CumAck affects this path
+#ifdef PRIVATE
+        // T.D. 23.03.09: for all destinations, set newPseudoCumAck to FALSE.
+        myPath->newPseudoCumAck                 = false;
+        myPath->newRTXPseudoCumAck              = false;   // CUCv2
+        myPath->sawNewAck                       = false;
+        myPath->lowestNewAckInSack              = 0;
+        myPath->highestNewAckInSack             = 0;
+        myPath->newOldestChunkSendTime          = simTime() + 9999.99;   // initialize to more than simTime()
+#endif
         if (myPath == path) {
             myPath->lastAckTime = simTime();
         }
@@ -1075,10 +1159,68 @@ SCTPEventCode SCTPAssociation::processSackArrived(SCTPSackChunk* sackChunk)
         }
         chunkMap->cumAck(tsna);
 
+#ifdef PRIVATE
+      // ====== Slow Path RTT Calculation ===================================
+      // T.D. 10.03.2010: Slow Path RTT Calculation
+      if( (state->allowCMT == true) &&
+          (state->cmtSlowPathRTTUpdate == true) &&
+          (path->waitingForRTTCalculaton == true) &&
+          ((path->tsnForRTTCalculation == tsna) ||
+           (tsnLt(path->tsnForRTTCalculation, tsna))) ) {
+         // Got update from CumAck -> no need for Slow Path RTT calculation
+         path->waitingForRTTCalculaton = false;
+      }
+#endif
     }
     else if (tsnLt(tsna, state->lastTsnAck)) {
         sctpEV3 << "Stale CumAck (" << tsna << " < " << state->lastTsnAck << ")"
                 << endl;
+#ifdef PRIVATE
+        // ====== Slow Path RTT Calculation ===================================
+        // T.D. 10.03.2010: Slow Path RTT Calculation
+        if( (state->allowCMT == true) &&
+            (state->cmtSlowPathRTTUpdate == true) &&
+            (path->waitingForRTTCalculaton == true) ) {
+            // T.D. 25.02.2010: Slow Path Update
+            // Look for a CumAck or GapAck of the remembered chunk on this path.
+            // If it has been found, we can compute the RTT of this path.
+
+            // ====== Look for matching CumAck first ===========================
+            bool renewRTT = false;
+            if( (tsnLt(path->tsnForRTTCalculation, tsna)) ||
+                (path->tsnForRTTCalculation == tsna) ) {
+                renewRTT = true;
+            }
+            // ====== Look for matching GapAck =================================
+            else if( (numGaps > 0) &&
+                     ((path->tsnForRTTCalculation == sackGapList.getGapStop(GapList::GT_Any, numGaps - 1)) ||
+                      (tsnLt(path->tsnForRTTCalculation, sackGapList.getGapStop(GapList::GT_Any, numGaps - 1)))) ) {
+                for (int32 key = 0;key < numGaps; key++) {
+                   const uint32 lo = sackGapList.getGapStart(GapList::GT_Any, key);
+                   const uint32 hi = sackGapList.getGapStop(GapList::GT_Any, key);
+                   if( (path->tsnForRTTCalculation == lo) ||
+                       (path->tsnForRTTCalculation == hi) ||
+                       ( tsnLt(lo, path->tsnForRTTCalculation) &&
+                         tsnLt(path->tsnForRTTCalculation, hi) ) ) {
+                       renewRTT = true;
+                       break;
+                   }
+               }
+           }
+
+           if(renewRTT) {
+               rttEstimation = simTime() - path->txTimeForRTTCalculation;
+               path->waitingForRTTCalculaton = false;
+               pmRttMeasurement(path, rttEstimation);
+
+               sctpEV3 << simTime() << ": SlowPathRTTUpdate from stale SACK - rtt="
+                       << rttEstimation << " from TSN "
+                       << path->tsnForRTTCalculation
+                       << " on path " << path->remoteAddress
+                       << " => RTO=" << path->pathRto << endl;
+           }
+       }
+#endif
         return SCTP_E_IGNORE;
     }
 
@@ -1149,14 +1291,35 @@ SCTPEventCode SCTPAssociation::processSackArrived(SCTPSackChunk* sackChunk)
 
         // ====== Looking for changes in the gap reports ======================
         sctpEV3 << "Looking for changes in gap reports" << endl;
+#ifdef PRIVATE   // T.D. 23.03.09: Get Pseudo CumAck for paths
+        uint32 lo1      = tsna;
+        uint32 tsnCheck = tsna + 1;   // T.D. 22.11.09: Just to make sure that no TSN is misssed
+#endif
         for (int32 key = 0; key < numGaps; key++) {
             const uint32 lo = sackGapList.getGapStart(GapList::GT_Any, key);
             const uint32 hi = sackGapList.getGapStop(GapList::GT_Any, key);
 
+#ifdef PRIVATE   // T.D. 22.11.09: CUCv2
+            // ====== Iterate over TSNs *not* listed in gap reports ============
+            for (uint32 pos = lo1+1; pos <= lo-1;pos++) {
+               assert(tsnCheck == pos);   tsnCheck++;
+               SCTPDataVariables* myChunk = chunkMap->getChunk(pos);
+                if(myChunk) {
+                    SCTPPathVariables* myChunkLastPath = myChunk->getLastDestinationPath();
+                    assert(myChunkLastPath != NULL);
+                    // T.D. 22.11.09: CUCv2 - chunk is *not* acked
+                    cucProcessGapReports(myChunk, myChunkLastPath, false);
+                }
+            }
+            lo1 = sackGapList.getGapStop(GapList::GT_Any, key);
+#endif
 
             // ====== Iterate over TSNs in gap reports =========================
             sctpEV3 << "Examine TSNs between " << lo << " and " << hi << endl;
             for (uint32 pos = lo; pos <= hi; pos++) {
+#ifdef PRIVATE
+                assert(tsnCheck == pos);   tsnCheck++;
+#endif
 
                 // ====== Newly acked chunk =====================================
                 if (chunkMap->isAcked(pos) == false) {
@@ -1164,6 +1327,10 @@ SCTPEventCode SCTPAssociation::processSackArrived(SCTPSackChunk* sackChunk)
                     if (myChunk) {
                         SCTPPathVariables* myChunkLastPath = myChunk->getLastDestinationPath();
                         assert(myChunkLastPath != NULL);
+#ifdef PRIVATE
+                        // T.D. 22.11.09: CUCv2 - chunk is acked
+                        cucProcessGapReports(myChunk, myChunkLastPath, true);
+#endif
                         // T.D. 02.02.2010: This chunk has been acked newly.
                         //                  Let's process this new acknowledgement!
                         handleChunkReportedAsAcked(highestNewAck, rttEstimation, myChunk,
@@ -1174,6 +1341,24 @@ SCTPEventCode SCTPAssociation::processSackArrived(SCTPSackChunk* sackChunk)
                         }
                     }
                     else {
+#ifdef PRIVATE
+                        // T.D. 10.03.2010: Slow Path RTT Calculation
+                        if( (path->tsnForRTTCalculation == myChunk->tsn) &&
+                            (path->waitingForRTTCalculaton == true) &&
+                            (state->allowCMT == true) &&
+                            (state->cmtSlowPathRTTUpdate == true) &&
+                            (myChunk->getLastDestinationPath() == path) ) {
+                            const simtime_t rttEstimation = simTime() - path->txTimeForRTTCalculation;
+                            path->waitingForRTTCalculaton = false;
+                            pmRttMeasurement(path, rttEstimation);
+
+                            sctpEV3 << simTime() << ": SlowPathRTTUpdate from gap report - rtt="
+                                    << rttEstimation << " from TSN "
+                                    << path->tsnForRTTCalculation
+                                    << " on path " << path->remoteAddress
+                                    << " => RTO=" << path->pathRto << endl;
+                        }
+#endif
                     }
                 }
 
@@ -1314,14 +1499,41 @@ SCTPEventCode SCTPAssociation::processSackArrived(SCTPSackChunk* sackChunk)
         SCTPPathVariables* myPath = piter->second;
         const IPvXAddress& myPathId = myPath->remoteAddress;
 
+#ifdef PRIVATE
+        if(myPath->newPseudoCumAck) {
+            myPath->vectorPathPseudoCumAck->record(myPath->pseudoCumAck);
+        }
+        if(myPath->newRTXPseudoCumAck) {
+            myPath->vectorPathRTXPseudoCumAck->record(myPath->rtxPseudoCumAck);
+        }
+#endif
 
         if (myPath->newlyAckedBytes > 0) {
             // T.D. 07.10.2009: Only call ccUpdateBytesAcked() when there are
             //                  acked bytes on this path!
+#ifdef PRIVATE
+           bool advanceWindow = myPath->newPseudoCumAck || myPath->newRTXPseudoCumAck;
+           if(state->allowCMT == true) {
+               if(state->cmtCUCVariant == SCTPStateVariables::CUCV_PseudoCumAckV2) {
+                   advanceWindow = myPath->newPseudoCumAck || myPath->newRTXPseudoCumAck;
+               }
+               else if(state->cmtCUCVariant == SCTPStateVariables::CUCV_PseudoCumAck) {
+                   advanceWindow = myPath->newPseudoCumAck;
+               }
+               else if(state->cmtCUCVariant == SCTPStateVariables::CUCV_Normal) {
+                   advanceWindow = myPath->newCumAck;
+               }
+           }
+#else
             const bool advanceWindow = myPath->newCumAck;
+#endif
 
             sctpEV3 << simTime() << ":\tCC " << myPath->newlyAckedBytes
                     << " newly acked on path " << myPathId << ";"
+#ifdef PRIVATE
+                    << "\tpath->newPseudoCumAck="    << ((myPath->newPseudoCumAck == true) ? "true" : "false")
+                    << "\tpath->newRTXPseudoCumAck=" << ((myPath->newRTXPseudoCumAck == true) ? "true" : "false")
+#endif
                     << "\tdropFilledGap=" << ((dropFilledGap == true) ? "true" : "false")
                     << "\t->\tadvanceWindow=" << advanceWindow << endl;
 
@@ -1342,24 +1554,79 @@ SCTPEventCode SCTPAssociation::processSackArrived(SCTPSackChunk* sackChunk)
     // #### Path Management                                               ####
     // #######################################################################
 
+#ifdef PRIVATE
+    if ((state->allowCMT == true) &&
+       (state->cmtSmartT3Reset == true) ) {
+        // ====== Find oldest unacked chunk on each path ======================
+        for(SCTPQueue::PayloadQueue::const_iterator iterator = retransmissionQ->payloadQueue.begin();
+           iterator != retransmissionQ->payloadQueue.end(); ++iterator) {
+             const SCTPDataVariables* myChunk         = iterator->second;
+             SCTPPathVariables*       myChunkLastPath = myChunk->getLastDestinationPath();
+             if(!chunkHasBeenAcked(myChunk)) {
+                if(myChunkLastPath->newOldestChunkSendTime > myChunk->sendTime) {
+                    sctpEV3 << "TSN " << myChunk->tsn << " is new oldest on path "
+                          << myChunkLastPath->remoteAddress << ", rel send time is "
+                          << simTime() - myChunk->sendTime << " ago" << endl;
+                    myChunkLastPath->newOldestChunkSendTime = myChunk->sendTime;
+                    myChunkLastPath->oldestChunkTSN         = myChunk->tsn;
+                }
+            }
+        }
+    }
+#endif
 
     // ====== Need to stop or restart T3 timer? ==============================
     for (SCTPPathMap::iterator piter = sctpPathMap.begin(); piter != sctpPathMap.end(); piter++) {
         SCTPPathVariables* myPath = piter->second;
         const IPvXAddress& myPathId = myPath->remoteAddress;
 
+#ifdef PRIVATE
+        // ====== Smart T3 Reset ===============================================
+        bool updatedOldestChunkSendTime = false;
+        if ((state->allowCMT == true) &&
+            (state->cmtSmartT3Reset == true) ) {
+            // ====== Has oldest chunk send time been updated? =================
+            if(myPath->newOldestChunkSendTime > simTime()) {
+                myPath->newOldestChunkSendTime = myPath->oldestChunkSendTime;
+                // newOldestChunkSendTime > simTime => no old chunk found:
+                // Set newOldestChunkSendTime to oldestChunkSendTime
+            }
+            else if(myPath->newOldestChunkSendTime != myPath->oldestChunkSendTime) {
+                // Update oldestChunkSendTime.
+                myPath->oldestChunkSendTime = myPath->newOldestChunkSendTime;
+                updatedOldestChunkSendTime  = true;
+            }
+            assert(myPath->oldestChunkSendTime <= simTime());
+        }
+#endif
 
         if (myPath->outstandingBytes == 0) {
             // T.D. 07.01.2010: Only stop T3 timer when there is nothing more to send on this path!
             if (qCounter.roomTransQ.find(myPath->remoteAddress)->second == 0) {
                 // Stop T3 timer, if there are no more outstanding bytes.
                 stopTimer(myPath->T3_RtxTimer);
+#ifdef PRIVATE
+                myPath->oldestChunkSendTime = SIMTIME_ZERO;
+#endif
             }
         }
+#ifdef PRIVATE
+        else if (myPath->newCumAck) {   // TD 10.12.09: Only care for CumAcks here!
+            // NOTE: Due to the existence of retransmissions *before* PseudoCumAck for CUCv2,
+            //       it is *not* possible to check PseudoCumAck here!
+            //       This would miss retransmissions -> chunks would never be retransmitted!
+#else
         else if (myPath->newCumAck) {
+#endif
             stopTimer(myPath->T3_RtxTimer);
             startTimer(myPath->T3_RtxTimer, myPath->pathRto);
         }
+#ifdef PRIVATE
+        else if(updatedOldestChunkSendTime) {   // T.D. 03.02.2010: Smart T3 Reset
+           stopTimer(myPath->T3_RtxTimer);
+           startTimer(myPath->T3_RtxTimer, myPath->pathRto);
+        }
+#endif
         else {
             /* Also restart T3 timer, when lowest TSN is rtx'ed */
             if (myPath->lowestTSNRetransmitted == true) {
@@ -1394,6 +1661,44 @@ void SCTPAssociation::handleChunkReportedAsAcked(uint32&            highestNewAc
         const bool         sackIsNonRevokable)
 {
     SCTPPathVariables* myChunkLastPath = myChunk->getLastDestinationPath();
+#ifdef PRIVATE
+    // T.D. 24.03.09: SFR algorithm
+    if(state->allowCMT == true) {
+        sctpEV3 << "TSN " << myChunk->tsn << " on path " << myChunkLastPath->remoteAddress << ":\t"
+                << "findPseudoCumAck="    << ((myChunkLastPath->findPseudoCumAck == true) ? "true" : "false")    << "\t"
+                << "pseudoCumAck="        << myChunkLastPath->pseudoCumAck    << "\t"
+                << "newPseudoCumAck="     << ((myChunkLastPath->newPseudoCumAck == true) ? "true" : "false")     << "\t"
+                << "findRTXPseudoCumAck=" << ((myChunkLastPath->findRTXPseudoCumAck == true) ? "true" : "false") << "\t"
+                << "rtxPseudoCumAck="     << myChunkLastPath->rtxPseudoCumAck << "\t"
+                << "newRTXPseudoCumAck="  << ((myChunkLastPath->newRTXPseudoCumAck == true) ? "true" : "false")  << "\t"
+                << endl;
+
+        // This chunk has not been acked before -> new ack on its myChunkLastPath.
+        if(myChunkLastPath->sawNewAck == false) {
+            sctpEV3 << "TSN " << myChunk->tsn << " on path " << myChunkLastPath->remoteAddress << ":\t"
+                    << "Saw new ack -> setting highestNewAckInSack!" << endl;
+            myChunkLastPath->sawNewAck           = true;
+        }
+
+        // T.D. 11.03.2010: Smart Fast RTX
+        // If chunk has already been transmitted on another path, do not consider it
+        // for fast RTX handling!
+        if( (!myChunk->hasBeenTimerBasedRtxed) ||
+            (state->cmtSmartFastRTX == false) ) {
+
+             if(myChunkLastPath->lowestNewAckInSack == 0) {
+                 myChunkLastPath->lowestNewAckInSack  = myChunk->tsn;   // The lowest TSN acked
+             }
+             if(myChunkLastPath->highestNewAckInSack == 0) {
+                 myChunkLastPath->highestNewAckInSack = myChunk->tsn;   // The highest TSN acked so far
+             }
+             else if(tsnLt(myChunkLastPath->highestNewAckInSack, myChunk->tsn)) {
+                 myChunkLastPath->highestNewAckInSack = myChunk->tsn;   // The highest TSN acked so far
+             }
+
+        }
+    }
+#endif
     if ( (myChunk->numberOfTransmissions == 1) &&
             (myChunk->hasBeenMoved == false) &&
             (myChunk->hasBeenReneged == false) ) {
@@ -1405,6 +1710,21 @@ void SCTPAssociation::handleChunkReportedAsAcked(uint32&            highestNewAc
             sctpEV3 << simTime() << " processSackArrived: computed rtt time diff == "
                     << timeDifference << " for TSN " << myChunk->tsn << endl;
         }
+#ifdef PRIVATE
+        else {
+            if( (state->allowCMT == true) &&
+                (state->cmtSlowPathRTTUpdate == true) &&
+                (myChunkLastPath->waitingForRTTCalculaton == false) ) {
+                // numberOfTransmissions==1, hasBeenReneged==false
+                // T.D. 25.02.2010: Slow Path Update
+                // Remember this chunk's TSN and send time in order to update the
+                // path's RTT using a stale SACK on its own path.
+                myChunkLastPath->tsnForRTTCalculation    = myChunk->tsn;
+                myChunkLastPath->txTimeForRTTCalculation = myChunk->sendTime;
+                myChunkLastPath->waitingForRTTCalculaton = true;
+            }
+        }
+#endif
     }
 
     if ( (myChunk->hasBeenAcked == false) &&
@@ -1453,7 +1773,97 @@ void SCTPAssociation::handleChunkReportedAsMissing(const SCTPSackChunk*     sack
     if (!chunkHasBeenAcked(myChunk)) {
         sctpEV3 << "has not been acked, highestNewAck=" << highestNewAck
                 << " countsAsOutstanding=" << myChunk->countsAsOutstanding << endl;
+#ifdef PRIVATE
+        // ===== Check whether a Fast Retransmission is necessary =============
+        // Non-CMT behaviour: check for highest TSN
+        uint32 chunkReportedAsMissing = (highestNewAck > myChunk->tsn) ? 1 : 0;
+
+        // T.D. 24.03.09: Split Fast Retransmission (SFR) algorithm for CMT
+        if((state->allowCMT == true) && (state->cmtUseSFR == true)) {
+           chunkReportedAsMissing = 0;   // Default: do not assume chunk as missing.
+
+           // If there has been another chunk with highest TSN acked on this path,
+           // the current one is missing.
+           if( (myChunkLastPath->sawNewAck) &&
+               (tsnGt(myChunkLastPath->highestNewAckInSack, myChunk->tsn)) ) {
+              if(state->cmtUseDAC == false) {
+                 chunkReportedAsMissing = 1;
+              }
+              else {
+                 // ------ DAC algorithm at sender side -----------
+                 // Is there a newly acked TSN on another path?
+                 bool sawNewAckOnlyOnThisPath = true;
+                 for(SCTPPathMap::iterator piter = sctpPathMap.begin(); piter != sctpPathMap.end(); piter++) {
+                    const SCTPPathVariables* otherPath = piter->second;
+                    if( (otherPath != myChunkLastPath) && (otherPath->sawNewAck) ) {
+                       sawNewAckOnlyOnThisPath = false;
+                       break;
+                    }
+                 }
+
+                 if(sawNewAckOnlyOnThisPath == true) {
+                    // All newly acked TSNs were sent on the same path
+                    sctpEV3 << "SplitFastRTX + DAC: all on same path:   "
+                            << "TSN="                  << myChunk->tsn
+                            << " lowestNewAckInSack="  << myChunkLastPath->lowestNewAckInSack
+                            << " highestNewAckInSack=" << myChunkLastPath->highestNewAckInSack
+                            << " (on path "            << myChunkLastPath->remoteAddress << ")" << endl;
+                    // Are there newly acked TSNs ta, tb, so that ta < myChunk->tsn < tb?
+                    // myChunkLastPath->highestNewAckInSack is highest newly acked TSN on the current path
+                    //   -> since all TSNs were on this path, this value can be used as tb
+                    // lowestNewAckInSack is the lowest newly acked TSN of this SACK
+                    //   -> since all TSNs were on the same path, this value can be used as ta
+                    if( tsnLt(myChunkLastPath->lowestNewAckInSack, myChunk->tsn) &&
+                        tsnLt(myChunk->tsn, myChunkLastPath->highestNewAckInSack) ) {
+                       sctpEV3 << "   => conservative increment of 1" << endl;
+                       chunkReportedAsMissing = 1;
+  /*
+                       printf("%s:\tlow=%d < %d < high=%d  -> missing=%d+1\n",
+                              myChunk->getLastDestination().str().c_str(),
+                              myChunkLastPath->lowestNewAckInSack,
+                              myChunk->tsn,
+                              myChunkLastPath->highestNewAckInSack,
+                              myChunk->gapReports);
+  */
+                    }
+                    else if(tsnGt(myChunkLastPath->lowestNewAckInSack, myChunk->tsn)) {   // All newly acked TSNs are larger than myChunk->tsn
+                       sctpEV3 << "   => reported increment of dacPacketsRcvd=" << (unsigned int)sackChunk->getDacPacketsRcvd() << endl;
+                       chunkReportedAsMissing = sackChunk->getDacPacketsRcvd();
+  /*
+                       printf("%s:\t%d < low=%d -> missing=%d+%d\n",
+                              myChunk->getLastDestination().str().c_str(),
+                              myChunk->tsn,
+                              myChunkLastPath->lowestNewAckInSack,
+                              myChunk->gapReports, chunkReportedAsMissing);
+  */
+                    }
+                    else {
+                       // sctpEV3 << "   => DAC - what to do here?!" << endl;
+                    }
+                 }
+                 else {
+                    // Mixed SACKS: newly acked TSNs were sent to multiple paths
+                    sctpEV3 << "SplitFastRTX + DAC: mixed acks, increment is 1" << endl;
+                    chunkReportedAsMissing = 1;
+  /*
+                    printf("%s:\t%d -> missing=%d+1\n",
+                           myChunk->getLastDestination().str().c_str(),
+                           myChunk->tsn, myChunk->gapReports);
+  */
+                 }
+              }
+           } // else: There is no need to increment the missing count.
+
+           sctpEV3 << "SplitFastRTX: chunkReportedAsMissing="
+                    << chunkReportedAsMissing << ", "
+                    << "sawNewAck="           << myChunkLastPath->sawNewAck           << ", "
+                    << "lowestNewAckInSack="  << myChunkLastPath->lowestNewAckInSack
+                    << "highestNewAckInSack=" << myChunkLastPath->highestNewAckInSack << ", "
+                    << "TSN="           << myChunk->tsn                               << endl;
+        }
+#else
         const uint32 chunkReportedAsMissing = (highestNewAck > myChunk->tsn) ? 1 : 0;
+#endif
         if (chunkReportedAsMissing > 0) {
             // T.D. 15.04.09: Increase gapReports by chunkReportedAsMissing.
             // Fixed bug here: gapReports += chunkReportedAsMissing instead of gapReports = chunkReportedAsMissing.
@@ -1475,8 +1885,15 @@ void SCTPAssociation::handleChunkReportedAsMissing(const SCTPSackChunk*     sack
                 switch (state->rtxMethod) {
                     case 0: // Only one Fast RTX after 3 Gap reports
                         fastRtx = ((myChunk->hasBeenFastRetransmitted == false) &&
-                                ((myChunk->numberOfRetransmissions == 0)
-                                ));
+                                   ((myChunk->numberOfRetransmissions == 0)
+#ifdef PRIVATE
+                                    ||
+                                     ((myChunk->hasBeenMoved) &&
+                                      (myChunk->countsAsOutstanding) &&
+                                      (state->movedChunkFastRTXFactor > 0) &&
+                                      ((simTime() - myChunk->sendTime) > state->movedChunkFastRTXFactor * myChunkLastPath->srtt))
+#endif
+                                  ));
                         break;
                     case 1: // Just 1 Fast RTX per RTT
                         fastRtx = ((myChunk->hasBeenFastRetransmitted == false) &&
@@ -1491,6 +1908,12 @@ void SCTPAssociation::handleChunkReportedAsMissing(const SCTPSackChunk*     sack
                         break;
                 }
                 if (fastRtx) {
+#ifdef PRIVATE
+                    if(myChunk->hasBeenMoved) {
+                        sctpEV3 << simTime() << ": MovedFastRTX for TSN " << myChunk->tsn << endl;
+                    }
+                    myChunk->hasBeenMoved = false;   // T.D. 18.02.2010: Just trigger *one* fast RTX ...
+#endif
 
                     // ====== Add chunk to transmission queue ========
                     if (transmissionQ->getChunk(myChunk->tsn) == NULL) {
@@ -1572,11 +1995,18 @@ void SCTPAssociation::nonRenegablyAckChunk(SCTPDataVariables* chunk,
     }
 
     if ( (chunk->hasBeenCountedAsNewlyAcked == false) &&
-            (chunk->hasBeenAcked == false) ) {
-        chunk->hasBeenCountedAsNewlyAcked = true;
-        // T.D. 13.07.2011: The chunk has not been acked before.
-        //                  Therefore, its size may *once* be counted as newly acked.
-        lastPath->newlyAckedBytes += chunk->booksize;
+         (chunk->hasBeenAcked == false) ) {
+#ifdef PRIVATE
+        if ((state->cmtMovedChunksReduceCwnd == false) ||
+            (chunk->hasBeenMoved == false)) {
+#endif
+            chunk->hasBeenCountedAsNewlyAcked = true;
+            // T.D. 13.07.2011: The chunk has not been acked before.
+            //                  Therefore, its size may *once* be counted as newly acked.
+            lastPath->newlyAckedBytes += chunk->booksize;
+#ifdef PRIVATE
+        }
+#endif
     }
 
     assert(chunk->queuedOnPath->queuedBytes >= chunk->booksize);
@@ -1594,6 +2024,22 @@ void SCTPAssociation::nonRenegablyAckChunk(SCTPDataVariables* chunk,
         assocStat->fairAckedBytes += chunk->len/8;
     }
 
+#ifdef PRIVATE
+    if( (state->allowCMT == true)                    &&
+        (state->cmtSlowPathRTTUpdate == true)        &&
+        (lastPath->waitingForRTTCalculaton == false) &&
+        (lastPath != sackPath)                       &&
+        (chunk->numberOfTransmissions == 1)          &&
+        (chunk->hasBeenMoved == false)               &&
+        (chunk->hasBeenReneged == false) ) {
+        // T.D. 25.02.2010: Slow Path Update
+        // Remember this chunk's TSN and send time in order to update the
+        // path's RTT using a stale SACK on its own path.
+        lastPath->tsnForRTTCalculation    = chunk->tsn;
+        lastPath->txTimeForRTTCalculation = chunk->sendTime;
+        lastPath->waitingForRTTCalculaton = true;
+    }
+#endif
 
     // ====== RTT calculation ================================================
     if ((chunkHasBeenAcked(chunk) == false) && (chunk->countsAsOutstanding)) {
@@ -1641,10 +2087,17 @@ void SCTPAssociation::renegablyAckChunk(SCTPDataVariables* chunk,
 
     if ( (chunk->hasBeenCountedAsNewlyAcked == false) &&
             (chunk->hasBeenAcked == false) ) {
-        chunk->hasBeenCountedAsNewlyAcked = true;
-        // T.D. 13.07.2011: The chunk has not been acked before.
-        //                  Therefore, its size may *once* be counted as newly acked.
-        chunk->getLastDestinationPath()->newlyAckedBytes += chunk->booksize;
+#ifdef PRIVATE
+        if ((state->cmtMovedChunksReduceCwnd == false) ||
+            (chunk->hasBeenMoved == false)) {
+#endif
+           chunk->hasBeenCountedAsNewlyAcked = true;
+           // T.D. 13.07.2011: The chunk has not been acked before.
+           //                  Therefore, its size may *once* be counted as newly acked.
+           chunk->getLastDestinationPath()->newlyAckedBytes += chunk->booksize;
+#ifdef PRIVATE
+        }
+#endif
     }
 
     // ====== Acknowledge chunk =============================================
@@ -1731,6 +2184,16 @@ void SCTPAssociation::dequeueAckedChunks(const uint32       tsna,
                 SCTPPathVariables* lastPath = chunk->getLastDestinationPath();
                 // T.D. 05.12.09: CumAck affects lastPath -> reset its T3 timer later.
                 lastPath->newCumAck = true;
+#ifdef PRIVATE
+                // T.D. 23.03.09: CumAck of SACK has acknowledged this chunk. Handle Pseudo CumAck.
+                lastPath->findPseudoCumAck    = true;
+                lastPath->newPseudoCumAck     = true;
+                // T.D. 22.11.09: CUCv2
+                lastPath->findRTXPseudoCumAck = true;
+                lastPath->newRTXPseudoCumAck  = true;
+
+                recordAcknowledgement(chunk, lastPath);
+#endif
             }
             recordDequeuing(chunk);
             nonRenegablyAckChunk(chunk, sackPath, rttEstimation, assocStat);
@@ -2843,11 +3306,22 @@ void SCTPAssociation::process_TIMEOUT_RTX(SCTPPathVariables* path)
         checkOutstandingBytes();
     }
 
+#ifdef PRIVATE
+    // T.D. 10.08.2011: Stop blocking!
+    if(path->BlockingTimer) {
+        stopTimer(path->BlockingTimer);
+    }
+    path->blockingTimeout = -1.0;
+#endif
 
     // ====== Increase the RTO (by doubling it) ==============================
     path->pathRto = min(2 * path->pathRto.dbl(), sctpMain->par("rtoMax"));
     path->statisticsPathRTO->record(path->pathRto);
     sctpEV3 << "T3 based retransmission for path " << path->remoteAddress
+#ifdef PRIVATE
+            << " oldest chhunk sent " << simTime() - path->oldestChunkSendTime << " ago"
+            << " (TSN " << path->oldestChunkTSN << ")"
+#endif
             << endl;
     if (SCTP::testing) {
         sctpEV3 << "Unacked chunks in Retransmission Queue:" << endl;
@@ -2859,6 +3333,9 @@ void SCTPAssociation::process_TIMEOUT_RTX(SCTPPathVariables* path)
                 sctpEV3 << " - " << myChunk->tsn
                         << "\tsent=now-" << simTime() - myChunk->sendTime
                         << "\tlast=" << myChunkLastPath->remoteAddress
+#ifdef PRIVATE
+                        << "\tmoved=" << ((myChunk->hasBeenMoved == true) ? "YES!" : "no")
+#endif
                         << "\tnumTX=" << myChunk->numberOfTransmissions
                         << "\tnumRTX=" << myChunk->numberOfRetransmissions
                         << "\tfastRTX=" << ((myChunk->hasBeenFastRetransmitted == true) ? "YES!" : "no")
@@ -2984,6 +3461,12 @@ void SCTPAssociation::process_TIMEOUT_RTX(SCTPPathVariables* path)
 
 void SCTPAssociation::process_TIMEOUT_BLOCKING(SCTPPathVariables* path)
 {
+#ifdef PRIVATE
+    std::cout << "TIMEOUT_BLOCKING on " << path->remoteAddress
+              << " cwnd=" << path->cwnd << endl;
+    path->blockingTimeout = -1.0;
+    sendOnAllPaths(path);
+#endif
 }
 
 
diff --git a/src/transport/sctp/SCTPAssociationSendAll.cc b/src/transport/sctp/SCTPAssociationSendAll.cc
index 113f89c..fdae2de 100644
--- a/src/transport/sctp/SCTPAssociationSendAll.cc
+++ b/src/transport/sctp/SCTPAssociationSendAll.cc
@@ -182,6 +182,14 @@ void SCTPAssociation::dumpPaths(std::ostream& os) const
                 << "\trto=" << path->pathRto
                 << "\tFR=" << ((path->fastRecoveryActive == true) ? "YES!" : "no")
                 << "\tFRexit=" << path->fastRecoveryExitPoint
+#ifdef PRIVATE
+                << "\tpseudoCumAck="        << path->pseudoCumAck
+                << "\tfindPseudoCumAck="    << (path->newPseudoCumAck ? "true" : "false")
+                << "\tfindRTXPseudoCumAck=" << (path->newRTXPseudoCumAck ? "true" : "false")
+                << "\tnewPseudoCumAck="     << (path->newPseudoCumAck ? "YES!" : "no")
+                << "\trtxPseudoCumAck="     << path->rtxPseudoCumAck
+                << "\tnewRTXPseudoCumAck="  << (path->newRTXPseudoCumAck ? "YES!" : "no")
+#endif
                 ;
         const uint32 room = qCounter.roomTransQ.find(path->remoteAddress)->second;
         const uint32 booked = qCounter.bookedTransQ.find(path->remoteAddress)->second;
@@ -193,9 +201,72 @@ void SCTPAssociation::dumpPaths(std::ostream& os) const
 }
 
 
+#ifdef PRIVATE
+std::vector<SCTPPathVariables*> SCTPAssociation::getSortedPathMap()
+{
+   std::vector<SCTPPathVariables*> sortedPaths;
+   for (SCTPPathMap::iterator iterator = sctpPathMap.begin(); iterator != sctpPathMap.end(); ++iterator) {
+      SCTPPathVariables* path = iterator->second;
+      sortedPaths.insert(sortedPaths.end(), path);
+   }
+   if(state->cmtSendAllComparisonFunction != NULL) {
+      std::sort(sortedPaths.begin(), sortedPaths.end(), state->cmtSendAllComparisonFunction);
+   }
+
+   sctpEV3 << "SORTED PATH MAP:" << endl;
+   for (std::vector<SCTPPathVariables*>::iterator iterator = sortedPaths.begin(); iterator != sortedPaths.end(); ++iterator) {
+      SCTPPathVariables* path = *iterator;
+      sctpEV3 << " - "             << path->remoteAddress
+              << "  cwnd="          << path->cwnd
+              << "  ssthresh="    << path->ssthresh
+              << "  outstanding=" << path->outstandingBytes
+              << "  bytesToRetransmit=" << state->bytesToRetransmit << endl;
+   }
+   return(sortedPaths);
+}
+
+
+bool SCTPAssociation::pathMapRandomized(const SCTPPathVariables* left, const SCTPPathVariables* right)
+{
+   return(left->sendAllRandomizer < right->sendAllRandomizer);
+}
+
+
+bool SCTPAssociation::pathMapSmallestLastTransmission(const SCTPPathVariables* left, const SCTPPathVariables* right)
+{
+   return(left->lastTransmission < right->lastTransmission);
+}
+
+
+bool SCTPAssociation::pathMapLargestSSThreshold(const SCTPPathVariables* left, const SCTPPathVariables* right)
+{
+   return(left->ssthresh > right->ssthresh);
+}
+
+
+bool SCTPAssociation::pathMapLargestSpace(const SCTPPathVariables* left, const SCTPPathVariables* right)
+{
+   const int l = (left->cwnd   - left->outstandingBytes);
+   const int r = (right->cwnd - right->outstandingBytes);
+   return(l > r);
+}
+
+
+bool SCTPAssociation::pathMapLargestSpaceAndSSThreshold(const SCTPPathVariables* left, const SCTPPathVariables* right)
+{
+   if(left->ssthresh != right->ssthresh) {
+      return(left->ssthresh > right->ssthresh);
+   }
+
+   const int l = (left->cwnd   - left->outstandingBytes);
+   const int r = (right->cwnd - right->outstandingBytes);
+   return(l > r);
+}
+#endif
+
 
 SCTPDataVariables* SCTPAssociation::makeDataVarFromDataMsg(SCTPDataMsg*       datMsg,
-        SCTPPathVariables* path)
+                                                           SCTPPathVariables* path)
 {
     SCTPDataVariables* datVar = new SCTPDataVariables();
 
@@ -270,8 +341,16 @@ SCTPPathVariables* SCTPAssociation::choosePathForRetransmission()
 void SCTPAssociation::timeForSack(bool& sackOnly, bool& sackWithData)
 {
     sackOnly = sackWithData = false;
+#ifdef PRIVATE
+   // T.D. 25.03.09: CMT DAC implementation at the receiver side
+   // If CMT DAC is used, a SACK is *not* immediately transferred upon reordering
+   if ( ((state->gapList.getNumGaps(GapList::GT_Any) > 0) || (state->dupList.size() > 0)) &&
+         (state->sackAllowed) &&
+         (!((state->allowCMT == true) && (state->cmtUseDAC == true))) ) {
+#else
     if ( ((state->gapList.getNumGaps(GapList::GT_Any) > 0) || (state->dupList.size() > 0)) &&
             (state->sackAllowed) ) {
+#endif
         // Schedule sending of SACKs at once, when we have fragments to report
         state->ackState = sackFrequency;
         sackOnly = sackWithData = true;   // SACK necessary, regardless of data available
@@ -288,31 +367,330 @@ void SCTPAssociation::timeForSack(bool& sackOnly, bool& sackWithData)
 
 void SCTPAssociation::sendOnAllPaths(SCTPPathVariables* firstPath)
 {
-    // ------ Send on provided path first ... -----------------------------
-    if (firstPath != NULL) {
-        sendOnPath(firstPath);
-    }
+#ifdef PRIVATE
+    if(state->allowCMT) {
+        // ------ Send on provided path first ... -----------------------------
+        if(firstPath != NULL) {
+            sendOnPath(firstPath);
+        }
 
-    // ------ ... then, try sending on all other paths --------------------
-    for (SCTPPathMap::iterator iterator = sctpPathMap.begin(); iterator != sctpPathMap.end(); ++iterator) {
-        SCTPPathVariables* path = iterator->second;
-        if (path != firstPath) {
-            sendOnPath(path);
+        // ------ ... then, try sending on all other paths --------------------
+        std::vector<SCTPPathVariables*> sortedPaths = getSortedPathMap();
+        for (std::vector<SCTPPathVariables*>::iterator iterator = sortedPaths.begin(); iterator != sortedPaths.end(); ++iterator) {
+            SCTPPathVariables* path = *iterator;
+            sctpEV3 << path->remoteAddress << " [" << path->lastTransmission << "]\t";
+        }
+        sctpEV3 <<endl;
+
+
+        for (std::vector<SCTPPathVariables*>::iterator iterator = sortedPaths.begin();
+             iterator != sortedPaths.end(); ++iterator) {
+            SCTPPathVariables* path = *iterator;
+            if(path != firstPath) {
+               /*
+               sctpEV3 << " - "       << path->remoteAddress
+                     << " lastTx="      << path->lastTransmission
+                     << " rnd="         << path->sendAllRandomizer
+                     << " cwnd="        << path->cwnd
+                     << " ssthresh="    << path->ssthresh
+                     << " outstanding=" << path->outstandingBytes
+                     << endl;
+               */
+               sendOnPath(path);
+               path->sendAllRandomizer = uniform(0, (1 << 31));
+            }
+        }
+        if( (state->strictCwndBooking) &&
+            (sctpPathMap.size() > 1) ) {   // T.D. 08.02.2010: strict behaviour only for more than 1 paths!
+           // T.D. 14.01.2010: Second pass for "Strict Cwnd Booking" option.
+           for (std::vector<SCTPPathVariables*>::iterator iterator = sortedPaths.begin();
+                iterator != sortedPaths.end(); ++iterator) {
+               SCTPPathVariables* path = *iterator;
+               /*
+               sctpEV3 << " - "       << path->remoteAddress
+                     << " lastTx="      << path->lastTransmission
+                     << " rnd="         << path->sendAllRandomizer
+                     << " cwnd="        << path->cwnd
+                     << " ssthresh="    << path->ssthresh
+                     << " outstanding=" << path->outstandingBytes
+                     << endl;
+               */
+               sendOnPath(path, false);
+            }
         }
     }
+    else {
+#endif
+        // ------ Send on provided path first ... -----------------------------
+        if (firstPath != NULL) {
+            sendOnPath(firstPath);
+        }
 
+        // ------ ... then, try sending on all other paths --------------------
+        for (SCTPPathMap::iterator iterator = sctpPathMap.begin(); iterator != sctpPathMap.end(); ++iterator) {
+            SCTPPathVariables* path = iterator->second;
+            if (path != firstPath) {
+                sendOnPath(path);
+            }
+        }
+
+#ifdef PRIVATE
+       if(state->strictCwndBooking) {
+           // T.D. 14.01.2010: Second pass for "Strict Cwnd Booking" option.
+           sendOnPath(firstPath, false);
+
+           // ------ Then, try sending on all other paths ---------------------------
+           for (SCTPPathMap::iterator iterator = sctpPathMap.begin(); iterator != sctpPathMap.end(); ++iterator) {
+               SCTPPathVariables* path = iterator->second;
+               if(path != firstPath) {
+                  sendOnPath(path, false);
+               }
+           }
+       }
+   }
+#endif
 }
 
 
+#ifdef PRIVATE
+void SCTPAssociation::chunkReschedulingControl(SCTPPathVariables* path)
+{
+   sctpEV3 << simTime() << ": chunkReschedulingControl:"
+           << "\tqueueFillLevel=" << (100.0 * (double)state->queuedSentBytes) / (double)state->sendQueueLimit << "%"
+           << "\tpeerRwnd="       << state->peerRwnd
+           << endl;
+
+   double       totalBandwidth        = 0.0;
+   unsigned int totalOutstandingBytes = 0;
+   unsigned int totalQueuedBytes      = 0;
+   for (SCTPPathMap::iterator iterator = sctpPathMap.begin(); iterator != sctpPathMap.end(); ++iterator) {
+      const SCTPPathVariables* myPath = iterator->second;
+      totalQueuedBytes      += myPath->queuedBytes;
+      totalOutstandingBytes += myPath->outstandingBytes;
+      totalBandwidth        += (double)myPath->cwnd / myPath->srtt.dbl();
+   }
+   assert(totalOutstandingBytes == state->outstandingBytes);
+
+   const unsigned int queuedBytes      = path->queuedBytes;
+   const unsigned int outstandingBytes = path->outstandingBytes;
+
+   /* senderLimit is just the size of the send queue! */
+   uint32 senderLimit = ((state->sendQueueLimit != 0) ? state->sendQueueLimit : 0xffffffff);
+   if( (state->cmtBufferSplitVariant == SCTPStateVariables::CBSV_BothSides)    ||
+       (state->cmtBufferSplitVariant == SCTPStateVariables::CBSV_SenderOnly)   ||
+       (state->cmtBufferSplitVariant == SCTPStateVariables::CBSV_ReceiverOnly) ) {
+      senderLimit = senderLimit / sctpPathMap.size();
+   }
+
+   /* receiverLimit is the peerRwnd + all bytes queued
+      (i.e. waiting or being outstanding)! */
+   uint32 receiverLimit = state->peerRwnd + totalQueuedBytes;
+   if( (state->cmtBufferSplitVariant == SCTPStateVariables::CBSV_BothSides)    ||
+       (state->cmtBufferSplitVariant == SCTPStateVariables::CBSV_SenderOnly)   ||
+       (state->cmtBufferSplitVariant == SCTPStateVariables::CBSV_ReceiverOnly) ) {
+      receiverLimit = receiverLimit / sctpPathMap.size();
+   }
+
+   const double senderBlockingFraction   = (queuedBytes - outstandingBytes) / (double)senderLimit;
+   const double receiverBlockingFraction = (queuedBytes - outstandingBytes) / (double)receiverLimit;
+
+
+   sctpEV3 << " - "          << path->remoteAddress
+           << "\tt3="        << (path->T3_RtxTimer->isScheduled() ? path->T3_RtxTimer->getArrivalTime().dbl() : -1.0)
+           << "\tssthresh="  << path->ssthresh
+           << "\tcwnd="      << path->cwnd
+           << "\tsrtt="      << path->srtt
+           << "\tbw="        << (8.0 * (double)path->cwnd) / (1000000.0 * path->srtt) << " Mbit/s"
+           << "\tosb="       << path->outstandingBytes
+           << "\tqueued="    << path->queuedBytes
+           << "\tslimit="    << senderLimit
+           << "\trlimit="    << receiverLimit
+           << "\tsblocking=" << 100.0 * senderBlockingFraction << " %"
+           << "\trblocking=" << 100.0 * receiverBlockingFraction << " %"
+           << endl;
+
+   path->statisticsPathSenderBlockingFraction->record(senderBlockingFraction);
+   path->statisticsPathReceiverBlockingFraction->record(receiverBlockingFraction);
+
+   // ====== Chunk Rescheduling =============================================
+   if( (state->cmtChunkReschedulingVariant == SCTPStateVariables::CCRV_SenderOnly) ||
+       (state->cmtChunkReschedulingVariant == SCTPStateVariables::CCRV_ReceiverOnly) ||
+       (state->cmtChunkReschedulingVariant == SCTPStateVariables::CCRV_BothSides) ) {
+
+      if( (((state->cmtChunkReschedulingVariant == SCTPStateVariables::CCRV_SenderOnly) ||
+            (state->cmtChunkReschedulingVariant == SCTPStateVariables::CCRV_BothSides)) &&
+           (senderBlockingFraction >= state->cmtChunkReschedulingThreshold)) ||
+          (((state->cmtChunkReschedulingVariant == SCTPStateVariables::CCRV_ReceiverOnly) ||
+            (state->cmtChunkReschedulingVariant == SCTPStateVariables::CCRV_BothSides)) &&
+           (receiverBlockingFraction >= state->cmtChunkReschedulingThreshold)) ) {
+
+#if 0
+         std::cout << simTime() << ":\txxx $$$ QueueFull bp=" << path->remoteAddress
+         << " s="<<senderBlockingFraction<< " r=" << receiverBlockingFraction
+         << "\tpeerR=" << state->peerRwnd
+         << "\tosb=" << state->outstandingBytes
+         << "\trLim=" << receiverLimit
+         << "\tpathQB=" << queuedBytes
+         << "\tpathOSB=" << outstandingBytes
+         << "\tpathWaitingBytes=" <<  queuedBytes - outstandingBytes
+         << "\tblocked=" <<  (!((path->blockingTimeout < 0.0) || (simTime() >= path->blockingTimeout)))
+         << "\tblockedUtil=" << path->blockingTimeout
+         << "\tfastRecovery=" <<  (path->fastRecoveryActive)
+         << endl;
+         if(receiverBlockingFraction > 10.0) {
+            dumpQueue(std::cout);
+            std::cout << "----$$$----\n";
+         }
+#endif
+
+         if( (!path->fastRecoveryActive) &&      // T.D. 03.08.2011: Only apply when path is not yet in Fast Recovery!
+             ( (path->blockingTimeout < 0.0) ||  // T.D. 08.07.2011: Do not move chunks to an already-blocked path!
+               (simTime() >= path->blockingTimeout) ) ) {
+
+            // ====== Rescheduling of chunk from other path to current path ====
+            SCTPQueue::PayloadQueue::iterator iterator = retransmissionQ->payloadQueue.begin();
+            if(iterator != retransmissionQ->payloadQueue.end()) {
+               SCTPDataVariables* chunk    = iterator->second;
+               SCTPPathVariables* lastPath = chunk->getLastDestinationPath();
+
+               if( (chunk->countsAsOutstanding == true) &&   // T.D. 04.08.2011: Chunk must be outstanding, i.e. in the network!
+                   (chunk->hasBeenMoved == false) &&         // T.D. 08.07.2011: Check, whether this chunk has already been moved!
+                   ( (lastPath != path) ||
+                     (chunk->sendTime + (2 * path->srtt) < simTime()) ) ) {
+
+                  assert(chunk->numberOfTransmissions > 0);   // It has been transmitted as least once
+                  assert(chunk->hasBeenAcked == false);       // It has not been acked (since it is outstanding)
+
+                  sctpEV3 << simTime() << ": RESCHEDULING TSN " << chunk->tsn << " on "
+                          << lastPath->remoteAddress << " to "
+                          << path->remoteAddress << endl;
+
+                  // ====== Move chunk ======================================
+                  lastPath->vectorPathBlockingTSNsMoved->record(chunk->tsn);
+                  moveChunkToOtherPath(chunk, path);
+
+                  // This chunk is important, since it is blocking others ...
+                  // If SackNow is supported, ensure that it is SACK'ed quickly!
+                  chunk->ibit = sctpMain->sackNow;
+
+                  state->blockingTSNsMoved++;
+                  chunk->hasBeenMoved = (lastPath != path);
+
+                  // Restart T3 timer on its old path, if it is scheduled
+                  if(lastPath->T3_RtxTimer->isScheduled()) {
+                     // T.D. 08.07.2011: Stop timer, if path is empty now.
+                     // Else, keep it running, without reset!
+                     if(lastPath->queuedBytes == 0) {
+                        stopTimer(lastPath->T3_RtxTimer);
+                     }
+                  }
+
+                  // ====== Handle Congestion Control =======================
+                  if(state->cmtMovedChunksReduceCwnd == true) {
+                     if(lastPath != path) {
+                        if( (lastPath->blockingTimeout >= 0.0) &&
+                            (simTime() < lastPath->blockingTimeout) ) {
+                           // Path is already blocked
+                           sctpEV3 << simTime() << "\tCR-3 on path "
+                                   << lastPath->remoteAddress << " (blocked until "
+                                   << lastPath->blockingTimeout << ")" << endl;
+                        }
+                        else if(lastPath->fastRecoveryActive) {
+                           // A further problem during Fast Recovery -> block path
+                           const simtime_t pause = lastPath->srtt;
+                           lastPath->blockingTimeout = simTime() + pause;
+                           assert(!lastPath->BlockingTimer->isScheduled());
+                           startTimer(lastPath->BlockingTimer, pause);
+                           sctpEV3 << simTime() << "\tCR-2 on path "
+                                   << lastPath->remoteAddress << " (pause="
+                                   << pause << "; blocked until "
+                                   << lastPath->blockingTimeout << ")" << endl;
+                        }
+                        else {
+                           // Go into Fast Recovery mode ...
+                           lastPath->requiresRtx = true;
+                           (this->*ccFunctions.ccUpdateBeforeSack)();
+                           (this->*ccFunctions.ccUpdateAfterSack)();
+                           lastPath->requiresRtx = false;
+                           sctpEV3 << simTime() << "\tCR-1 on path "
+                                   << lastPath->remoteAddress << endl;
+                        }
+                     }
+                     else {
+                        sctpEV3 << simTime() << "\tCR-4 on path "
+                                << path->remoteAddress << " (lastTX="
+                                << simTime() - chunk->sendTime
+                                << ", TSN " << chunk->tsn << ")" << endl;
+
+                        lastPath->requiresRtx = true;
+                        (this->*ccFunctions.ccUpdateBeforeSack)();
+                        (this->*ccFunctions.ccUpdateAfterSack)();
+                        lastPath->requiresRtx = false;
+                     }
+                  }
+               }
+            }
+         }
+      }
+   }
+
+   // ====== Test ===========================================================
+   else if(state->cmtChunkReschedulingVariant == SCTPStateVariables::CCRV_Test) {
+      abort();
+   }
+
+}
+#endif
 
 
 void SCTPAssociation::sendSACKviaSelectedPath(SCTPMessage* sctpMsg)
 {
     SCTPPathVariables* sackPath =
             (state->lastDataSourceList.size() > 0) ? state->lastDataSourceList.front() :
-                    state->lastDataSourcePath;
+                                                     state->lastDataSourcePath;
     assert(sackPath != NULL);
 
+#ifdef PRIVATE
+    if(state->allowCMT) {
+        if(state->cmtSackPath == SCTPStateVariables::CSP_RoundRobin) {
+            /* T.D. 23.06.2010 - Observation:
+               For same bandwidths but different delays, chunks on both paths arrive
+               with same interleave time =>
+               Chunk on A / Chunk on B => SACK on B
+               Chunk on A / Chunk on B => SACK on B
+               Chunk on A / Chunk on B => SACK on B
+               Chunk on A / Chunk on B => SACK on B
+               Chunk on A / Chunk on B => SACK on B
+               ...
+               RESULT: Losts of SACKs on B, no SACK on A  =>  Bad performance! */
+
+            // T.D. 10.07.2011: Solution is now to make a round-robin selection among paths,
+            //                  taking the path with the longest time passed since last SACK.
+            for(std::list<SCTPPathVariables*>::iterator iterator = state->lastDataSourceList.begin();
+               iterator != state->lastDataSourceList.end(); iterator++) {
+               SCTPPathVariables* path = *iterator;
+                if(path->lastSACKSent < sackPath->lastSACKSent) {
+                    sackPath = path;
+                }
+            }
+        }
+        else if(state->cmtSackPath == SCTPStateVariables::CSP_SmallestSRTT) {
+            /* T.D. 15.07.2011:
+               Instead of RR among last DATA paths, send SACK on
+               the DATA path having the smallest SRTT. */
+            for(std::list<SCTPPathVariables*>::iterator iterator = state->lastDataSourceList.begin();
+               iterator != state->lastDataSourceList.end(); iterator++) {
+               SCTPPathVariables* path = *iterator;
+                if(path->srtt < sackPath->srtt) {
+                    sackPath = path;
+                }
+            }
+        }
+        else if(state->cmtSackPath == SCTPStateVariables::CSP_Primary) {
+           sackPath = state->getPrimaryPath();
+        }
+    }
+#endif
 
     sctpEV3 << assocId << ": sending SACK to " << sackPath->remoteAddress << endl;
     sendToIP(sctpMsg, sackPath->remoteAddress);
@@ -386,6 +764,12 @@ void SCTPAssociation::bytesAllowedToSend(SCTPPathVariables* path,
 
             // ====== Get cwnd value to use, according to maxBurstVariant ======
             uint32 myCwnd = path->cwnd;
+#ifdef PRIVATE
+            if( (state->maxBurstVariant == SCTPStateVariables::MBV_UseItOrLoseItTempCwnd) ||
+                (state->maxBurstVariant == SCTPStateVariables::MBV_CongestionWindowLimitingTempCwnd) ) {
+                myCwnd = path->tempCwnd;
+            }
+#endif
 
             // ====== Obtain byte allowance ====================================
             if ( ( ((state->peerAllowsChunks) &&
@@ -396,6 +780,11 @@ void SCTPAssociation::bytesAllowedToSend(SCTPPathVariables* path,
                     ((!state->peerAllowsChunks) &&
                             (path->outstandingBytes < myCwnd) &&
                             (!state->peerWindowFull)) )
+#ifdef PRIVATE
+                 &&
+                 ( (path->blockingTimeout < 0.0) ||   /* T.D. 08.07.2011: Chunk Rescheduling: no new transmission when blocking is active! */
+                    (simTime() >= path->blockingTimeout) )
+#endif
             ) {
                 sctpEV3 << "bytesAllowedToSend(" << path->remoteAddress << "):"
                         << " bookedSumSendStreams=" << qCounter.bookedSumSendStreams
@@ -420,6 +809,9 @@ void SCTPAssociation::bytesAllowedToSend(SCTPPathVariables* path,
     sctpEV3 << "bytesAllowedToSend(" << path->remoteAddress << "):"
             << " osb=" << path->outstandingBytes
             << " cwnd=" << path->cwnd
+#ifdef PRIVATE
+            << " tempCwnd=" << path->tempCwnd
+#endif
             << " bytes.packet=" << (bytes.packet ? "YES!" : "no")
             << " bytes.chunk=" << (bytes.chunk  ? "YES!" : "no")
             << " bytes.bytesToSend=" << bytes.bytesToSend << endl;
@@ -454,6 +846,13 @@ void SCTPAssociation::sendOnPath(SCTPPathVariables* pathId, bool firstPass)
     bool sackAdded = false;
     bool forwardPresent = false;
 
+#ifdef PRIVATE
+   // ====== Perform Chunk Rescheduling =====================================
+   if( (state->allowCMT) &&
+       (state->cmtChunkReschedulingVariant != SCTPStateVariables::CCRV_None) ) {
+      chunkReschedulingControl((pathId == NULL) ? state->getPrimaryPath() : pathId);
+   }
+#endif
 
     // ====== Obtain path ====================================================
     sctpEV3 << endl << "##### sendAll(";
@@ -478,6 +877,31 @@ void SCTPAssociation::sendOnPath(SCTPPathVariables* pathId, bool firstPass)
             }
         }
 
+#ifdef PRIVATE
+       if( (state->maxBurstVariant == SCTPStateVariables::MBV_MaxBurst) ||
+           (state->maxBurstVariant == SCTPStateVariables::MBV_AggressiveMaxBurst) ) {
+           if(state->lastTransmission < simTime()) {
+              state->packetsInTotalBurst = 0;
+           }
+           if(path->lastTransmission < simTime()) {
+              // T.D. 18.07.2011: Only reset packetsInBurst once per time-stamp!
+              path->packetsInBurst = 0;
+           }
+       }
+       // T.D. 18.07.2011: packetsInBurst must be checked here!
+       // sendOnPath() may be called multiple times at the same simTime!
+       if( ((state->maxBurstVariant == SCTPStateVariables::MBV_MaxBurst) ||
+            (state->maxBurstVariant == SCTPStateVariables::MBV_AggressiveMaxBurst) ||
+            (state->maxBurstVariant == SCTPStateVariables::MBV_TotalMaxBurst)) &&
+            (path->packetsInBurst >=  state->maxBurst) ) {
+           break;
+       }
+       // T.D. 15.08.2011: TotalMaxBurst variant: limit bursts on all paths.
+       if( (state->maxBurstVariant == SCTPStateVariables::MBV_TotalMaxBurst) &&
+           (state->packetsInTotalBurst >= state->maxBurst) ) {
+           break;
+       }
+#endif
 
         outstandingBytes = path->outstandingBytes;
         assert((int32)outstandingBytes >= 0);
@@ -500,7 +924,11 @@ void SCTPAssociation::sendOnPath(SCTPPathVariables* pathId, bool firstPass)
         bool sackWithData;
         timeForSack(sackOnly, sackWithData);
 
-        if ((tcount == 0 && scount == 0)) {
+        if ((tcount == 0 && scount == 0)
+#ifdef PRIVATE
+            || (!state->allowCMT && tcount == 0 && Tcount > 0)
+#endif
+           ) {
             // ====== No DATA chunks to send or retransmissions due on another path ======
             sctpEV3 << "No DATA chunk available!" << endl;
             if (!sackOnly) {   // SACK?, no data to send
@@ -535,6 +963,14 @@ void SCTPAssociation::sendOnPath(SCTPPathVariables* pathId, bool firstPass)
             // SACK can be sent
             assert(headerCreated==true);
             sackChunk = createSack();
+#ifdef PRIVATE
+            // T.D. 25.03.09: CMT DAC
+            if( (state->allowCMT == true) && (state->cmtUseDAC == true) ) {
+                sctpEV3 << "Adding dacPacketsRcvd=" << (unsigned int)dacPacketsRcvd << " to SACK" << endl;
+                sackChunk->setDacPacketsRcvd(dacPacketsRcvd);
+            }
+            dacPacketsRcvd = 0;
+#endif
             chunksAdded++;
             totalChunksSent++;
             // ------ Create AUTH chunk, if necessary --------------------------
@@ -547,6 +983,10 @@ void SCTPAssociation::sendOnPath(SCTPPathVariables* pathId, bool firstPass)
             if (sackOnly && !(bytesToSend > 0 || bytes.chunk || bytes.packet))
             {
                 // There is no data to be sent, just the SACK
+#ifdef PRIVATE
+                path->lastTransmission = simTime();
+                path->packetsInBurst++;
+#endif
                 state->lastTransmission = simTime();
                 state->packetsInTotalBurst++;
                 if (dataChunksAdded > 0) {
@@ -602,14 +1042,77 @@ void SCTPAssociation::sendOnPath(SCTPPathVariables* pathId, bool firstPass)
 
             // ====== How many bytes may be transmitted in next packet? ========
             int32 allowance = path->pmtu;   // Default behaviour: send 1 path MTU
-            if ((bytesToSend > 0) || (bytes.chunk) || (bytes.packet)) {
-                // Allow 1 more MTU
+#ifdef PRIVATE
+            // T.D. 05.01.2010: Restrict amount of data to send to cwnd size.
+            if( (state->strictCwndBooking) &&
+                (sctpPathMap.size() > 1) ) {   // T.D. 07.02.2010: strict behaviour only for more than 1 paths!
+                 // T.D. 19.01.2010: bytesToSend may be less than 1 MTU on this path.
+                 // Allow overbooking in second pass, if *total* cwnd allows it.
+                 if(!firstPass) {
+                     // No "one packet"/"one chunk" in second pass!
+                     bytes.packet = false;
+                     bytes.chunk  = false;
+                 }
+
+                 if(bytes.chunk) {
+                     // Send 1 chunk: allow one path MTU.
+                 }
+                 else if(bytes.packet) {
+                     // Send 1 chunk: allow one path MTU.
+                 }
+                 else if( (path->outstandingBytes == 0) && (firstPass) ) {
+                     // No outstanding data and first pass: allow one path MTU.
+                 }
+                 else {   // There *may* be something more to send ...
+                     if((int32)path->cwnd - (int32)path->outstandingBytes >= (int32)path->pmtu) {
+                         // Enough space -> allow one path MTU
+                     }
+                     else {
+                         if(firstPass) {
+                             // In first pass, disallow overbooking.
+                             allowance   = 0;
+                             bytesToSend = 0;
+                         }
+                         else {
+                             if(!state->allowCMT) {
+                                 // For non-CMT in second pass, allow 1 more MTU.
+                             }
+                             else {
+                                // Not CMT in second pass, check total space ...
+                                int32 totalOutstanding = 0;
+                                int32 totalCwnd        = 0;
+                                for (SCTPPathMap::const_iterator pathMapIterator = sctpPathMap.begin();
+                                     pathMapIterator != sctpPathMap.end(); pathMapIterator++) {
+                                    const SCTPPathVariables* myPath = pathMapIterator->second;
+                                    totalOutstanding += myPath->outstandingBytes;
+                                    totalCwnd        += myPath->cwnd;
+                                }
+                                if((int32)(totalCwnd - totalOutstanding) < (int32)(path->pmtu)) {
+                                    // ... and disallow overbooking if there is no more space for 1 MTU
+                                    allowance   = 0;
+                                    bytesToSend = 0;
+                                 }
+                                else {
+                                    // ... and allow 1 MTU if there is still space
+                                }
+                            }
+                        }
+                    }
+                }
             }
             else {
-                // No more sending allowed.
-                allowance = 0;
-                bytesToSend = 0;
+#endif
+                if ((bytesToSend > 0) || (bytes.chunk) || (bytes.packet)) {
+                    // Allow 1 more MTU
+                }
+                else {
+                    // No more sending allowed.
+                    allowance = 0;
+                    bytesToSend = 0;
+                }
+#ifdef PRIVATE
             }
+#endif
 
             if ((allowance > 0) || (bytes.chunk) || (bytes.packet)) {
                 bool firstTime = false;   // Is DATA chunk send for the first time?
@@ -635,6 +1138,10 @@ void SCTPAssociation::sendOnPath(SCTPPathVariables* pathId, bool firstPass)
                                 sackAdded = false;
                             }
                             else {
+#ifdef PRIVATE
+                                path->lastTransmission = simTime();
+                                path->packetsInBurst++;
+#endif
                                 state->lastTransmission = simTime();
                                 state->packetsInTotalBurst++;
                                 if (dataChunksAdded > 0) {
@@ -686,11 +1193,29 @@ void SCTPAssociation::sendOnPath(SCTPPathVariables* pathId, bool firstPass)
                                     << " (last was " << datVar->getLastDestination() << ")" << endl;
 #ifdef SNDMESSAGE_DEBUG
                             std::cout << simTime() << ":\t"
-                                    << "Sending TSN " << datVar->tsn << " (RETRANSMISSION) on "
-                                    << datVar->getNextDestinationPath()->remoteAddress
-                                    << endl;
+                                      << "Sending TSN " << datVar->tsn << " (RETRANSMISSION) on "
+                                      << datVar->getNextDestinationPath()->remoteAddress
+#ifdef PRIVATE
+                                      << ", packetsInBurst="
+                                      << datVar->getNextDestinationPath()->packetsInBurst
+#endif
+                                      << endl;
 #endif
 
+#ifdef PRIVATE
+                            // TD 04.12.09: The chunk is going to be retransmitted on another path.
+                            //              On the original path, it is necessary to find another
+                            //              PseudoCumAck!
+                            if(datVar->getLastDestinationPath() != datVar->getNextDestinationPath()) {
+                               SCTPPathVariables* oldPath = datVar->getLastDestinationPath();
+                               oldPath->findPseudoCumAck    = true;
+                               oldPath->findRTXPseudoCumAck = true;
+                               SCTPPathVariables* newPath = datVar->getNextDestinationPath();
+                               newPath->findPseudoCumAck    = true;
+                               newPath->findRTXPseudoCumAck = true;
+                            }
+                            datVar->wasDropped          = false;
+#endif
                             datVar->countsAsOutstanding = true;
                             datVar->hasBeenReneged = false;
                             increaseOutstandingBytes(datVar, path);   // NOTE: path == datVar->getNextDestinationPath()
@@ -701,7 +1226,51 @@ void SCTPAssociation::sendOnPath(SCTPPathVariables* pathId, bool firstPass)
                 else if ( ((scount > 0) && (!state->nagleEnabled)) || // Data to send and Nagle off
                         ((uint32)scount >= path->pmtu - 32 - 20) || // Data to fill at least one path MTU
                         ((scount > 0) && (state->nagleEnabled) && ((outstandingBytes == 0) || (sackOnly && sackAdded)) )) {   // Data to send, Nagle on and no outstanding bytes
+#ifdef PRIVATE
+                    // ====== Buffer Splitting ===================================
+                    bool         rejected    = false;
+                    const uint32 bytesOnPath = (state->cmtBufferSplittingUsesOSB == true) ?
+                                                  path->outstandingBytes : path->queuedBytes;
+                    if(state->allowCMT) {
+                        // ------ Sender Side -------------------------------------
+                        if( (state->cmtBufferSplitVariant == SCTPStateVariables::CBSV_SenderOnly) ||
+                            (state->cmtBufferSplitVariant == SCTPStateVariables::CBSV_BothSides) ) {
+
+                           // Limit is 1/n of current sender-side buffer allocation
+                           const uint32 limit = ((state->sendQueueLimit != 0) ? state->sendQueueLimit : 0xffffffff) / sctpPathMap.size();
+                           if(bytesOnPath + path->pmtu > limit) {
+                               rejected = true;
+                               sctpEV3 << simTime() << ":\tSenderBufferSplitting: Rejecting transmission on "
+                                       << path->remoteAddress << ", since "
+                                       << bytesOnPath << " + " << path->pmtu << " > "
+                                       << state->sendQueueLimit / sctpPathMap.size() << endl;
+                           }
+                        }
+
+                        // ------ Receiver Side -----------------------------------
+                        if( (rejected == false) &&
+                            ( (state->cmtBufferSplitVariant == SCTPStateVariables::CBSV_ReceiverOnly) ||
+                              (state->cmtBufferSplitVariant == SCTPStateVariables::CBSV_BothSides) ) ) {
+
+                            // Limit is 1/n of current receiver-side buffer allocation
+                            const uint32 limit = (state->peerRwnd + state->outstandingBytes) /
+                                                 sctpPathMap.size();
+                            if(bytesOnPath + path->pmtu > limit + path->pmtu) {
+                                // T.D. 09.07.2011: Allow overbooking by up to 1 MTU ...
+                                sctpEV3 << simTime() << ":\tReceiverBufferSplitting: Rejecting transmission on "
+                                        << path->remoteAddress << ", since "
+                                        << bytesOnPath + path->pmtu << " > " << limit << endl;
+                                rejected = true;
+                            }
+                        }
+                    }
+
+                    // ====== Buffer Splitting ===================================
+                    if( ((state->allowCMT) || (path == state->getPrimaryPath())) &&
+                        (!rejected) ) {
+#else
                     if (path == state->getPrimaryPath()) {
+#endif
 
                         // ------ Dequeue data message ----------------------------
                         SCTPDataMsg* datMsg = dequeueOutboundDataMsg(path, path->pmtu-sctpMsg->getByteLength() - 20,
@@ -721,6 +1290,10 @@ void SCTPAssociation::sendOnPath(SCTPPathVariables* pathId, bool firstPass)
                                     sackAdded = false;
                                 }
                                 else {
+#ifdef PRIVATE
+                                    path->lastTransmission = simTime();
+                                    path->packetsInBurst++;
+#endif
                                     state->lastTransmission = simTime();
                                     state->packetsInTotalBurst++;
                                     if (dataChunksAdded > 0) {
@@ -1004,6 +1577,15 @@ void SCTPAssociation::sendOnPath(SCTPPathVariables* pathId, bool firstPass)
                             chunkPtr->setIBit(sctpMain->sackNow);
                         }
 
+#ifdef PRIVATE
+                        // T.D. 02.02.2010: Set I-bit when this is the final packet for this path!
+                        if(state->strictCwndBooking) {
+                            const int32 a = (int32)path->cwnd - (int32)path->outstandingBytes;
+                            if( ((a > 0) && (nextChunkFitsIntoPacket(path, a) == false)) || (!firstPass) ) {
+                                chunkPtr->setIBit(sctpMain->sackNow);
+                            }
+                        }
+#endif
                         if (dataChunksAdded > 0) {
                             state->ssNextStream = true;
                         }
@@ -1012,6 +1594,10 @@ void SCTPAssociation::sendOnPath(SCTPPathVariables* pathId, bool firstPass)
                         recordTransmission(sctpMsg, path);
                         pmDataIsSentOn(path);
                         totalPacketsSent++;
+#ifdef PRIVATE
+                        path->lastTransmission = simTime();
+                        path->packetsInBurst++;
+#endif
                         state->lastTransmission = simTime();
                         state->packetsInTotalBurst++;
 
@@ -1021,6 +1607,10 @@ void SCTPAssociation::sendOnPath(SCTPPathVariables* pathId, bool firstPass)
                             std::cout << simTime() << ":\t"
                                     << "Sending TSN " << dataChunkPtr->getTsn() << " on "
                                     << path->remoteAddress
+#ifdef PRIVATE
+                                    << ", packetsInBurst="
+                                    << path->packetsInBurst
+#endif
                                     << endl;
                         }
 #endif
diff --git a/src/transport/sctp/SCTPAssociationUtil.cc b/src/transport/sctp/SCTPAssociationUtil.cc
index 6f67c79..a56dd8d 100644
--- a/src/transport/sctp/SCTPAssociationUtil.cc
+++ b/src/transport/sctp/SCTPAssociationUtil.cc
@@ -144,7 +144,24 @@ void SCTPAssociation::checkOutstandingBytes()
     assert(state->outstandingBytes == totalOutstandingBytesCounted);
 }
 
+#ifdef PRIVATE
+void SCTPAssociation::checkPseudoCumAck(const SCTPPathVariables* path)
+{
+   uint32 earliestOutstandingTSN    = path->pseudoCumAck;
+   uint32 rtxEarliestOutstandingTSN = path->rtxPseudoCumAck;
+
+   retransmissionQ->findEarliestOutstandingTSNsForPath(
+                       path->remoteAddress,
+                       earliestOutstandingTSN, rtxEarliestOutstandingTSN);
 
+   if( tsnGt(path->pseudoCumAck, earliestOutstandingTSN) ||
+       tsnGt(path->rtxPseudoCumAck, rtxEarliestOutstandingTSN) ) {
+      std::cerr << "WRONG PSEUDO CUM-ACK!" << endl
+                << "pseudoCumAck=" << path->pseudoCumAck << ", earliestOutstandingTSN=" << earliestOutstandingTSN << endl
+                << "rtxPseudoCumAck=" << path->rtxPseudoCumAck << ", rtxEarliestOutstandingTSN=" << rtxEarliestOutstandingTSN << endl;
+   }
+}
+#endif
 
 void SCTPAssociation::printSctpPathMap() const
 {
@@ -1281,8 +1298,122 @@ SCTPForwardTsnChunk* SCTPAssociation::createForwardTsnChunk(const IPvXAddress& p
     return forwChunk;
 }
 
-
-
+#ifdef PRIVATE
+inline static bool writeCompressedValue(uint8_t*       outputBuffer,
+                                       const size_t   outputBufferSize,
+                                       size_t&        pos,
+                                       const uint16_t value)
+{
+   if(value < 0x80) {   // 1 byte: 0vvvvvvv
+      if(pos + 1 > outputBufferSize) {
+         return(false);
+      }
+      outputBuffer[pos] = (uint8_t)value;
+      // printf("[%02x] ", outputBuffer[pos]);
+      pos += 1;
+   }
+   else if(value < 0x4000) {   // 2 bytes: 10vvvvvv vvvvvvvv
+      if(pos + 2 > outputBufferSize) {
+         return(false);
+      }
+      outputBuffer[pos+0] = 0x80 | (uint8_t)(value >> 8);
+      outputBuffer[pos+1] = (uint8_t)(value & 0xff);
+      // printf("[%02x %02x] ", outputBuffer[pos+0], outputBuffer[pos+1]);
+      pos += 2;
+   }
+   else {   // 3 bytes: 11xxxxxx vvvvvvvv vvvvvvvv
+      if(pos + 3 > outputBufferSize) {
+         return(false);
+      }
+      outputBuffer[pos+0] = 0xc0;
+      outputBuffer[pos+1] = (uint8_t)(value >> 8);
+      outputBuffer[pos+2] = (uint8_t)(value & 0xff);
+      pos += 3;
+   }
+   return(true);
+}
+
+inline static uint16_t readCompressedValue(const uint8_t* inputBuffer,
+                                           const size_t   inputBufferSize,
+                                           size_t&        pos)
+{
+   uint16_t value;
+
+   assert(pos < inputBufferSize);
+   if(inputBuffer[pos] < 0x80) {   // 1 byte: 0vvvvvvv
+      value = (uint16_t)inputBuffer[pos];
+      pos += 1;
+   }
+   else if((inputBuffer[pos] & 0xc0) == 0x80) {   // 2 bytes: 10vvvvvv vvvvvvvv
+      assert(pos + 1 < inputBufferSize);
+      value = ((uint16_t)inputBuffer[pos+0] << 8) &~ 0x8000;
+      value |= (uint16_t)inputBuffer[pos+1];
+      pos += 2;
+   }
+   else if(inputBuffer[pos] == 0xc0) {   // 3 bytes: 11xxxxxx vvvvvvvv vvvvvvvv
+      assert(pos + 2 < inputBufferSize);
+      value = ((uint16_t)inputBuffer[pos+1] << 8) | (uint16_t)inputBuffer[pos+2];
+      pos += 3;
+   }
+   else { assert(false); }
+
+   return(value);
+}
+
+
+#define VERIFY_COMPRESSED_GAPLISTS
+
+static uint32 compressGaps(const GapList* gapList, const GapList::GapType type, size_t& space)
+{
+   uint8 compressedDataBuffer[1 + 6 * gapList->getNumGaps(type)];   // Worst-case size
+
+   size_t       outputPos      = 0;
+   unsigned int entriesWritten = 0;
+   uint32 last          = gapList->getCumAckTSN();
+   for(unsigned int i = 0; i < gapList->getNumGaps(type); i++) {
+      assert(tsnGt(gapList->getGapStart(type, i), last + 1));
+      assert(tsnGe(gapList->getGapStop(type, i), gapList->getGapStart(type, i)));
+      const uint16 startOffset = gapList->getGapStart(type, i) - last;
+      const uint16 stopOffset  = gapList->getGapStop(type, i) - gapList->getGapStart(type, i);
+      const size_t lastOutputPos = outputPos;
+      if( (writeCompressedValue((uint8*)&compressedDataBuffer, sizeof(compressedDataBuffer), outputPos, startOffset) == false) ||
+          (writeCompressedValue((uint8*)&compressedDataBuffer, sizeof(compressedDataBuffer), outputPos, stopOffset) == false) ||
+          (outputPos + 1 > space) ) {
+         outputPos = lastOutputPos;
+         break;
+      }
+      entriesWritten++;
+      last = gapList->getGapStop(type, i);
+   }
+   assert(writeCompressedValue((uint8*)&compressedDataBuffer, sizeof(compressedDataBuffer), outputPos, 0x00) == true);
+   space = outputPos;
+
+#ifdef VERIFY_COMPRESSED_GAPLISTS
+#warning Verifying compressed gaps lists
+   size_t       inputPos = 0;
+   unsigned int i        = 0;
+   last = gapList->getCumAckTSN();
+   while(true) {
+      const uint16 startOffset = readCompressedValue(compressedDataBuffer, outputPos, inputPos);
+      if(startOffset > 0) {
+         const uint16 stopOffset = readCompressedValue(compressedDataBuffer, outputPos, inputPos);
+         const uint32 startTSN = last + startOffset;
+         const uint32 stopTSN  = startTSN + stopOffset;
+         assert(startTSN == gapList->getGapStart(type, i));
+         assert(stopTSN  == gapList->getGapStop(type, i));
+         last = stopTSN;
+      }
+      else {
+         break;
+      }
+      i++;
+   }
+   assert(i == entriesWritten);
+#endif
+
+   return(entriesWritten);
+}
+#endif
 
 static uint32 copyToRGaps(SCTPSackChunk*         sackChunk,
         const GapList*         gapList,
@@ -1293,6 +1424,11 @@ static uint32 copyToRGaps(SCTPSackChunk*         sackChunk,
     const uint32 count = gapList->getNumGaps(type);
     uint32       last = gapList->getCumAckTSN();
     uint32       keys = min(space / 4, count);   // Each entry occupies 2+2 bytes => at most space/4 entries
+#ifdef PRIVATE
+    if(compression) {
+        keys = count;   // Get all entries first, compress them later
+    }
+#endif
 
     sackChunk->setGapStartArraySize(keys);
     sackChunk->setGapStopArraySize(keys);
@@ -1306,7 +1442,15 @@ static uint32 copyToRGaps(SCTPSackChunk*         sackChunk,
         sackChunk->setGapStop(key, gapList->getGapStop(type, key));
         last = gapList->getGapStop(type, key);
     }
-    space = 4 * keys;
+#ifdef PRIVATE
+    if(compression) {
+        keys = compressGaps(gapList, type, space);
+        sackChunk->setNrGapStartArraySize(keys);
+        sackChunk->setNrGapStopArraySize(keys);
+    }
+   else
+#endif
+       space = 4 * keys;
 
     return (keys);
 }
@@ -1320,6 +1464,11 @@ static uint32 copyToNRGaps(SCTPSackChunk*         sackChunk,
     const uint32 count = gapList->getNumGaps(type);
     uint32       last = gapList->getCumAckTSN();
     uint32       keys = min(space / 4, count);   // Each entry occupies 2+2 bytes => at most space/4 entries
+#ifdef PRIVATE
+    if(compression) {
+        keys = count;   // Get all entries first, compress them later
+    }
+#endif
 
     sackChunk->setNrGapStartArraySize(keys);
     sackChunk->setNrGapStopArraySize(keys);
@@ -1333,7 +1482,15 @@ static uint32 copyToNRGaps(SCTPSackChunk*         sackChunk,
         sackChunk->setNrGapStop(key, gapList->getGapStop(type, key));
         last = gapList->getGapStop(type, key);
     }
-    space = 4 * keys;
+#ifdef PRIVATE
+    if(compression) {
+        keys = compressGaps(gapList, type, space);
+        sackChunk->setNrGapStartArraySize(keys);
+        sackChunk->setNrGapStopArraySize(keys);
+    }
+    else
+#endif
+        space = 4 * keys;
 
     return (keys);
 }
@@ -1445,20 +1602,67 @@ SCTPSackChunk* SCTPAssociation::createSack()
     statisticsNumNonRevokableGapBlocksStored->record(numNonRevokableGaps);
     statisticsNumDuplicatesStored->record(numDups);
 
-    // ------ Regular NR-SACK ---------------------------
-    if (state->nrSack == true) {
-        sackHeaderLength = SCTP_NRSACK_CHUNK_LENGTH;
-        numRevokableGaps = copyToRGaps(sackChunk,  &state->gapList, GapList::GT_Revokable,    compression, revokableGapsSpace);    // Add R-acks only
-        numNonRevokableGaps = copyToNRGaps(sackChunk, &state->gapList, GapList::GT_NonRevokable, compression, nonRevokableGapsSpace); // Add NR-acks only
-    }
-    // ------ Regular SACK ------------------------------
-    else {
-        sackHeaderLength = SCTP_SACK_CHUNK_LENGTH;
-        numRevokableGaps = copyToRGaps(sackChunk, &state->gapList,  GapList::GT_Any, false, revokableGapsSpace);            // Add ALL
-        numNonRevokableGaps = 0;
-        nonRevokableGapsSpace = 0;
+#ifdef PRIVATE
+   // ====== Optimization ===================================================
+   const int optR   = (int)numRevokableGaps    - (int)totalGaps;
+   const int optNR  = (int)numNonRevokableGaps - (int)totalGaps;
+
+   // static int opt=0;
+   // static int total=0;
+   // total += numRevokableGaps + numNonRevokableGaps;
+   // printf("%d/%d\t%d\t%d\t%d\t%d\n",
+   //        opt,total,totalGaps,numRevokableGaps,numNonRevokableGaps,numRevokableGaps+numNonRevokableGaps);
+
+   if( (state->gapListOptimizationVariant == SCTPStateVariables::GLOV_Shrunken) &&
+       ((numRevokableGaps > 0) || (numNonRevokableGaps > 0)) ) {
+      compression = true;
+   }
+
+   // ------ Optimization 1: R=ANY, NR=non-revokable ------
+   if( (state->nrSack == true) &&
+       (((optR > 0) && (state->gapListOptimizationVariant == SCTPStateVariables::GLOV_Optimized1)) ||
+        ((optR > 0) && (optR >= optNR) && (state->gapListOptimizationVariant >= SCTPStateVariables::GLOV_Optimized2))) ) {
+      assert(totalGaps < numRevokableGaps);
+      sackHeaderLength    = (compression == true) ? SCTP_COMPRESSED_NRSACK_CHUNK_LENGTH : SCTP_NRSACK_CHUNK_LENGTH;
+      numRevokableGaps    = copyToRGaps(sackChunk,  &state->gapList, GapList::GT_Any,          compression, revokableGapsSpace);    // Add ALL
+      numNonRevokableGaps = copyToNRGaps(sackChunk, &state->gapList, GapList::GT_NonRevokable, compression, nonRevokableGapsSpace); // Add NR-acks only
+      assert(numRevokableGaps == totalGaps);
+      // opt += optR;
+   }
+   // ------ Optimization 2: NR=ANY, R=difference ---------
+   else if( (state->nrSack == true) &&
+            (optNR > 0) && (state->gapListOptimizationVariant >= SCTPStateVariables::GLOV_Optimized2) ) {
+      assert(totalGaps < numNonRevokableGaps);
+      sackChunk->setNrSubtractRGaps(true);
+      sackHeaderLength    = (compression == true) ? SCTP_COMPRESSED_NRSACK_CHUNK_LENGTH : SCTP_NRSACK_CHUNK_LENGTH;
+      numRevokableGaps    = copyToRGaps(sackChunk,  &state->gapList, GapList::GT_Revokable, compression, revokableGapsSpace);    // Add R-acks only
+      numNonRevokableGaps = copyToNRGaps(sackChunk, &state->gapList, GapList::GT_Any,       compression, nonRevokableGapsSpace); // Add ALL
+      assert(numNonRevokableGaps == totalGaps);
+      // opt += optNR;
+   }
+   else {
+#endif
+        // ------ Regular NR-SACK ---------------------------
+        if (state->nrSack == true) {
+           sackHeaderLength = SCTP_NRSACK_CHUNK_LENGTH;
+#ifdef PRIVATE
+           if(compression == true) {
+              sackHeaderLength = SCTP_COMPRESSED_NRSACK_CHUNK_LENGTH;
+           }
+#endif
+           numRevokableGaps = copyToRGaps(sackChunk,  &state->gapList, GapList::GT_Revokable,    compression, revokableGapsSpace);    // Add R-acks only
+           numNonRevokableGaps = copyToNRGaps(sackChunk, &state->gapList, GapList::GT_NonRevokable, compression, nonRevokableGapsSpace); // Add NR-acks only
+        }
+        // ------ Regular SACK ------------------------------
+        else {
+           sackHeaderLength = SCTP_SACK_CHUNK_LENGTH;
+           numRevokableGaps = copyToRGaps(sackChunk, &state->gapList,  GapList::GT_Any, false, revokableGapsSpace);            // Add ALL
+           numNonRevokableGaps = 0;
+           nonRevokableGapsSpace = 0;
+        }
+#ifdef PRIVATE
     }
-
+#endif
 
     // ====== SACK has to be shorted to fit in MTU ===========================
     uint32 sackLength = sackHeaderLength + revokableGapsSpace + nonRevokableGapsSpace + numDups*4;
@@ -1492,6 +1696,14 @@ SCTPSackChunk* SCTPAssociation::createSack()
             SCTP::AssocStatMap::iterator iter = sctpMain->assocStatMap.find(assocId);
             iter->second.numOverfullSACKs++;
 
+#ifdef PRIVATE
+            // ====== Undo NR optimization ====================================
+            if(sackChunk->getNrSubtractRGaps() == true) {
+                sackChunk->setNrSubtractRGaps(false);   // Unset SubtractRGaps!
+                // This optimization cannot work when lists have to be shortened.
+                // Just use regular NR list.
+            }
+#endif
             revokableGapsSpace = allowedLength - sackHeaderLength;
             if (totalGaps < (state->gapList.getNumGaps(GapList::GT_Revokable))) {
                 numRevokableGaps = copyToRGaps(sackChunk,  &state->gapList, GapList::GT_Any,          compression, revokableGapsSpace);    // Add ALL
@@ -1502,20 +1714,39 @@ SCTPSackChunk* SCTPAssociation::createSack()
             sackLength = sackHeaderLength + revokableGapsSpace + nonRevokableGapsSpace + numDups*4;
 
             // ====== Shorten gap lists ========================================
-            if (sackLength > allowedLength) {
-                const uint32 blocksBeRemoved = (sackLength - allowedLength) / 4;
-                const double revokableFraction = numRevokableGaps / (double)(numRevokableGaps + numNonRevokableGaps);
-
-                const uint32 removeRevokable = (uint32)ceil(blocksBeRemoved * revokableFraction);
-                const uint32 removeNonRevokable = (uint32)ceil(blocksBeRemoved * (1.0 - revokableFraction));
-                numRevokableGaps -= std::min(removeRevokable, numRevokableGaps);
-                numNonRevokableGaps -= std::min(removeNonRevokable, numNonRevokableGaps);
-                revokableGapsSpace = 4 * numRevokableGaps;
-                nonRevokableGapsSpace = 4 * numNonRevokableGaps;
-                numRevokableGaps = copyToRGaps(sackChunk,  &state->gapList, GapList::GT_Revokable,    compression, revokableGapsSpace);    // Add R-acks only
-                numNonRevokableGaps = copyToNRGaps(sackChunk, &state->gapList, GapList::GT_NonRevokable, compression, nonRevokableGapsSpace); // Add NR-acks only
-                sackLength = sackHeaderLength + revokableGapsSpace + nonRevokableGapsSpace + numDups*4;
+#ifdef PRIVATE
+            if(state->smartOverfullSACKHandling) {
+               if(sackHeaderLength + revokableGapsSpace < allowedLength) {
+                  // Fill NR-acks up to allowed size
+                  nonRevokableGapsSpace = allowedLength - sackHeaderLength - revokableGapsSpace;
+                  numNonRevokableGaps = copyToNRGaps(sackChunk, &state->gapList, GapList::GT_NonRevokable, compression, nonRevokableGapsSpace); // Add NR-acks only
+                  sackLength = sackHeaderLength + revokableGapsSpace + nonRevokableGapsSpace + numDups*4;
+               }
+               else {
+                  // Not even space to set R-acks => cut R-acks, no NR-acks!
+                  nonRevokableGapsSpace = allowedLength - sackHeaderLength;
+                  numRevokableGaps = copyToRGaps(sackChunk,  &state->gapList, GapList::GT_Any, compression, revokableGapsSpace);    // Add ALL
+               }
+            }
+            else {
+#endif
+                if (sackLength > allowedLength) {
+                   const uint32 blocksBeRemoved = (sackLength - allowedLength) / 4;
+                   const double revokableFraction = numRevokableGaps / (double)(numRevokableGaps + numNonRevokableGaps);
+
+                   const uint32 removeRevokable = (uint32)ceil(blocksBeRemoved * revokableFraction);
+                   const uint32 removeNonRevokable = (uint32)ceil(blocksBeRemoved * (1.0 - revokableFraction));
+                   numRevokableGaps -= std::min(removeRevokable, numRevokableGaps);
+                   numNonRevokableGaps -= std::min(removeNonRevokable, numNonRevokableGaps);
+                   revokableGapsSpace = 4 * numRevokableGaps;
+                   nonRevokableGapsSpace = 4 * numNonRevokableGaps;
+                   numRevokableGaps = copyToRGaps(sackChunk,  &state->gapList, GapList::GT_Revokable,    compression, revokableGapsSpace);    // Add R-acks only
+                   numNonRevokableGaps = copyToNRGaps(sackChunk, &state->gapList, GapList::GT_NonRevokable, compression, nonRevokableGapsSpace); // Add NR-acks only
+                   sackLength = sackHeaderLength + revokableGapsSpace + nonRevokableGapsSpace + numDups*4;
+                }
+#ifdef PRIVATE
             }
+#endif
             assert(sackLength <= allowedLength);
 
             // Update values in SACK chunk ...
@@ -1526,6 +1757,22 @@ SCTPSackChunk* SCTPAssociation::createSack()
     sackChunk->setNumDupTsns(numDups);
     sackChunk->setBitLength(sackLength * 8);
 
+#ifdef PRIVATE
+    // ====== Apply limit ====================================================
+    if (state->gapReportLimit < 1000000) {
+       if (!compression) {
+          numRevokableGaps    = std::min(numRevokableGaps, state->gapReportLimit);
+          numNonRevokableGaps = std::min(numNonRevokableGaps, state->gapReportLimit);
+          // Update values in SACK chunk ...
+          sackChunk->setNumGaps(numRevokableGaps);
+          sackChunk->setNumNrGaps(numNonRevokableGaps);
+          sackLength = sackHeaderLength + revokableGapsSpace + nonRevokableGapsSpace + numDups*4;
+       }
+       else {
+          assert(false);   // NOTE: IMPLEMENT ME!
+       }
+    }
+#endif
 
     // ====== Add duplicates =================================================
     if (numDups > 0) {
@@ -2353,6 +2600,12 @@ SCTPPathVariables* SCTPAssociation::getNextPath(const SCTPPathVariables* oldPath
                 }
             }
             if ( (newPath->activePath)
+#ifdef PRIVATE
+                 &&
+                 ( (state->allowCMT == false) ||
+                   (newPath->blockingTimeout <= 0.0) ||
+                   (simTime() > newPath->blockingTimeout) )
+#endif
             ) {
                 return newPath;
             }
@@ -2602,12 +2855,75 @@ void SCTPAssociation::putInTransmissionQ(const uint32 tsn, SCTPDataVariables* ch
 
 void SCTPAssociation::recordTransmission(SCTPMessage* sctpMsg, SCTPPathVariables* path)
 {
+#ifdef PRIVATE
+   if(path->QoS.isActive()) {
+      // ====== Record DATA transmission(s) on their stream(s) ==============
+      const uint32 numberOfChunks = sctpMsg->getChunksArraySize();
+      for(unsigned int i = 0; i < numberOfChunks; i++) {
+         const SCTPDataChunk* chunk =
+            dynamic_cast<const SCTPDataChunk*>(sctpMsg->getChunks(i));
+         if(chunk) {
+            unsigned int payloadLength = chunk->getByteLength();
+            assert(payloadLength >= 16);
+            payloadLength -= 16;   // Subtract DATA chunk header size => payload only.
+
+            SCTPSendStreamMap::iterator iterator =
+               sendStreams.find(chunk->getSid());
+            assert(iterator != sendStreams.end());
+            SCTPSendStream* stream = iterator->second;
+            if(chunk->getUBit()) {
+               stream->UnorderedQoS.recordTransmission(
+                  chunk->getTsn(), payloadLength, simTime());
+            }
+            else {
+               stream->OrderedQoS.recordTransmission(
+                  chunk->getTsn(), payloadLength, simTime());
+            }
+
+            // ====== Record transmission on path ===========================
+            path->QoS.recordTransmission(
+               chunk->getTsn(), payloadLength, simTime());
+         }
+      }
+   }
+#endif
 }
 
 void SCTPAssociation::recordAcknowledgement(SCTPDataVariables* chunk, SCTPPathVariables* path)
 {
+#ifdef PRIVATE
+   // ====== Record DATA acknowledgement for its stream =====================
+   SCTPSendStreamMap::iterator iterator = sendStreams.find(chunk->sid);
+   assert(iterator != sendStreams.end());
+   SCTPSendStream* stream = iterator->second;
+   if(!chunk->ordered) {
+      stream->UnorderedQoS.recordAcknowledgement(
+         chunk->tsn, chunk->booksize, chunk->sendTime, simTime());
+   }
+   else {
+      stream->OrderedQoS.recordAcknowledgement(
+         chunk->tsn, chunk->booksize, chunk->sendTime, simTime());
+   }
+
+   // ====== Record acknowledgement on path =================================
+   path->QoS.recordAcknowledgement(
+      chunk->tsn, chunk->booksize, chunk->sendTime, simTime());
+#endif
 }
 
 void SCTPAssociation::recordDequeuing(SCTPDataVariables* chunk)
 {
+#ifdef PRIVATE
+   SCTPSendStreamMap::iterator iterator = sendStreams.find(chunk->sid);
+   assert(iterator != sendStreams.end());
+   SCTPSendStream* stream = iterator->second;
+   if(!chunk->ordered) {
+      stream->UnorderedQoS.recordDequeuing(
+         chunk->booksize, chunk->enqueuingTime, simTime());
+   }
+   else {
+      stream->OrderedQoS.recordDequeuing(
+         chunk->booksize, chunk->enqueuingTime, simTime());
+   }
+#endif
 }
diff --git a/src/transport/sctp/SCTPCCFunctions.cc b/src/transport/sctp/SCTPCCFunctions.cc
index 737ddbc..9cc6210 100644
--- a/src/transport/sctp/SCTPCCFunctions.cc
+++ b/src/transport/sctp/SCTPCCFunctions.cc
@@ -31,9 +31,184 @@ static inline double GET_SRTT(const double srtt)
 }
 
 
+#ifdef PRIVATE
+// ====== High-Speed CC cwnd adjustment table from RFC 3649 appendix B ======
+struct HighSpeedCwndAdjustmentEntry {
+   int32_t cwndThreshold;
+   double  increaseFactor;
+   double  decreaseFactor;
+};
+static const HighSpeedCwndAdjustmentEntry HighSpeedCwndAdjustmentTable[] = {
+   {    38,  1,  0.50 },
+   {   118,  2,  0.44 },
+   {   221,  3,  0.41 },
+   {   347,  4,  0.38 },
+   {   495,  5,  0.37 },
+   {   663,  6,  0.35 },
+   {   851,  7,  0.34 },
+   {  1058,  8,  0.33 },
+   {  1284,  9,  0.32 },
+   {  1529, 10,  0.31 },
+   {  1793, 11,  0.30 },
+   {  2076, 12,  0.29 },
+   {  2378, 13,  0.28 },
+   {  2699, 14,  0.28 },
+   {  3039, 15,  0.27 },
+   {  3399, 16,  0.27 },
+   {  3778, 17,  0.26 },
+   {  4177, 18,  0.26 },
+   {  4596, 19,  0.25 },
+   {  5036, 20,  0.25 },
+   {  5497, 21,  0.24 },
+   {  5979, 22,  0.24 },
+   {  6483, 23,  0.23 },
+   {  7009, 24,  0.23 },
+   {  7558, 25,  0.22 },
+   {  8130, 26,  0.22 },
+   {  8726, 27,  0.22 },
+   {  9346, 28,  0.21 },
+   {  9991, 29,  0.21 },
+   { 10661, 30,  0.21 },
+   { 11358, 31,  0.20 },
+   { 12082, 32,  0.20 },
+   { 12834, 33,  0.20 },
+   { 13614, 34,  0.19 },
+   { 14424, 35,  0.19 },
+   { 15265, 36,  0.19 },
+   { 16137, 37,  0.19 },
+   { 17042, 38,  0.18 },
+   { 17981, 39,  0.18 },
+   { 18955, 40,  0.18 },
+   { 19965, 41,  0.17 },
+   { 21013, 42,  0.17 },
+   { 22101, 43,  0.17 },
+   { 23230, 44,  0.17 },
+   { 24402, 45,  0.16 },
+   { 25618, 46,  0.16 },
+   { 26881, 47,  0.16 },
+   { 28193, 48,  0.16 },
+   { 29557, 49,  0.15 },
+   { 30975, 50,  0.15 },
+   { 32450, 51,  0.15 },
+   { 33986, 52,  0.15 },
+   { 35586, 53,  0.14 },
+   { 37253, 54,  0.14 },
+   { 38992, 55,  0.14 },
+   { 40808, 56,  0.14 },
+   { 42707, 57,  0.13 },
+   { 44694, 58,  0.13 },
+   { 46776, 59,  0.13 },
+   { 48961, 60,  0.13 },
+   { 51258, 61,  0.13 },
+   { 53677, 62,  0.12 },
+   { 56230, 63,  0.12 },
+   { 58932, 64,  0.12 },
+   { 61799, 65,  0.12 },
+   { 64851, 66,  0.11 },
+   { 68113, 67,  0.11 },
+   { 71617, 68,  0.11 },
+   { 75401, 69,  0.10 },
+   { 79517, 70,  0.10 },
+   { 84035, 71,  0.10 },
+   { 89053, 72,  0.10 },
+   { 94717, 73,  0.09 }
+};
+
+
+void SCTPAssociation::updateHighSpeedCCThresholdIdx(SCTPPathVariables* path)
+{
+   if(path->cwnd > HighSpeedCwndAdjustmentTable[path->highSpeedCCThresholdIdx].cwndThreshold * path->pmtu) {
+      while( (path->cwnd > HighSpeedCwndAdjustmentTable[path->highSpeedCCThresholdIdx].cwndThreshold * path->pmtu) &&
+             (path->highSpeedCCThresholdIdx < (sizeof(HighSpeedCwndAdjustmentTable) / sizeof(HighSpeedCwndAdjustmentEntry))) ) {
+         path->highSpeedCCThresholdIdx++;
+      }
+   }
+   else {
+      while( (path->cwnd <= HighSpeedCwndAdjustmentTable[path->highSpeedCCThresholdIdx].cwndThreshold * path->pmtu) &&
+             (path->highSpeedCCThresholdIdx > 0) ) {
+         path->highSpeedCCThresholdIdx--;
+      }
+   }
+}
+#endif
+
+
 void SCTPAssociation::cwndUpdateBeforeSack()
 {
+#ifdef PRIVATE
+   // First, calculate per-path values.
+   for (SCTPPathMap::iterator otherPathIterator = sctpPathMap.begin();
+      otherPathIterator != sctpPathMap.end(); otherPathIterator++) {
+      SCTPPathVariables* otherPath = otherPathIterator->second;
+      otherPath->utilizedCwnd      = otherPath->outstandingBytesBeforeUpdate;
+   }
+
+   // Calculate per-path-group values.
+   for (SCTPPathMap::iterator currentPathIterator = sctpPathMap.begin();
+        currentPathIterator != sctpPathMap.end(); currentPathIterator++) {
+      SCTPPathVariables* currentPath = currentPathIterator->second;
+
+      currentPath->cmtGroupPaths                      = 0;
+      currentPath->cmtGroupTotalCwnd                  = 0;
+      currentPath->cmtGroupTotalSsthresh              = 0;
+      currentPath->cmtGroupTotalUtilizedCwnd          = 0;
+      currentPath->cmtGroupTotalCwndBandwidth         = 0.0;
+      currentPath->cmtGroupTotalUtilizedCwndBandwidth = 0.0;
+
+      double qNumerator   = 0.0;
+      double qDenominator = 0.0;
+      for (SCTPPathMap::const_iterator otherPathIterator = sctpPathMap.begin();
+         otherPathIterator != sctpPathMap.end(); otherPathIterator++) {
+         const SCTPPathVariables* otherPath = otherPathIterator->second;
+         if(otherPath->cmtCCGroup == currentPath->cmtCCGroup) {
+            currentPath->cmtGroupPaths++;
+
+            currentPath->cmtGroupTotalCwnd                  += otherPath->cwnd;
+            currentPath->cmtGroupTotalSsthresh              += otherPath->ssthresh;
+            currentPath->cmtGroupTotalCwndBandwidth         += otherPath->cwnd / GET_SRTT(otherPath->srtt.dbl());
+
+            if( (otherPath->blockingTimeout < 0.0) || (otherPath->blockingTimeout < simTime()) ) {
+               currentPath->cmtGroupTotalUtilizedCwnd          += otherPath->utilizedCwnd;
+               currentPath->cmtGroupTotalUtilizedCwndBandwidth += otherPath->utilizedCwnd / GET_SRTT(otherPath->srtt.dbl());
+            }
+
+            qNumerator   = max(qNumerator, otherPath->cwnd / (pow(GET_SRTT(otherPath->srtt.dbl()), 2.0)));
+            qDenominator = qDenominator + (otherPath->cwnd / GET_SRTT(otherPath->srtt.dbl()));
+         }
+      }
+      currentPath->cmtGroupAlpha = currentPath->cmtGroupTotalCwnd * (qNumerator / pow(qDenominator, 2.0));
+
+/*
+      printf("alpha(%s)=%1.6f\ttotalCwnd=%u\tcwnd=%u\tpaths=%u\n",
+             currentPath->remoteAddress.str().c_str(),
+             currentPath->cmtGroupAlpha,
+             currentPath->cmtGroupTotalCwnd,
+             currentPath->cwnd,
+             currentPath->cmtGroupPaths);
+*/
+   }
+#endif
+}
+
+
+#ifdef PRIVATE
+static uint32 updateMPTCP(const uint32 w,
+                          const uint32 totalW,
+                          double       a,
+                          const uint32 mtu,
+                          const uint32 ackedBytes)
+{
+   const uint32 increase =
+      max(1,
+          min( (uint32)ceil((double)w * a * (double)min(ackedBytes, mtu)  / (double)totalW),
+               (uint32)min(ackedBytes, mtu) ));
+/*
+   printf("\n%1.6f:\tMPTCP-Like CC: a=%1.6f\tc=%u -> %u\tincrease=%u\n",
+          simTime().dbl(), a, w, w + increase, increase);
+*/
+   return(w + increase);
 }
+#endif
 
 
 void SCTPAssociation::recordCwndUpdate(SCTPPathVariables* path)
@@ -64,7 +239,24 @@ void SCTPAssociation::recordCwndUpdate(SCTPPathVariables* path)
 uint32 SCTPAssociation::getInitialCwnd(const SCTPPathVariables* path) const
 {
     uint32 newCwnd;
+#ifdef PRIVATE
+    const uint32 upperLimit = (state->initialWindow > 0) ? (state->initialWindow * path->pmtu) : max(2 * path->pmtu, 4380);
+    if( (state->allowCMT == false) || (state->cmtCCVariant == SCTPStateVariables::CCCV_CMT) ) {
+        newCwnd = (int32)min((state->initialWindow > 0) ? (state->initialWindow * path->pmtu) : (4 * path->pmtu),
+                             upperLimit);
+    }
+    else {
+        newCwnd = (int32)min( (int32)ceil(((state->initialWindow > 0) ?
+                                          (state->initialWindow * path->pmtu) :
+                                          (4 * path->pmtu)) / (double)sctpPathMap.size()),
+                              upperLimit);
+        if(newCwnd < path->pmtu) {   // T.D. 09.09.2010: cwnd < MTU makes no sense ...
+            newCwnd = path->pmtu;
+        }
+    }
+#else
     newCwnd = max(2 * path->pmtu, 4380);
+#endif
     return (newCwnd);
 }
 
@@ -76,6 +268,9 @@ void SCTPAssociation::initCCParameters(SCTPPathVariables* path)
     recordCwndUpdate(path);
 
     sctpEV3 << assocId << ": " << simTime() << ":\tCC [initCCParameters]\t" << path->remoteAddress
+#ifdef PRIVATE
+            << " (cmtCCGroup=" << path->cmtCCGroup << ")"
+#endif
             << "\tsst=" << path->ssthresh
             << "\tcwnd=" << path->cwnd << endl;
 }
@@ -86,6 +281,23 @@ int32 SCTPAssociation::rpPathBlockingControl(SCTPPathVariables* path, const doub
     // ====== Compute new cwnd ===============================================
     const int32 newCwnd = (int32)ceil(path->cwnd - reduction);
     // NOTE: newCwnd may be negative!
+#ifdef PRIVATE
+    // ====== Block path if newCwnd < 1 MTU ==================================
+    if( (state->rpPathBlocking == true) && (newCwnd < (int32)path->pmtu) ) {
+        if( (path->blockingTimeout < 0.0) || (path->blockingTimeout < simTime()) ) {
+            // printf("a=%1.9f b=%1.9f   a=%d b=%d\n", path->blockingTimeout.dbl(), simTime().dbl(), (path->blockingTimeout < 0.0), (path->blockingTimeout < simTime()) );
+
+            const simtime_t timeout = (state->rpScaleBlockingTimeout == true) ?
+                                      path->cmtGroupPaths * path->pathRto :
+                                      path->pathRto;
+            sctpEV3 << "Blocking " << path->remoteAddress << " for " << timeout << endl;
+
+            path->blockingTimeout = simTime() + timeout;
+            assert(!path->BlockingTimer->isScheduled());
+            startTimer(path->BlockingTimer, timeout);
+        }
+    }
+#endif
     return (newCwnd);
 }
 
@@ -101,16 +313,91 @@ void SCTPAssociation::cwndUpdateAfterSack()
             // ====== Retransmission required -> reduce congestion window ======
             if (path->requiresRtx) {
                 double decreaseFactor = 0.5;
-                path->ssthresh = max((int32)path->cwnd - (int32)rint(decreaseFactor * (double)path->cwnd),
-                        4 * (int32)path->pmtu);
-                path->cwnd = path->ssthresh;
+#ifdef PRIVATE
+                sctpEV3 << assocId << ": "<< simTime() << ":\tCC [cwndUpdateAfterSack]\t" << path->remoteAddress
+                        << " (cmtCCGroup=" << path->cmtCCGroup << ")"
+                        << "\tsst="     << path->ssthresh
+                        << "\tcwnd="    << path->cwnd
+                        << "\tSST="     << path->cmtGroupTotalSsthresh
+                        << "\tCWND="    << path->cmtGroupTotalCwnd
+                        << "\tBW.CWND=" << path->cmtGroupTotalCwndBandwidth;
+                if(state->highSpeedCC == true) {
+                   decreaseFactor = HighSpeedCwndAdjustmentTable[path->highSpeedCCThresholdIdx].decreaseFactor;
+                   sctpEV3 << "\tHighSpeedDecreaseFactor=" << decreaseFactor;
+                }
+
+                // ====== SCTP or CMT-SCTP (independent congestion control) =====
+                if( (state->allowCMT == false) ||
+                    (state->cmtCCVariant == SCTPStateVariables::CCCV_CMT) ) {
+#endif
+                    path->ssthresh = max((int32)path->cwnd - (int32)rint(decreaseFactor * (double)path->cwnd),
+                                         4 * (int32)path->pmtu);
+                    path->cwnd = path->ssthresh;
+#ifdef PRIVATE
+                }
+                // ====== Resource Pooling ======================================
+                else {
+                    // ====== CMT/RP-SCTPv1 Fast Retransmit ======================
+                    if(state->cmtCCVariant == SCTPStateVariables::CCCV_CMTRPv1) {
+                        const double sstRatio    = (double)path->ssthresh / (double)path->cmtGroupTotalSsthresh;
+                        const int32  reducedCwnd = rpPathBlockingControl(path, rint(path->cmtGroupTotalCwnd * decreaseFactor));
+                        path->ssthresh = max(reducedCwnd,
+                                             max((int32)path->pmtu,
+                                                 (int32)ceil((double)state->rpMinCwnd * (double)path->pmtu * sstRatio)));
+                        path->cwnd     = path->ssthresh;
+                    }
+                    // ====== CMT/RPv2-SCTP Fast Retransmit ======================
+                    else if(state->cmtCCVariant == SCTPStateVariables::CCCV_CMTRPv2) {
+                        // Bandwidth is based on cwnd, *not* ssthresh!
+                        const double pathBandwidth   = path->cwnd / GET_SRTT(path->srtt.dbl());
+                        const double bandwidthToGive = path->cmtGroupTotalCwndBandwidth / 2.0;
+                        const double reductionFactor = max(0.5, bandwidthToGive / pathBandwidth);
+                        const int32  reducedCwnd     = rpPathBlockingControl(path, reductionFactor * path->cwnd);
+                        path->ssthresh = (int32)max(reducedCwnd, (int32)state->rpMinCwnd * (int32)path->pmtu);
+                        path->cwnd     = path->ssthresh;
+                    }
+                    // ====== Like MPTCP Fast Retransmit =========================
+                    else if(state->cmtCCVariant == SCTPStateVariables::CCCV_Like_MPTCP) {
+                        // Just like plain CMT-SCTP ...
+                        const int32 reducedCwnd = rpPathBlockingControl(path, rint(decreaseFactor * (double)path->cwnd));
+                        path->ssthresh = max(reducedCwnd, (int32)state->rpMinCwnd * (int32)path->pmtu);
+                        path->cwnd     = path->ssthresh;
+                    }
+                    // ====== TEST Fast Retransmit ===============================
+                    else if(state->cmtCCVariant == SCTPStateVariables::CCCV_CMTRP_Test1) {
+                        // Bandwidth is based on cwnd, *not* ssthresh!
+                        const double pathBandwidth   = path->cwnd / GET_SRTT(path->srtt.dbl());
+                        const double bandwidthToGive = path->cmtGroupTotalCwndBandwidth / 2.0;
+                        const double reductionFactor = max(0.5, bandwidthToGive / pathBandwidth);
+                        const int32  reducedCwnd     = rpPathBlockingControl(path, reductionFactor * path->cwnd);
+                        path->ssthresh = (int32)max(reducedCwnd, (int32)state->rpMinCwnd * (int32)path->pmtu);
+                        path->cwnd     = path->ssthresh;
+                    }
+                    // ====== TEST Fast Retransmit ===============================
+                    else if(state->cmtCCVariant == SCTPStateVariables::CCCV_CMTRP_Test2) {
+                        // Just like CMT-SCTP ...
+                        const int32 reducedCwnd = rpPathBlockingControl(path, rint(decreaseFactor * (double)path->cwnd));
+                        path->ssthresh = max(reducedCwnd, (int32)state->rpMinCwnd * (int32)path->pmtu);
+                        path->cwnd     = path->ssthresh;
+                    }
+                    // ====== Other -> error =====================================
+                    else {
+                        throw cRuntimeError("Implementation for this cmtCCVariant is missing!");
+                    }
+                }
+#endif
 
                 recordCwndUpdate(path);
                 path->partialBytesAcked = 0;
 
                 path->vectorPathPbAcked->record(path->partialBytesAcked);
-                sctpEV3 << "\t=>\tsst=" << path->ssthresh
-                        << "\tcwnd=" << path->cwnd << endl;
+ #ifdef PRIVATE
+                if(state->highSpeedCC == true) {
+                    updateHighSpeedCCThresholdIdx(path);
+                }
+#endif
+               sctpEV3 << "\t=>\tsst=" << path->ssthresh
+                       << "\tcwnd=" << path->cwnd << endl;
 
                 // ====== Fast Recovery =========================================
                 if (state->fastRecoverySupported) {
@@ -141,6 +428,10 @@ void SCTPAssociation::cwndUpdateAfterSack()
                     sctpEV3 << assocId << ": " << simTime() << ":\tCC [cwndUpdateAfterSack] Entering Fast Recovery on path "
                             << path->remoteAddress
                             << ", exit point is " << path->fastRecoveryExitPoint
+#ifdef PRIVATE
+                            << ", pseudoCumAck=" << path->pseudoCumAck
+                            << ", rtxPseudoCumAck=" << path->rtxPseudoCumAck
+#endif
                             << endl;
                 }
             }
@@ -164,9 +455,78 @@ void SCTPAssociation::cwndUpdateAfterRtxTimeout(SCTPPathVariables* path)
     cwndUpdateBeforeSack();
 
     double decreaseFactor = 0.5;
-    path->ssthresh = max((int32)path->cwnd - (int32)rint(decreaseFactor * (double)path->cwnd),
-            4 * (int32)path->pmtu);
-    path->cwnd = path->pmtu;
+#ifdef PRIVATE
+    sctpEV3 << assocId << ": " << simTime() << ":\tCC [cwndUpdateAfterRtxTimeout]\t" << path->remoteAddress
+            << " (cmtCCGroup=" << path->cmtCCGroup << ")"
+            << "\tsst="     << path->ssthresh
+            << "\tcwnd="    << path->cwnd
+            << "\tSST="     << path->cmtGroupTotalSsthresh
+            << "\tCWND="    << path->cmtGroupTotalCwnd
+            << "\tBW.CWND=" << path->cmtGroupTotalCwndBandwidth;
+    if(state->highSpeedCC == true) {
+        decreaseFactor = HighSpeedCwndAdjustmentTable[path->highSpeedCCThresholdIdx].decreaseFactor;
+        sctpEV3 << "\tHighSpeedDecreaseFactor=" << decreaseFactor;
+    }
+
+    // ====== SCTP or CMT-SCTP (independent congestion control) ==============
+    if( (state->allowCMT == false) || (state->cmtCCVariant == SCTPStateVariables::CCCV_CMT) ) {
+#endif
+        path->ssthresh = max((int32)path->cwnd - (int32)rint(decreaseFactor * (double)path->cwnd),
+                             4 * (int32)path->pmtu);
+        path->cwnd = path->pmtu;
+#ifdef PRIVATE
+    }
+    // ====== Resource Pooling RTX Timeout ===================================
+    else {
+        // ====== CMT/RPv1-SCTP RTX Timeout ===================================
+        if(state->cmtCCVariant == SCTPStateVariables::CCCV_CMTRPv1) {
+            const double sstRatio        = (double)path->ssthresh / (double)path->cmtGroupTotalSsthresh;
+            const int32  decreasedWindow = (int32)path->cwnd - (int32)rint(path->cmtGroupTotalCwnd * decreaseFactor);
+            path->ssthresh = max(decreasedWindow,
+                                 max((int32)path->pmtu,
+                                     (int32)ceil((double)state->rpMinCwnd * (double)path->pmtu * sstRatio)));
+            path->cwnd = max((int32)path->pmtu,
+                             (int32)ceil((double)path->pmtu * sstRatio));
+        }
+        // ====== CMT/RPv2-SCTP RTX Timeout ===================================
+        else if(state->cmtCCVariant == SCTPStateVariables::CCCV_CMTRPv2) {
+            const double pathBandwidth   = path->cwnd / GET_SRTT(path->srtt.dbl());
+            const double bandwidthToGive = path->cmtGroupTotalCwndBandwidth / 2.0;
+            const double reductionFactor = max(0.5, bandwidthToGive / pathBandwidth);
+
+            path->ssthresh = (int32)max((int32)state->rpMinCwnd * (int32)path->pmtu,
+                                        (int32)ceil(path->cwnd - reductionFactor * path->cwnd));
+            path->cwnd = path->pmtu;
+        }
+        // ====== Like MPTCP RTX Timeout ======================================
+        else if(state->cmtCCVariant == SCTPStateVariables::CCCV_Like_MPTCP) {
+            path->ssthresh = max((int32)path->cwnd - (int32)rint(decreaseFactor * (double)path->cwnd),
+                                 (int32)state->rpMinCwnd * (int32)path->pmtu);
+            path->cwnd     = path->pmtu;
+        }
+        // ====== TEST RTX Timeout ============================================
+        else if(state->cmtCCVariant == SCTPStateVariables::CCCV_CMTRP_Test1) {
+            const double pathBandwidth   = path->cwnd / GET_SRTT(path->srtt.dbl());
+            const double bandwidthToGive = path->cmtGroupTotalCwndBandwidth / 2.0;
+            const double reductionFactor = max(0.5, bandwidthToGive / pathBandwidth);
+
+            path->ssthresh = (int32)max((int32)state->rpMinCwnd * (int32)path->pmtu,
+                                        (int32)ceil(path->cwnd - reductionFactor * path->cwnd));
+            path->cwnd = path->pmtu;
+        }
+        // ====== Like MPTCP RTX Timeout ======================================
+        else if(state->cmtCCVariant == SCTPStateVariables::CCCV_CMTRP_Test2) {
+            path->ssthresh = max((int32)path->cwnd - (int32)rint(decreaseFactor * (double)path->cwnd),
+                                 (int32)state->rpMinCwnd * (int32)path->pmtu);
+            path->cwnd     = path->pmtu;
+        }
+        // ====== Other -> error ==============================================
+        else {
+            throw cRuntimeError("Implementation for this cmtCCVariant is missing!");
+        }
+    }
+    path->highSpeedCCThresholdIdx = 0;
+#endif
     path->partialBytesAcked = 0;
     path->vectorPathPbAcked->record(path->partialBytesAcked);
     sctpEV3 << "\t=>\tsst=" << path->ssthresh
@@ -197,9 +557,69 @@ void SCTPAssociation::cwndUpdateBytesAcked(SCTPPathVariables* path,
             path->partialBytesAcked = 0;
 
             // ------ Increase Congestion Window -------------------------------
+#ifndef PRIVATE
+            if ((ctsnaAdvanced == true) &&
+                (path->outstandingBytesBeforeUpdate >= path->cwnd)) {
+#else
             if ((ctsnaAdvanced == true) &&
-                    (path->outstandingBytesBeforeUpdate >= path->cwnd)) {
-                path->cwnd += (int32)min(path->pmtu, ackedBytes);
+                ((path->outstandingBytesBeforeUpdate >= path->cwnd) ||
+                 ((state->strictCwndBooking) && (path->outstandingBytesBeforeUpdate + path->pmtu > path->cwnd)))) {
+               sctpEV3 << assocId << ": "<< simTime() << ":\tCC [cwndUpdateBytesAcked-SlowStart]\t" << path->remoteAddress
+                       << " (cmtCCGroup=" << path->cmtCCGroup << ")"
+                       << "\tacked="   << ackedBytes
+                       << "\tsst="     << path->ssthresh
+                       << "\tcwnd="    << path->cwnd
+                       << "\tSST="     << path->cmtGroupTotalSsthresh
+                       << "\tCWND="    << path->cmtGroupTotalCwnd
+                       << "\tBW.CWND=" << path->cmtGroupTotalCwndBandwidth;
+
+                // ====== SCTP or CMT-SCTP (independent congestion control) =====
+                if( (state->allowCMT == false) || (state->cmtCCVariant == SCTPStateVariables::CCCV_CMT) ) {
+#endif
+                    path->cwnd += (int32)min(path->pmtu, ackedBytes);
+#ifdef PRIVATE
+                }
+                // ====== Resource Pooling Slow Start ===========================
+                else {
+                    // ====== CMT/RPv1-SCTP Slow Start ===========================
+                    if(state->cmtCCVariant == SCTPStateVariables::CCCV_CMTRPv1) {
+                        const double sstRatio = (double)path->ssthresh / (double)path->cmtGroupTotalSsthresh;
+                        path->cwnd += (int32)ceil(min(path->pmtu, ackedBytes) * sstRatio);
+                    }
+                    // ====== CMT/RPv2-SCTP Slow Start ===========================
+                    else if(state->cmtCCVariant == SCTPStateVariables::CCCV_CMTRPv2) {
+                        // Increase ratio based on cwnd bandwidth share!
+                        const double increaseRatio = ((double)path->cwnd / GET_SRTT(path->srtt.dbl())) /
+                                                         (double)path->cmtGroupTotalCwndBandwidth;
+                        path->cwnd += (int32)ceil(min(path->pmtu, ackedBytes) * increaseRatio);
+                    }
+                    // ====== Like MPTCP Slow Start ==============================
+                    else if(state->cmtCCVariant == SCTPStateVariables::CCCV_Like_MPTCP) {
+                        // T.D. 14.08.2011: Rewrote MPTCP-Like CC code
+                        path->cwnd = updateMPTCP(path->cwnd, path->cmtGroupTotalCwnd,
+                                                 path->cmtGroupAlpha, path->pmtu, ackedBytes);
+                    }
+                    // ====== TEST Slow Start ====================================
+                    else if(state->cmtCCVariant == SCTPStateVariables::CCCV_CMTRP_Test1) {
+                        // Increase ratio based on cwnd bandwidth share!
+                        const double increaseRatio = ((double)path->utilizedCwnd / GET_SRTT(path->srtt.dbl())) /
+                                                         (double)path->cmtGroupTotalUtilizedCwndBandwidth;
+                        path->cwnd += (int32)ceil(min(path->pmtu, ackedBytes) * increaseRatio);
+                    }
+                    // ====== Like MPTCP Slow Start ==============================
+                    else if(state->cmtCCVariant == SCTPStateVariables::CCCV_CMTRP_Test2) {
+                        path->cwnd = updateMPTCP(path->cwnd, path->cmtGroupTotalCwnd,
+                                                 path->cmtGroupAlpha, path->pmtu, ackedBytes);
+                    }
+                    // ====== Other -> error =====================================
+                    else {
+                        throw cRuntimeError("Implementation for this cmtCCVariant is missing!");
+                    }
+                }
+                path->vectorPathPbAcked->record(path->partialBytesAcked);
+                sctpEV3 << "\t=>\tsst=" << path->ssthresh
+                        << "\tcwnd=" << path->cwnd << endl;
+#endif
 
                 recordCwndUpdate(path);
             }
@@ -226,10 +646,84 @@ void SCTPAssociation::cwndUpdateBytesAcked(SCTPPathVariables* path,
 
             // ------ Increase Congestion Window -------------------------------
             double increaseFactor = 1.0;
+#ifndef PRIVATE
             if ( (path->partialBytesAcked >= path->cwnd) &&
-                    (ctsnaAdvanced == true) &&
-                    (path->outstandingBytesBeforeUpdate >= path->cwnd) ) {
-                path->cwnd += (int32)rint(increaseFactor * path->pmtu);
+                 (ctsnaAdvanced == true) &&
+                 (path->outstandingBytesBeforeUpdate >= path->cwnd) ) {
+#else
+            if(state->highSpeedCC == true) {
+               updateHighSpeedCCThresholdIdx(path);
+               increaseFactor = HighSpeedCwndAdjustmentTable[path->highSpeedCCThresholdIdx].increaseFactor;
+               sctpEV3 << "HighSpeedCC Increase: factor=" << increaseFactor << endl;
+            }
+
+            const bool avancedAndEnoughOutstanding =
+                 (ctsnaAdvanced == true) &&
+                 ( (path->outstandingBytesBeforeUpdate >= path->cwnd) ||
+                   ( (state->strictCwndBooking) &&
+                     (path->outstandingBytesBeforeUpdate + path->pmtu > path->cwnd) ) );
+            const bool enoughPartiallyAcked =
+                  (path->partialBytesAcked >= path->cwnd) ||
+                  ( (state->strictCwndBooking) &&
+                    (path->partialBytesAcked >= path->pmtu) &&
+                    (path->partialBytesAcked + path->pmtu > path->cwnd) );
+
+            if ( avancedAndEnoughOutstanding && enoughPartiallyAcked) {
+               sctpEV3 << assocId << ": " << simTime() << ":\tCC [cwndUpdateBytesAcked-CgAvoidance]\t" << path->remoteAddress
+                       << " (cmtCCGroup=" << path->cmtCCGroup << ")"
+                       << "\tacked="   << ackedBytes
+                       << "\tsst="     << path->ssthresh
+                       << "\tcwnd="    << path->cwnd
+                       << "\tSST="     << path->cmtGroupTotalSsthresh
+                       << "\tCWND="    << path->cmtGroupTotalCwnd
+                       << "\tBW.CWND=" << path->cmtGroupTotalCwndBandwidth;
+
+               // ====== SCTP or CMT-SCTP (independent congestion control) =====
+               if( (state->allowCMT == false) || (state->cmtCCVariant == SCTPStateVariables::CCCV_CMT) ) {
+#endif
+                   path->cwnd += (int32)rint(increaseFactor * path->pmtu);
+#ifdef PRIVATE
+                }
+                // ====== Resource Pooling Congestion Avoidance =================
+                else {
+                    // ====== CMT/RP-SCTP Congestion Avoidance ===================
+                    if(state->cmtCCVariant == SCTPStateVariables::CCCV_CMTRPv1) {
+                        const double sstRatio = (double)path->ssthresh / (double)path->cmtGroupTotalSsthresh;
+                        path->cwnd += (int32)ceil(increaseFactor * path->pmtu * sstRatio);
+                    }
+                    // ====== CMT/RPv2-SCTP Congestion Avoidance =================
+                    else if(state->cmtCCVariant == SCTPStateVariables::CCCV_CMTRPv2) {
+                        // Increase ratio based on cwnd bandwidth share!
+                        const double increaseRatio = ((double)path->cwnd / GET_SRTT(path->srtt.dbl())) /
+                                                         (double)path->cmtGroupTotalCwndBandwidth;
+                        path->cwnd += (int32)ceil(increaseFactor * path->pmtu * increaseRatio);
+                    }
+                    // ====== Like MPTCP Congestion Avoidance ====================
+                    else if(state->cmtCCVariant == SCTPStateVariables::CCCV_Like_MPTCP) {
+                        // T.D. 14.08.2011: Rewrote MPTCP-Like CC code
+                        path->cwnd = updateMPTCP(path->cwnd, path->cmtGroupTotalCwnd,
+                                                 path->cmtGroupAlpha, path->pmtu, path->pmtu);
+                    }
+                    // ====== TEST Congestion Avoidance ==========================
+                    else if(state->cmtCCVariant == SCTPStateVariables::CCCV_CMTRP_Test1) {
+                        // Increase ratio based on cwnd bandwidth share!
+                        const double increaseRatio = ((double)path->utilizedCwnd / GET_SRTT(path->srtt.dbl())) /
+                                                         (double)path->cmtGroupTotalUtilizedCwndBandwidth;
+                        path->cwnd += (int32)ceil(increaseFactor * path->pmtu * increaseRatio);
+                    }
+                    // ====== TEST Congestion Avoidance ==========================
+                    else if(state->cmtCCVariant == SCTPStateVariables::CCCV_CMTRP_Test2) {
+                        path->cwnd = updateMPTCP(path->cwnd, path->cmtGroupTotalCwnd,
+                                                 path->cmtGroupAlpha, path->pmtu, path->pmtu);
+                    }
+                    // ====== Other -> error =====================================
+                    else {
+                        throw cRuntimeError("Implementation for this cmtCCVariant is missing!");
+                    }
+                }
+                sctpEV3 << "\t=>\tsst=" << path->ssthresh
+                        << "\tcwnd=" << path->cwnd << endl;
+#endif
                 recordCwndUpdate(path);
                 path->partialBytesAcked =
                         ((path->cwnd < path->partialBytesAcked) ?
@@ -274,7 +768,13 @@ void SCTPAssociation::updateFastRecoveryStatus(const uint32 lastTsnAck)
 
         if (path->fastRecoveryActive) {
             if ( (tsnGt(lastTsnAck, path->fastRecoveryExitPoint)) ||
-                    (lastTsnAck == path->fastRecoveryExitPoint)
+                 (lastTsnAck == path->fastRecoveryExitPoint)
+#ifdef PRIVATE
+                 || ((state->allowCMT) && (state->cmtUseFRC) &&
+                     ((path->newPseudoCumAck && tsnGt(path->pseudoCumAck, path->fastRecoveryExitPoint)) ||
+                      (path->newRTXPseudoCumAck && tsnGt(path->rtxPseudoCumAck, path->fastRecoveryExitPoint)))
+                    )
+#endif
             ) {
                 path->fastRecoveryActive = false;
                 path->fastRecoveryExitPoint = 0;
@@ -283,6 +783,12 @@ void SCTPAssociation::updateFastRecoveryStatus(const uint32 lastTsnAck)
                 sctpEV3 << assocId << ": " << simTime() << ":\tCC [cwndUpdateAfterSack] Leaving Fast Recovery on path "
                         << path->remoteAddress
                         << ", lastTsnAck=" << lastTsnAck
+#ifdef PRIVATE
+                        << ", pseudoCumAck=" << path->pseudoCumAck
+                        << ", rtxPseudoCumAck=" << path->rtxPseudoCumAck
+                        << ", newPseudoCumAck=" << path->newPseudoCumAck
+                        << ", newRTXPseudoCumAck=" << path->newRTXPseudoCumAck
+#endif
                         << endl;
             }
         }
@@ -292,24 +798,70 @@ void SCTPAssociation::updateFastRecoveryStatus(const uint32 lastTsnAck)
 
 void SCTPAssociation::cwndUpdateMaxBurst(SCTPPathVariables* path)
 {
+#ifdef PRIVATE
+   if( (state->maxBurstVariant == SCTPStateVariables::MBV_UseItOrLoseIt) ||
+       (state->maxBurstVariant == SCTPStateVariables::MBV_CongestionWindowLimiting) ||
+       (state->maxBurstVariant == SCTPStateVariables::MBV_UseItOrLoseItTempCwnd) ||
+       (state->maxBurstVariant == SCTPStateVariables::MBV_CongestionWindowLimitingTempCwnd) ) {
+#endif
 
-    // ====== cwnd allows to send more than the maximum burst size ========
-    if (path->cwnd > ((path->outstandingBytes + state->maxBurst * path->pmtu))) {
-        sctpEV3 << assocId << ": " << simTime() << ":\tCC [cwndUpdateMaxBurst]\t"
-                << path->remoteAddress
-                << "\tsst=" << path->ssthresh
-                << "\tcwnd=" << path->cwnd
-                << "\tosb=" << path->outstandingBytes
-                << "\tmaxBurst=" << state->maxBurst * path->pmtu;
-
-        // ====== Update cwnd ==============================================
-        path->cwnd = path->outstandingBytes + (state->maxBurst * path->pmtu);
-        recordCwndUpdate(path);
-
-        sctpEV3 << "\t=>\tsst=" << path->ssthresh
-                << "\tcwnd=" << path->cwnd
-                << endl;
+        // ====== cwnd allows to send more than the maximum burst size ========
+        if (path->cwnd > ((path->outstandingBytes + state->maxBurst * path->pmtu))) {
+            sctpEV3 << assocId << ": " << simTime() << ":\tCC [cwndUpdateMaxBurst]\t"
+                    << path->remoteAddress
+                    << "\tsst=" << path->ssthresh
+                    << "\tcwnd=" << path->cwnd
+#ifdef PRIVATE
+                    << "\ttempCwnd=" << path->tempCwnd
+#endif
+                    << "\tosb=" << path->outstandingBytes
+                    << "\tmaxBurst=" << state->maxBurst * path->pmtu;
+
+#ifdef PRIVATE
+             // ====== Update cwnd or tempCwnd, according to MaxBurst variant ===
+             if( (state->maxBurstVariant == SCTPStateVariables::MBV_UseItOrLoseIt) ||
+                 (state->maxBurstVariant == SCTPStateVariables::MBV_CongestionWindowLimiting) ) {
+                path->cwnd = path->outstandingBytes + (state->maxBurst * path->pmtu);
+             }
+             else if( (state->maxBurstVariant == SCTPStateVariables::MBV_UseItOrLoseItTempCwnd) ||
+                      (state->maxBurstVariant == SCTPStateVariables::MBV_CongestionWindowLimitingTempCwnd) ) {
+                path->tempCwnd = path->outstandingBytes + (state->maxBurst * path->pmtu);
+             }
+             else {
+                assert(false);
+             }
+
+             if(state->maxBurstVariant == SCTPStateVariables::MBV_CongestionWindowLimiting) {
+                if(path->ssthresh < path->cwnd) {
+                   path->ssthresh = path->cwnd;
+                }
+             }
+             if(state->maxBurstVariant == SCTPStateVariables::MBV_CongestionWindowLimitingTempCwnd) {
+                if(path->ssthresh < path->tempCwnd) {
+                   path->ssthresh = path->tempCwnd;
+                }
+             }
+#else
+            // ====== Update cwnd ==============================================
+            path->cwnd = path->outstandingBytes + (state->maxBurst * path->pmtu);
+#endif
+            recordCwndUpdate(path);
+
+            sctpEV3 << "\t=>\tsst=" << path->ssthresh
+                    << "\tcwnd=" << path->cwnd
+#ifdef PRIVATE
+                    << "\ttempCwnd=" << path->tempCwnd
+#endif
+                    << endl;
+        }
+#ifdef PRIVATE
+        // ====== Possible transmission will not exceed burst size ============
+        else {
+            // Just store current cwnd to tempCwnd
+            path->tempCwnd = path->cwnd;
+        }
     }
+#endif
 }
 
 
@@ -318,6 +870,9 @@ void SCTPAssociation::cwndUpdateAfterCwndTimeout(SCTPPathVariables* path)
     // When the association does not transmit data on a given transport address
     // within an RTO, the cwnd of the transport address SHOULD be adjusted to 2*MTU.
     sctpEV3 << assocId << ": " << simTime() << ":\tCC [cwndUpdateAfterCwndTimeout]\t" << path->remoteAddress
+#ifdef PRIVATE
+            << " (cmtCCGroup=" << path->cmtCCGroup << ")"
+#endif
             << "\tsst=" << path->ssthresh
             << "\tcwnd=" << path->cwnd;
     path->cwnd = getInitialCwnd(path);
diff --git a/src/transport/sctp/SCTPSSFunctions.cc b/src/transport/sctp/SCTPSSFunctions.cc
index 2692dc1..2aba7bd 100644
--- a/src/transport/sctp/SCTPSSFunctions.cc
+++ b/src/transport/sctp/SCTPSSFunctions.cc
@@ -55,6 +55,17 @@ void SCTPAssociation::initStreams(uint32 inStreams, uint32 outStreams)
         {
             SCTPSendStream* sendStream = new SCTPSendStream(i);
             sendStream->setStreamId(i);
+#ifdef PRIVATE
+            char str[128];
+            snprintf(str, sizeof(str), "Ordered Stream %d:%d", assocId, sendStream->getStreamId());
+            sendStream->OrderedQoS.initialize(sctpMain, str);
+            snprintf(str, sizeof(str), "Unordered Stream %d:%d", assocId, sendStream->getStreamId());
+            sendStream->UnorderedQoS.initialize(sctpMain, str);
+            if(getSctpMain()->par("allowQoSTracking")) {
+                sendStream->OrderedQoS.activate(((simtime_t)getSctpMain()->par("qosTrackingInterval")).dbl());
+                sendStream->UnorderedQoS.activate(((simtime_t)getSctpMain()->par("qosTrackingInterval")).dbl());
+            }
+#endif
             sendStreams[i] = sendStream;
         }
     }
diff --git a/src/transport/sctp/SCTPSendStream.h b/src/transport/sctp/SCTPSendStream.h
index 87c4066..efa82b3 100644
--- a/src/transport/sctp/SCTPSendStream.h
+++ b/src/transport/sctp/SCTPSendStream.h
@@ -24,6 +24,9 @@
 #include <assert.h>
 #include "SCTPQueue.h"
 #include "SCTPAssociation.h"
+#ifdef PRIVATE
+#include "QoSStatsCollector.h"
+#endif
 #include "SCTPMessage_m.h"
 
 class SCTPMessage;
@@ -86,6 +89,13 @@ class INET_API SCTPSendStream : public cPolymorphic
     inline unsigned long long getQueuedBytes() const {
        return (streamQ->getByteLength() + uStreamQ->getByteLength());
     }
+
+#ifdef PRIVATE
+  public:
+    // ====== QoS-SCTP ======================================================
+    QoSStatsCollector  OrderedQoS;                     // T.D. 11.08.2010
+    QoSStatsCollector  UnorderedQoS;                   // T.D. 11.08.2010
+#endif
 };
 
 #endif
diff --git a/src/transport/tcp/TCPConnection.h b/src/transport/tcp/TCPConnection.h
index d499321..e98c415 100644
--- a/src/transport/tcp/TCPConnection.h
+++ b/src/transport/tcp/TCPConnection.h
@@ -1,6 +1,8 @@
 //
 // Copyright (C) 2004 Andras Varga
 // Copyright (C) 2009-2010 Thomas Reschka
+// Copyright (C) 2010 Robin Seggelmann
+// Copyright (C) 2010-2011 Thomas Dreibholz
 //
 // This program is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public License
@@ -87,6 +89,7 @@ enum TCPEventCode
     TCP_E_CLOSE,
     TCP_E_ABORT,
     TCP_E_STATUS,
+    TCP_E_QUEUE_BYTES_LIMIT,
 
     // TPDU types
     TCP_E_RCV_DATA,
@@ -241,6 +244,10 @@ class INET_API TCPStateVariables : public cPolymorphic
     uint32 sackedBytes_old;  // old number of sackedBytes - needed for RFC 3042 to check if last dupAck contained new sack information
     bool lossRecovery;       // indicates if algorithm is in loss recovery phase
 
+    // queue management
+    uint32 sendQueueLimit;
+    bool queueUpdate;
+
     // those counters would logically belong to TCPAlgorithm, but it's a lot easier to manage them here
     uint32 dupacks;          // current number of received consecutive duplicate ACKs
     uint32 snd_sacks;        // number of sent sacks
@@ -382,6 +389,7 @@ class INET_API TCPConnection
     virtual void process_CLOSE(TCPEventCode& event, TCPCommand *tcpCommand, cMessage *msg);
     virtual void process_ABORT(TCPEventCode& event, TCPCommand *tcpCommand, cMessage *msg);
     virtual void process_STATUS(TCPEventCode& event, TCPCommand *tcpCommand, cMessage *msg);
+    virtual void process_QUEUE_BYTES_LIMIT(TCPEventCode& event, TCPCommand *tcpCommand, cMessage *msg);
     //@}
 
     /** @name Processing TCP segment arrivals. Invoked from processTCPSegment(). */
@@ -521,7 +529,7 @@ class INET_API TCPConnection
     virtual void sendToApp(cMessage *msg);
 
     /** Utility: sends status indication (TCP_I_xxx) to application */
-    virtual void sendIndicationToApp(int code);
+    virtual void sendIndicationToApp(int code, const int id = 0);
 
     /** Utility: sends TCP_I_ESTABLISHED indication with TCPConnectInfo to application */
     virtual void sendEstabIndicationToApp();
diff --git a/src/transport/tcp/TCPConnectionBase.cc b/src/transport/tcp/TCPConnectionBase.cc
index fb57f5b..b613092 100644
--- a/src/transport/tcp/TCPConnectionBase.cc
+++ b/src/transport/tcp/TCPConnectionBase.cc
@@ -1,6 +1,8 @@
 //
 // Copyright (C) 2004 Andras Varga
 // Copyright (C) 2009-2010 Thomas Reschka
+// Copyright (C) 2010 Robin Seggelmann
+// Copyright (C) 2010-2011 Thomas Dreibholz
 //
 // This program is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public License
@@ -76,7 +78,7 @@ TCPStateVariables::TCPStateVariables()
     snd_ws = false;
     rcv_ws = false;
     rcv_wnd_scale = 0;        // will be set from configureStateVariables()
-    snd_wnd_scale = 0;      
+    snd_wnd_scale = 0;
 
     ts_support = false;       // will be set from configureStateVariables()
     ts_enabled = false;
@@ -110,6 +112,8 @@ TCPStateVariables::TCPStateVariables()
     usedRcvBuffer = 0;
     freeRcvBuffer = 0;
     tcpRcvQueueDrops = 0;
+    sendQueueLimit = 0;
+    queueUpdate = true;
 }
 
 std::string TCPStateVariables::info() const
@@ -360,6 +364,7 @@ bool TCPConnection::processAppCommand(cMessage *msg)
         case TCP_E_CLOSE: process_CLOSE(event, tcpCommand, msg); break;
         case TCP_E_ABORT: process_ABORT(event, tcpCommand, msg); break;
         case TCP_E_STATUS: process_STATUS(event, tcpCommand, msg); break;
+        case TCP_E_QUEUE_BYTES_LIMIT: process_QUEUE_BYTES_LIMIT(event, tcpCommand, msg); break;
         default: opp_error("wrong event code");
     }
 
@@ -372,12 +377,13 @@ TCPEventCode TCPConnection::preanalyseAppCommandEvent(int commandCode)
 {
     switch (commandCode)
     {
-        case TCP_C_OPEN_ACTIVE:  return TCP_E_OPEN_ACTIVE;
-        case TCP_C_OPEN_PASSIVE: return TCP_E_OPEN_PASSIVE;
-        case TCP_C_SEND:         return TCP_E_SEND;
-        case TCP_C_CLOSE:        return TCP_E_CLOSE;
-        case TCP_C_ABORT:        return TCP_E_ABORT;
-        case TCP_C_STATUS:       return TCP_E_STATUS;
+        case TCP_C_OPEN_ACTIVE:       return TCP_E_OPEN_ACTIVE;
+        case TCP_C_OPEN_PASSIVE:      return TCP_E_OPEN_PASSIVE;
+        case TCP_C_SEND:              return TCP_E_SEND;
+        case TCP_C_CLOSE:             return TCP_E_CLOSE;
+        case TCP_C_ABORT:             return TCP_E_ABORT;
+        case TCP_C_STATUS:            return TCP_E_STATUS;
+        case TCP_C_QUEUE_BYTES_LIMIT: return TCP_E_QUEUE_BYTES_LIMIT;
         default: opp_error("Unknown message kind in app command");
                  return (TCPEventCode)0; // to satisfy compiler
     }
diff --git a/src/transport/tcp/TCPConnectionEventProc.cc b/src/transport/tcp/TCPConnectionEventProc.cc
index f373980..70d0ecf 100644
--- a/src/transport/tcp/TCPConnectionEventProc.cc
+++ b/src/transport/tcp/TCPConnectionEventProc.cc
@@ -1,5 +1,7 @@
 //
 // Copyright (C) 2004 Andras Varga
+// Copyright (C) 2010 Robin Seggelmann
+// Copyright (C) 2010-2011 Thomas Dreibholz
 //
 // This program is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public License
@@ -154,6 +156,10 @@ void TCPConnection::process_SEND(TCPEventCode& event, TCPCommand *tcpCommand, cM
             opp_error("Error processing command SEND: connection closing");
     }
 
+    if ((state->sendQueueLimit > 0) && (sendQueue->getBytesAvailable(state->snd_una) > state->sendQueueLimit)) {
+       state->queueUpdate = false;
+    }
+
     delete sendCommand; // msg itself has been taken by the sendQueue
 }
 
@@ -285,4 +291,13 @@ void TCPConnection::process_STATUS(TCPEventCode& event, TCPCommand *tcpCommand,
     sendToApp(msg);
 }
 
-
+void TCPConnection::process_QUEUE_BYTES_LIMIT(TCPEventCode& event, TCPCommand *tcpCommand, cMessage *msg)
+{
+   if(state == NULL) {
+      opp_error("Called process_QUEUE_BYTES_LIMIT on uninitialized TCPConnection!");
+   }
+   state->sendQueueLimit = tcpCommand->getUserId();
+   tcpEV<<"state->sendQueueLimit set to "<<state->sendQueueLimit<<"\n";
+   delete msg;
+   delete tcpCommand;
+}
diff --git a/src/transport/tcp/TCPConnectionUtil.cc b/src/transport/tcp/TCPConnectionUtil.cc
index 7c65b75..55b7fe4 100644
--- a/src/transport/tcp/TCPConnectionUtil.cc
+++ b/src/transport/tcp/TCPConnectionUtil.cc
@@ -70,6 +70,7 @@ const char *TCPConnection::eventName(int event)
         CASE(TCP_E_CLOSE);
         CASE(TCP_E_ABORT);
         CASE(TCP_E_STATUS);
+        CASE(TCP_E_QUEUE_BYTES_LIMIT);
         CASE(TCP_E_RCV_DATA);
         CASE(TCP_E_RCV_ACK);
         CASE(TCP_E_RCV_SYN);
@@ -101,6 +102,7 @@ const char *TCPConnection::indicationName(int code)
         CASE(TCP_I_CONNECTION_RESET);
         CASE(TCP_I_TIMED_OUT);
         CASE(TCP_I_STATUS);
+        CASE(TCP_I_SEND_MSG);
     }
     return s;
 #undef CASE
@@ -280,13 +282,14 @@ void TCPConnection::signalConnectionTimeout()
     sendIndicationToApp(TCP_I_TIMED_OUT);
 }
 
-void TCPConnection::sendIndicationToApp(int code)
+void TCPConnection::sendIndicationToApp(int code, const int id)
 {
     tcpEV << "Notifying app: " << indicationName(code) << "\n";
     cMessage *msg = new cMessage(indicationName(code));
     msg->setKind(code);
     TCPCommand *ind = new TCPCommand();
     ind->setConnId(connId);
+    ind->setUserId(id);
     msg->setControlInfo(ind);
     tcpMain->send(msg, "appOut", appGateIndex);
 }
@@ -605,6 +608,16 @@ void TCPConnection::sendSegment(uint32 bytes)
 
     // send it
     sendToIP(tcpseg);
+
+    // let application fill queue again, if there is space
+    const uint32 alreadyQueued = sendQueue->getBytesAvailable(sendQueue->getBufferStartSeq());
+    const uint32 abated        = (state->sendQueueLimit > alreadyQueued) ? state->sendQueueLimit - alreadyQueued : 0;
+    if ((state->sendQueueLimit > 0) && (state->queueUpdate == false) &&
+        (abated >= state->snd_mss)) {   // T.D. 07.09.2010: Just request more data if space >= 1 MSS
+        // Tell upper layer readiness to accept more data
+        sendIndicationToApp(TCP_I_SEND_MSG, abated);
+        state->queueUpdate = true;
+    }
 }
 
 bool TCPConnection::sendData(bool fullSegmentsOnly, uint32 congestionWindow)
@@ -681,7 +694,15 @@ bool TCPConnection::sendData(bool fullSegmentsOnly, uint32 congestionWindow)
     {
         while (bytesToSend >= effectiveMaxBytesSend)
         {
+            const ulong b0 = sendQueue->getBytesAvailable(state->snd_nxt);
             sendSegment(state->snd_mss);
+            const ulong b1 = sendQueue->getBytesAvailable(state->snd_nxt);
+
+            if(b0 - state->sentBytes != b1) {
+               // T.D. 17.11.2011: Nothing more to send -> stop here!
+               // FIXME: This happens sometimes when SACKs are enabled. Is this a bug?
+               break;
+            }
             bytesToSend -= state->sentBytes;
         }
     }
